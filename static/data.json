[{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"","content":"undefined","url":"/cloud/cli-reference"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Spin","content":"This page documents the Spin Command Line Interface (CLI). Specifically, all of the available Spin Options and Subcommands. You can reproduce this documentation on your machine by using the --help For example:$ spin --help\n\nUSAGE:\n    spin <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    add          Scaffold a new component into an existing application\n    bindle       Commands for publishing applications as bindles\n    build        Build the Spin application\n    deploy       Deploy a Spin application\n    help         Print this message or the help of the given subcommand(s)\n    login        Log into the server\n    new          Scaffold a new application based on a template\n    plugin       Install/uninstall Spin plugins\n    templates    Commands for working with WebAssembly component templates\n    up           Start the Spin application","url":"/cloud/cli-reference#spin"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Bindle","content":"Adding a subcommand (and again issuing the --help command) will provide information specific to that particular subcommand. For example:$ spin bindle --help\n\nUSAGE:\n    spin bindle <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help       Print this message or the help of the given subcommand(s)\n    prepare    Create a standalone bindle for subsequent publication\n    push       Publish an application as a bindle","url":"/cloud/cli-reference#spin#bindle"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Prepare (Bindle)","content":"Again, adding another related subcommand provides even more specific information. For example:$ spin bindle prepare --help\n\nUSAGE:\n    spin bindle prepare [OPTIONS] --staging-dir <STAGING_DIR>\n\nOPTIONS:\n        --buildinfo <BUILDINFO>        Build metadata to append to the bindle version\n    -d, --staging-dir <STAGING_DIR>    Path to create standalone bindle\n    -f, --file <APP_CONFIG_FILE>       Path to spin.toml\n    -h, --help                         Print help information","url":"/cloud/cli-reference#spin#bindle#prepare-bindle"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Push (Bindle)","content":"$ spin bindle push --help\n\nUSAGE:\n    spin bindle push [OPTIONS] --bindle-server <BINDLE_SERVER_URL>\n\nOPTIONS:\n        --bindle-password <BINDLE_PASSWORD>\n            Basic http auth password for the bindle server [env: BINDLE_PASSWORD=]\n\n        --bindle-server <BINDLE_SERVER_URL>\n            URL of bindle server [env: BINDLE_URL=]\n\n        --bindle-username <BINDLE_USERNAME>\n            Basic http auth username for the bindle server [env: BINDLE_USERNAME=]\n\n        --buildinfo <BUILDINFO>\n            Build metadata to append to the bindle version\n\n    -d, --staging-dir <STAGING_DIR>\n            Path to assemble the bindle before pushing (defaults to temporary directory)\n\n    -f, --file <APP_CONFIG_FILE>\n            Path to spin.toml\n\n    -h, --help\n            Print help information\n\n    -k, --insecure\n            Ignore server certificate errors","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Build","content":"$ spin build --help\n\nUSAGE:\n    spin build [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -f, --file <APP_CONFIG_FILE>    Path to spin.toml\n    -h, --help                      Print help information\n    -u, --up                        Run the application after building","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Deploy","content":"$ spin deploy --help\n\nUSAGE:\n    spin deploy [OPTIONS]\n\nOPTIONS:\n        --buildinfo <BUILDINFO>\n            Build metadata to append to the bindle version\n\n    -d, --staging-dir <STAGING_DIR>\n            Path to assemble the bindle before pushing (defaults to a temporary directory)\n\n    -e, --deploy-existing-bindle\n            Deploy existing bindle if it already exists on bindle server\n\n        --environment-name <environment-name>\n            Deploy to the Fermyon instance saved under the specified name. If omitted, Spin deploys\n            to the default unnamed instance [env: FERMYON_DEPLOYMENT_ENVIRONMENT=]\n\n    -f, --file <APP_CONFIG_FILE>\n            Path to spin.toml [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n        --no-buildinfo\n            Disable attaching buildinfo [env: SPIN_DEPLOY_NO_BUILDINFO=]\n\n        --readiness-timeout <READINESS_TIMEOUT_SECS>\n            How long in seconds to wait for a deployed HTTP application to become ready. The default\n            is 60 seconds. Set it to 0 to skip waiting for readiness [default: 60]","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Login","content":"spin login --help\n\nUSAGE:\n    spin login [OPTIONS]\n\nOPTIONS:\n        --auth-method <auth-method>\n            [env: AUTH_METHOD=] [possible values: github, username]\n\n        --bindle-password <BINDLE_PASSWORD>\n            Basic http auth password for the bindle server [env: BINDLE_PASSWORD=]\n\n        --bindle-server <BINDLE_SERVER_URL>\n            URL of bindle server [env: BINDLE_URL=]\n\n        --bindle-username <BINDLE_USERNAME>\n            Basic http auth username for the bindle server [env: BINDLE_USERNAME=]\n\n        --environment-name <environment-name>\n            Save the login details under the specified name instead of making them the default. Use\n            named environments with `spin deploy --environment-name <name>` [env:\n            FERMYON_DEPLOYMENT_ENVIRONMENT=]\n\n    -h, --help\n            Print help information\n\n    -k, --insecure\n            Ignore server certificate errors from bindle and hippo\n\n        --list\n            List saved logins\n\n        --password <HIPPO_PASSWORD>\n            Hippo password [env: HIPPO_PASSWORD=]\n\n        --status\n            Display login status\n\n        --url <HIPPO_SERVER_URL>\n            URL of hippo server [env: HIPPO_URL=] [default: http://localhost:5309]\n\n        --username <HIPPO_USERNAME>\n            Hippo username [env: HIPPO_USERNAME=]","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"New","content":"$ spin new --help\n\nUSAGE:\n    spin new [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n        --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the fileThe spin add command is identical to spin new except that it adds a component to an existing application (instead of starting a new application).  It needs an existing spin.toml file, either in the current directory or referenced via the -f option.","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Plugin","content":"$ spin plugin --help\n\nUSAGE:\n    spin plugin <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new#plugin"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Install (Plugin)","content":"$ spin plugin install --help\n\nUSAGE:\n    spin plugin install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new#plugin#install-plugin"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Uninstall (Plugin)","content":"$ spin plugin uninstall --help\n\nUSAGE:\n    spin plugin uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new#plugin#install-plugin#uninstall-plugin"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Update (Plugin)","content":"$ spin plugin update --help\n\nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugin update\n\nOPTIONS:\n    -h, --help    Print help information","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new#plugin#install-plugin#uninstall-plugin#update-plugin"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Upgrade (Plugin)","content":"$ spin plugin upgrade --help\n\nUSAGE:\n    spin plugin upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new#plugin#install-plugin#uninstall-plugin#update-plugin#upgrade-plugin"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Templates","content":"$ spin templates --help\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new#plugin#install-plugin#uninstall-plugin#update-plugin#upgrade-plugin#templates"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Install (Templates)","content":"$ spin templates install --help\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --update\n            If present, updates existing templates instead of skipping","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new#plugin#install-plugin#uninstall-plugin#update-plugin#upgrade-plugin#templates#install-templates"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"List (Templates)","content":"$ spin templates list --help\n\nUSAGE:\n    spin templates list\n\nOPTIONS:\n    -h, --help    Print help information","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new#plugin#install-plugin#uninstall-plugin#update-plugin#upgrade-plugin#templates#install-templates#list-templates"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Uninstall (Templates)","content":"$ spin templates uninstall --help\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new#plugin#install-plugin#uninstall-plugin#update-plugin#upgrade-plugin#templates#install-templates#list-templates#uninstall-templates"},{"project":"cloud","title":"Spin Command Line Interface (CLI) Reference","subheading":"Up","content":"$ spin up --help\n\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n    -b, --bindle <BINDLE_ID>\n            ID of application bindle\n\n        --bindle-password <BINDLE_PASSWORD>\n            Basic http auth password for the bindle server [env: BINDLE_PASSWORD=]\n\n        --bindle-server <BINDLE_SERVER_URL>\n            URL of bindle server [env: BINDLE_URL=]\n\n        --bindle-username <BINDLE_USERNAME>\n            Basic http auth username for the bindle server [env: BINDLE_USERNAME=]\n\n    -e, --env <ENV>\n            Pass an environment variable (key=value) to all components of the application\n\n    -f, --file <APP_CONFIG_FILE>\n            Path to spin.toml\n\n    -h, --help\n            \n\n    -k, --insecure\n            Ignore server certificate errors from bindle server\n\n        --temp <TMP>\n            Temporary directory for the static assets of the components\n``","url":"/cloud/cli-reference#spin#bindle#prepare-bindle#push-bindle#build#deploy#login#new#plugin#install-plugin#uninstall-plugin#update-plugin#upgrade-plugin#templates#install-templates#list-templates#uninstall-templates#up"},{"project":"cloud","title":"Contributing","subheading":"","content":"To contribute to the Fermyon Cloud Documentation, please follow these steps.undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","url":"/cloud/contributing"},{"project":"cloud","title":"Contributing","subheading":"1. Fork the Repository","content":"The first step is to fork the undefined, from Fermyon's GitHub, to your own GitHub account.undefinedEnsure that you are forking the developer repository undefined GitHub account; where you have full editing privileges.","url":"/cloud/contributing#1-fork-the-repository"},{"project":"cloud","title":"Contributing","subheading":"2. Clone the Fork","content":"Copy the URL from the UI in readiness for running the git clone command.undefinedGo ahead and clone the new fork that you just created (the one which resides in your own GitHub account):$ cd ~\n$ git clone git@github.com:yourusername/developer.git\n$ cd developer","url":"/cloud/contributing#1-fork-the-repository#2-clone-the-fork"},{"project":"cloud","title":"Contributing","subheading":"3. Create New Branch","content":"Create a new branch that will house all of your changes for this specific contribution:$ git checkout -b my_new_branch","url":"/cloud/contributing#1-fork-the-repository#2-clone-the-fork#3-create-new-branch"},{"project":"cloud","title":"Contributing","subheading":"4. Add Upstream","content":"Create a new remote for the upstream (a pointer to the original repository to which you are contributing):$ git remote add upstream https://github.com/fermyon/developer","url":"/cloud/contributing#1-fork-the-repository#2-clone-the-fork#3-create-new-branch#4-add-upstream"},{"project":"cloud","title":"Contributing","subheading":"5. Code Blocks and Annotations","content":"It is highly recommended that you use either the <!-- @selectiveCpy --> or the <!-- @nocpy --> annotation before each of your code blocks, and that each code block defines the appropriate undefined. The annotation can be skipped for code blocks with example code snippets i.e. non-terminal or generic output examples.The selective copy annotation (<!-- @selectiveCpy -->) is intended for use when communicating code and/or CLI commands for the reader to copy and paste. The selective copy annotation allows the reader to see the entire code block (both commands and results) but only copies the lines that start with $ into the readers clipboard (minus the $) when the user clicks the copy button. For example, copying the following code block will only copy echo \"hello\" into your clipboard, for pasting.$ echo \"hello\"\nhelloundefinedThe no copy annotation (<!-- @nocpy -->) preceeds a code block where no copy and pasting of code is intended. If using the no copy attribute please still be sure to add the appropriate syntax highliting to your code block (for display purposes).","url":"/cloud/contributing#1-fork-the-repository#2-clone-the-fork#3-create-new-branch#4-add-upstream#5-code-blocks-and-annotations"},{"project":"cloud","title":"Contributing","subheading":"6. Check Content","content":"Once you are satisfied with your contribution, you can programmatically check your content.If you have not done so already, please go ahead and perform the npm install command; to enable Node dependencies such as markdownlint-cli2. Simply run the following command, from the root of the developer repository:$ npm installWith all Node dependencies installed, you can now check for broken links and also lint your markdown files. Simply run the following command, from the root of the developer repository:$ npm test","url":"/cloud/contributing#1-fork-the-repository#2-clone-the-fork#3-create-new-branch#4-add-upstream#5-code-blocks-and-annotations#6-check-content"},{"project":"cloud","title":"Contributing","subheading":"7. Add Changes","content":"Once your changes have been checked, go ahead and add your changes by moving to a top-level directory, under which your changes exist i.e. cd ~/developer.Add your changes by running the following command, from the root of the developer repository:$ git add","url":"/cloud/contributing#1-fork-the-repository#2-clone-the-fork#3-create-new-branch#4-add-upstream#5-code-blocks-and-annotations#6-check-content#7-add-changes"},{"project":"cloud","title":"Contributing","subheading":"8. Commit Changes","content":"Before committing, please ensure that your GitHub installation is configured sufficiently so that you can --signoff as part of the git commit command. For example, please ensure that the user.name and user.email are configured in your terminal. You can check if these are set by typing git config --list.If you need to set these values please use the following commands:$ git config user.name \"yourusername\"$ git config user.email \"youremail@somemail.com\"More information can be found at this GitHub documentation page called undefined.Type the following commit command to ensure that you sign off (--signoff), sign the data (-S) - recommended, and also leave a short message (-m):$ git commit -S --signoff -m \"Updating documentation\"undefined","url":"/cloud/contributing#1-fork-the-repository#2-clone-the-fork#3-create-new-branch#4-add-upstream#5-code-blocks-and-annotations#6-check-content#7-add-changes#8-commit-changes"},{"project":"cloud","title":"Contributing","subheading":"9. Push Changes","content":"At this stage, it is a good idea to just quickly check what GitHub thinks the origin is. For example, if we type git remote -v we can see that the origin is our repo; which we a) forked the original repo into and b) which we then cloned to our local disk so that we could edit:$ git remote -vThe above command will return output similar to the following:origin\tgit@github.com:yourusername/developer.git (fetch)\norigin\tgit@github.com:yourusername/developer.git (push)\nupstream\thttps://github.com/fermyon/developer (fetch)\nupstream\thttps://github.com/fermyon/developer (push)Once you are satisfied go ahead and push your changes:$ git push -u origin my_new_branch","url":"/cloud/contributing#1-fork-the-repository#2-clone-the-fork#3-create-new-branch#4-add-upstream#5-code-blocks-and-annotations#6-check-content#7-add-changes#8-commit-changes#9-push-changes"},{"project":"cloud","title":"Contributing","subheading":"10. Create a Pull Request","content":"If you return to your GitHub repository in your browser, you will notice that a PR has automatically been generated for you.Clicking on the green “Compare and pull request” button will allow you to add a title and description as part of the PR.undefinedYou can also add any information in the textbox provided below the title. For example, screen captures and/or code/console/terminal snippets of your contribution working correctly and/or tests passing etc.Once you have finished creating your PR, please keep an eye on the PR; answering any questions as part of the collaboration process.undefinedThanks for contributing","url":"/cloud/contributing#1-fork-the-repository#2-clone-the-fork#3-create-new-branch#4-add-upstream#5-code-blocks-and-annotations#6-check-content#7-add-changes#8-commit-changes#9-push-changes#10-create-a-pull-request"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"","content":"","url":"/cloud/data-postgres"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"PostgreSQL","content":"undefined, is a powerful, open-source object-relational database system that has earned a strong reputation for reliability, robustness and performance. This tutorial will implement a persistent storage solution for Fermyon Cloud, using PostgreSQL. In this tutorial, we will be using undefined's free PostgreSQL service.","url":"/cloud/data-postgres#postgresql"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Spin and Fermyon Cloud","content":"First, you need to have Spin installed on your computer. Please use the official Fermyon Cloud Quickstart to both undefined Spin and also undefined to Fermyon Cloud.","url":"/cloud/data-postgres#postgresql#spin-and-fermyon-cloud"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Using Spin Application Templates","content":"The Spin CLI facilitates the creation of new Spin applications through the use of application templates. You can install Spin application templates using the undefined. The template we are interested in, for this tutorial, is the experimental http-csharp template. We can go ahead and install it using the following command:$ spin templates install --git https://github.com/fermyon/spin-dotnet-sdk --branch main --updateThe output from the command above will be similar to the following:Copying remote template source\nInstalling template http-csharp...\nInstalled 1 template(s)\n\n+------------------------------------------------------------+\n| Name          Description                                  |\n+============================================================+\n| http-csharp   HTTP request handler using C# (EXPERIMENTAL) |\n+------------------------------------------------------------+","url":"/cloud/data-postgres#postgresql#spin-and-fermyon-cloud#using-spin-application-templates"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Creating Our New Spin Application","content":"The official Spin CLI documentation also has instructions on how to undefined, from an existing template. Using the docs as a reference, we can perform the following:spin new http-csharp httpCSharpApplication\nProject description: A new http-csharp spin application\nHTTP base: /\nHTTP path: /data","url":"/cloud/data-postgres#postgresql#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"CSharp","content":"using Fermyon.Spin.Sdk;\nusing System.Net;\nusing System.Text;\n\nnamespace httpCSharpApplication;\n\npublic static class Handler {\n  [HttpHandler]\n  public static HttpResponse HandleHttpRequest(HttpRequest request) {\n    if (request.Url == Warmup.DefaultWarmupUrl) {\n      return new HttpResponse();\n    }\n\n    var connectionString = \"user=username password=password dbname=databasename host=127.0.0.1\";\n    var result = PostgresOutbound.Query(connectionString, \"SELECT * FROM myTable\");\n\n    var responseText = new StringBuilder();\n\n    responseText.AppendLine($\"Got {result.Rows.Count} row(s)\");\n    responseText.AppendLine($\"COL: [{String.Join(\" | \", result.Columns.Select(FmtCol))}]\");\n\n    string FmtEntry(DbValue v) {\n      return v.Value() switch {\n        null => \"<DBNULL>\",\n          var val => val.ToString() ?? \"<NULL>\",\n      };\n    }\n\n    foreach(var row in result.Rows) {\n      responseText.AppendLine($\"ROW: [{String.Join(\" | \", row.Select(FmtEntry))}]\");\n    }\n\n    return new HttpResponse {\n      StatusCode = HttpStatusCode.OK,\n        BodyAsString = responseText.ToString(),\n    };\n  }\n  private static string FmtCol(PgColumn c) {\n    return $ \"{c.Name} ({c.DataType})\";\n  }\n}","url":"/cloud/data-postgres#postgresql#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#csharp"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Wizer","content":"Wizer is required to successfully build this application. Please go ahead and install Wizer using the following command:$ cargo install wizer --all-features","url":"/cloud/data-postgres#postgresql#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#csharp#wizer"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Spin Build","content":"To build the application, use the following command:$ spin build","url":"/cloud/data-postgres#postgresql#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#csharp#wizer#spin-build"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Spin Deploy","content":"To deploy the application, use the deploy command:$ spin deployThe above deploy command will produce similar output to the following:Deployed httpCSharpApplication version 1.0.0+XXXXXXXX\nAvailable Routes:\n  http_c_sharp_application: https://httpcsharpapplication-XXXXXXXX.fermyon.app/dataVisiting the above URL will show your data in the browser's body","url":"/cloud/data-postgres#postgresql#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#csharp#wizer#spin-build#spin-deploy"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"","content":"","url":"/cloud/data-redis"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Redis","content":"undefined, is an open-source data store used by millions of developers as a database, cache, streaming engine, and message broker. This tutorial will implement a persistent storage solution for Fermyon Cloud, using Redis. In this tutorial, we will be using undefined' free Redis service.","url":"/cloud/data-redis#redis"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Spin and Fermyon Cloud","content":"First, you need to have Spin installed on your computer. Please use the official Fermyon Cloud Quickstart to both undefined Spin and also undefined to Fermyon Cloud.","url":"/cloud/data-redis#redis#spin-and-fermyon-cloud"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Using Spin Application Templates","content":"The Spin CLI facilitates the creation of new Spin applications through the use of application templates. You can install Spin application templates using the undefined. For example:$ spin templates install --git https://github.com/fermyon/spinThe output from the command above will be similar to the following:Copying remote template source\n// --snip--\nInstalling template http-rust...\n// --snip--\n\nInstalled 8 template(s)\n\n+-----------------------------------------------------------------+\n| Name         Description                                        |\n+=================================================================+\n| // --snip--                                                     |\n| http-rust     HTTP request handler using Rust                   |\n+-----------------------------------------------------------------+The template we are interested in is http-rust.","url":"/cloud/data-redis#redis#spin-and-fermyon-cloud#using-spin-application-templates"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Creating Our New Spin Application","content":"The official Spin CLI documentation also has instructions on how to undefined. Let's go ahead and create a new http-rust application:$ spin new http-rust redisRustApplicationThe above command will ask you to enter a Project description, HTTP base (default set to / which is fine) and HTTP path:Project description: \nHTTP base: /\nHTTP path: /...You can fill out these values, when prompted, for example:Project description: A new redis-rust Spin Application.\nHTTP base: /\nHTTP path: /dataundefined","url":"/cloud/data-redis#redis#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Redis","content":"To create your free database go to undefined. For this tutorial, we are signing up using GitHub authentication.undefinedOnce you have logged in to Redislabs click on the Data Access Control and Databases menus (in the left sidebar) to create roles/users and a new Redis database. Be sure to acknowledge the usernames, passwords and database URLs (provided during setup) as we will be using these to configure our Spin application. Please see the  undefined for additional information.","url":"/cloud/data-redis#redis#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#redis"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Configuration","content":"Open the Spin application's spin.toml file and add an environment configuration value, within the [[component]] section. For example:environment = { REDIS_ADDRESS = \"redis://username:password@redis.cloud.redislabs.com:16675\" }undefined","url":"/cloud/data-redis#redis#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#redis#configuration"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Spin SDK's Redis Implementation","content":"In this tutorial we will create the code to store and retrieve data from a Redislabs database.","url":"/cloud/data-redis#redis#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#redis#configuration#spin-sdks-redis-implementation"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Rust","content":"The following is the content which is required in the src/lib.rs file. Feel free to cut and paste the following, for convenience:use anyhow::{anyhow, Result};\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component, redis,\n};\n\nconst REDIS_ADDRESS_ENV: &str = \"REDIS_ADDRESS\";\n\n#[http_component]\nfn publish(_req: Request) -> Result<Response> {\n    let address = std::env::var(REDIS_ADDRESS_ENV)?;\n\n    // Set the Redis key \"spin-example\" to value \"Eureka Cloud!\"\n    redis::set(&address, \"spin-example\", &b\"Eureka Cloud!\"[..])\n        .map_err(|_| anyhow!(\"Error executing Redis set command\"))?;\n\n    // Get the value from the Redis key \"spin-example\"\n    let payload =\n        redis::get(&address, \"spin-example\").map_err(|_| anyhow!(\"Error querying Redis\"))?;\n\n    // Return the permanently stored value to the user's browser body\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(payload.into()))?)\n}","url":"/cloud/data-redis#redis#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#redis#configuration#spin-sdks-redis-implementation#rust"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Log into Fermyon Cloud","content":"We need to log into Fermyon Cloud, so that we can build/deploy our application. For example:$ spin login","url":"/cloud/data-redis#redis#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#redis#configuration#spin-sdks-redis-implementation#rust#log-into-fermyon-cloud"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Spin Build","content":"We build this application by typing the following command:$ spin buildThe output from the above command will look similar to the following:Executing the build command for component redis-rust-application: cargo build --target wasm32-wasi --release\n    Finished release [optimized] target(s) in 0.09s\nSuccessfully ran the build command for the Spin components.","url":"/cloud/data-redis#redis#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#redis#configuration#spin-sdks-redis-implementation#rust#log-into-fermyon-cloud#spin-build"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Spin Deploy","content":"To deploy the application, use the deploy command:$ spin deployThe above deploy command will produce similar output to the following:Deployed redisRustApplication version 0.1.0+XXXXXXXX\nApplication is running at redisRustApplication-XXXXXXXX.fermyon.appVisiting the URL, which is provided by the spin deploy command's output will show the Eureka Cloud! value for the spin-example key which is stored in Redis.","url":"/cloud/data-redis#redis#spin-and-fermyon-cloud#using-spin-application-templates#creating-our-new-spin-application#redis#configuration#spin-sdks-redis-implementation#rust#log-into-fermyon-cloud#spin-build#spin-deploy"},{"project":"cloud","title":"Deleting an application","subheading":"","content":"undefinedundefinedundefinedIt’s super easy to delete your application with Fermyon Cloud. This can be done in just a few steps using the Fermyon Cloud website.","url":"/cloud/delete"},{"project":"cloud","title":"Deleting an application","subheading":"Sign in to the Fermyon Cloud website","content":"undefinedundefinedundefined","url":"/cloud/delete#sign-in-to-the-fermyon-cloud-website"},{"project":"cloud","title":"Deleting an application","subheading":"Delete your application","content":"undefinedundefinedundefinedundefinedundefinedundefinedThat’s all about deleting your Spin Application on the Fermyon Cloud!","url":"/cloud/delete#sign-in-to-the-fermyon-cloud-website#delete-your-application"},{"project":"cloud","title":"Deleting an application","subheading":"Next steps","content":"undefinedundefined","url":"/cloud/delete#sign-in-to-the-fermyon-cloud-website#delete-your-application#next-steps"},{"project":"cloud","title":"Deploy an application","subheading":"","content":"undefinedundefinedundefinedundefinedThis article will guide you through deploying a Spin Application with the Fermyon Cloud. You can deploy your undefined or undefined site in just a few steps.","url":"/cloud/deploy"},{"project":"cloud","title":"Deploy an application","subheading":"Prerequisites - Install the Spin CLI","content":"Before developing a Spin application, you need to have the Spin CLI installed locally. Here’s a way to install the Spin CLI:curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash{{ details \"Additional info\" \"It's easier if you move the spin binary somewhere in your path, so it can be accessed from any directory. E.g., sudo mv ./spin /usr/local/bin/spin. \\n\\nYou can verify the version of Spin installed by running spin --version\" }}","url":"/cloud/deploy#prerequisites-install-the-spin-cli"},{"project":"cloud","title":"Deploy an application","subheading":"Log in to the Fermyon Cloud","content":"Next, you can log in to the Fermyon Cloud, which requires your GitHub account to sign in.$ spin login\n\nCopy your one-time code:\n\nXXXXXXXX\n\n...and open the authorization page in your browser:\n\nhttps://cloud.fermyon.com/device-authorization\n\nWaiting for device authorization...\nDevice authorized!This command generates an authentication code for your device to be authorized on the Fermyon Cloud.","url":"/cloud/deploy#prerequisites-install-the-spin-cli#log-in-to-the-fermyon-cloud"},{"project":"cloud","title":"Deploy an application","subheading":"Deploy your application","content":"After having signed in to the Fermyon Cloud, you deploy the application, by running the following command in the directory where your applications spin.toml file is located.$ spin deploy\nUploading cloud_start version 0.1.0+XXXXXXXX...\nDeploying...\nWaiting for application to become ready... ready\nAvailable Routes:\n  cloud-start: https://cloud-start-XXXXXXXX.fermyon.app (wildcard)Take a look at the undefined for how to get a pre-built application to deploy.{{ details \"Additional info\" \"spin deploy can point to a spin.toml file by using the --file option.\" }}undefined","url":"/cloud/deploy#prerequisites-install-the-spin-cli#log-in-to-the-fermyon-cloud#deploy-your-application"},{"project":"cloud","title":"Deploy an application","subheading":"Next steps","content":"undefined","url":"/cloud/deploy#prerequisites-install-the-spin-cli#log-in-to-the-fermyon-cloud#deploy-your-application#next-steps"},{"project":"cloud","title":"Deployment Concepts","subheading":"","content":"undefinedundefinedundefined","url":"/cloud/deployment-concepts"},{"project":"cloud","title":"Deployment Concepts","subheading":"Deployments in Fermyon Cloud","content":"Deploying applications to a cloud service should be simple. Even though there is complexity involved in operating a cloud with many servers, many applications, and an ever-changing number of workloads, the user's responsibility when deploying their applications should be minimal.In this article, we describe the core technologies and concepts, which are part of the deployment process in the Fermyon Cloud.","url":"/cloud/deployment-concepts#deployments-in-fermyon-cloud"},{"project":"cloud","title":"Deployment Concepts","subheading":"Bindle - An Aggregate Object Storage System","content":"The Fermyon Cloud uses undefined to package and distribute Spin applications. Bindle is an open-source project, built and maintained by Deis Labs. Bindle is very well documented, so we will not go into details of how Bindle works, other than calling out a few core features of the system here:undefinedundefinedundefined","url":"/cloud/deployment-concepts#deployments-in-fermyon-cloud#bindle-an-aggregate-object-storage-system"},{"project":"cloud","title":"Deployment Concepts","subheading":"The Deployment Process Explained","content":"In the Fermyon Cloud, we host an instance of Bindle, so when you run spin deploy, the command will take care of:undefinedundefinedThere is no direct interaction with Bindle when using the Fermyon Cloud.Let's unfold each of these steps.","url":"/cloud/deployment-concepts#deployments-in-fermyon-cloud#bindle-an-aggregate-object-storage-system#the-deployment-process-explained"},{"project":"cloud","title":"Deployment Concepts","subheading":"1. Packaging and Uploading an Application","content":"The first step in deploying an application is to package all the files into parcels and generate an invoice.  All of this is handled in a staging directory, which is either a temporary directory using undefined or the staging directory defined using the --staging-dir option.The bindle will be named using the name from spin.toml, the version from spin.toml, and a build metadata string, which is automatically generated by Spin at deployment time.Bindles in the Fermyon Cloud always use Semantic Versioning and require major, minor, and patch version numbers to be specified. Therefore, the version in spin.toml has to conform to the MAJOR.MINOR.PATCH format, i.e. 1.0.1 is valid, 1.0 and 1 are not valid version numbers for a Spin application. The result is that the version of a Spin application will be like this my_app_name/1.0.0+r80e5abb.Following packaging, the bindle will be uploaded to the Fermyon Cloud. As soon as a bindle has been uploaded, it cannot be modified or deleted. This is to preserve the integrity of the immutability of bindles.","url":"/cloud/deployment-concepts#deployments-in-fermyon-cloud#bindle-an-aggregate-object-storage-system#the-deployment-process-explained#1-packaging-and-uploading-an-application"},{"project":"cloud","title":"Deployment Concepts","subheading":"2. Create or Upgrade an Application","content":"The next step in the deployment process is to create or upgrade the application.An application in the Fermyon Cloud can have multiple revisions, which are tied to channels. These concepts are derived from undefined an open-source Platform as a Service (PaaS) for WebAssembly. As you deploy your application both an application, a channel and a revision will be created in the Fermyon Cloud.If the application already exists, an upgrade will take place. What happens at this point is that a new revision will be created, and as soon as this is deemed healthy, traffic will start to route to the new revision. The failover from the old to the new revision takes a short amount of time, during which you will be able to observe replies from both revisions. The application existence is determined based on the combination of the user account and the Spin application name, as defined in spin.toml.The deployment process checks for the application health endpoint and finishes once the application is concluded to be healthy by the cloud. The application health point is an integral part of the Fermyon Cloud but does reserve the HTTP route /.well-known/spin/health, which will not be routed to your Spin application.","url":"/cloud/deployment-concepts#deployments-in-fermyon-cloud#bindle-an-aggregate-object-storage-system#the-deployment-process-explained#1-packaging-and-uploading-an-application#2-create-or-upgrade-an-application"},{"project":"cloud","title":"Develop a Spin application","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedThis article briefly describes how to create a new Spin application. For a more thorough guide to developing Spin applications, take a look undefined.","url":"/cloud/develop"},{"project":"cloud","title":"Develop a Spin application","subheading":"Prerequisites - Install the Spin CLI","content":"Before developing a Spin application, you need to have the Spin CLI installed locally. Here’s a way to install the Spin CLI:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash{{ details \"Additional info\" \"It's easier if you move the spin binary somewhere in your path, so it can be accessed from any directory. E.g., sudo mv ./spin /usr/local/bin/spin. \\n\\nYou can verify the version of Spin installed by running spin --version\" }}","url":"/cloud/develop#prerequisites-install-the-spin-cli"},{"project":"cloud","title":"Develop a Spin application","subheading":"Create a new Spin application from a template","content":"You can create your very own application based on undefined. Start by installing a set of Spin application templates undefined:$ spin templates install --git https://github.com/fermyon/spin\nCopying remote template source\nInstalling template http-rust...\nInstalling template http-go...\n...\n+--------------------------------------------------+\n| Name         Description                         |\n+==================================================+\n| http-rust    HTTP request handler using Rust     |\n| http-go      HTTP request handler using (Tiny)Go |\n| ...                                              |\n+--------------------------------------------------+{{ details \"Additional info\" \"If you already have templates installed, you can update them by running spin templates install --git https://github.com/fermyon/spin --update \\n\\nIf you’re interested in building your own template, you can follow the guide here undefined and the undefined.\" }}We will be using the http-rust template to build our Spin Application, by running spin new.$ spin new\nPick a template to start your project with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-csharp (HTTP request handler using C# (EXPERIMENTAL))\n  http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n> http-rust (HTTP request handler using Rust)\n  http-swift (HTTP request handler using SwiftWasm)\n  http-zig (HTTP request handler using Zig)\n  redis-go (Redis message handler using (Tiny)Go)\n  redis-rust (Redis message handler using Rust)\n\nEnter a name for your new project: hello_rust\nProject description: My first Rust Spin application\nHTTP base: /\nHTTP path: /...The command created all the files we need to build and run our Spin Application. Here’s the spin.toml file — the manifest file for a Spin application:spin_version = \"1\"\nauthors = [\"Doc Docsen <docs@fermyon.com>\"]\ndescription = \"My first Rust Spin application\"\nname = \"hello_rust\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"hello-rust\"\nsource = \"target/wasm32-wasi/release/hello_rust.wasm\"\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"Next, let’s build the app.$ spin build\nExecuting the build command for component hello-rust: cargo build --target wasm32-wasi --release\n    Updating crates.io index\n    Updating git repository `https://github.com/fermyon/spin`\n    Updating git repository `https://github.com/bytecodealliance/wit-bindgen`\n    ...\n   Compiling hello-rust v0.1.0 (/Users/doc/hello_rust)\n    Finished release [optimized] target(s) in 10.15s\nSuccessfully ran the build command for the Spin components.","url":"/cloud/develop#prerequisites-install-the-spin-cli#create-a-new-spin-application-from-a-template"},{"project":"cloud","title":"Develop a Spin application","subheading":"Run the application","content":"Now it’s time to spin up the application.$ spin up\nServing http://127.0.0.1:3000\nAvailable Routes:\n  hello-rust: http://127.0.0.1:3000 (wildcard){{ details \"Additional info\" \"To get information printed to the console, use the --follow-all flag when running spin up. /n/nYou can also set the RUST_LOG environment variable for detailed logs, before running spin up, e.g., RUST_LOG=spin=debug spin up.\" }}Spin will instantiate all components from the application manifest, and will create the router configuration for the HTTP trigger accordingly. The component can now be invoked by making requests to http://localhost:3000:$ curl -i localhost:3000\nHTTP/1.1 200 OK\nfoo: bar\ncontent-length: 15\n\nHello, Fermyon","url":"/cloud/develop#prerequisites-install-the-spin-cli#create-a-new-spin-application-from-a-template#run-the-application"},{"project":"cloud","title":"Develop a Spin application","subheading":"Write your code","content":"For this template, we have a single crate built from src/lib.rs, which contains the following code:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n/// A simple Spin HTTP component.\n#[http_component]\nfn hello_rust(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req.headers());\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Fermyon\".into()))?)\n}Let's change the body text returned to be a parameter from the URL, by changing the hello_rust function to the code below:/// A simple Spin HTTP component, returning the value of the first URL parameter as a greeting.\n/// Try `curl \"http://localhost:3000?Doc\"`\n#[http_component]\nfn hello_rust(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req.headers());\n    \n    let query_string = req.uri().query();\n\n    let reply_body = match query_string {\n        Some(s) => format!(\"Hello {s}!\"),\n        None => \"Who's there?\".to_string(),\n    };\n    \n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(reply_body.into()))?)\n}This Spin application will now take the query string of the URL http://localhost:3000?Doc and return the text Hello Doc! as a greeting.","url":"/cloud/develop#prerequisites-install-the-spin-cli#create-a-new-spin-application-from-a-template#run-the-application#write-your-code"},{"project":"cloud","title":"Develop a Spin application","subheading":"Next steps","content":"undefinedundefinedundefined","url":"/cloud/develop#prerequisites-install-the-spin-cli#create-a-new-spin-application-from-a-template#run-the-application#write-your-code#next-steps"},{"project":"cloud","title":"FAQ and Known Limitations","subheading":"","content":"This document contains:undefinedundefinedundefinedundefined","url":"/cloud/faq"},{"project":"cloud","title":"FAQ and Known Limitations","subheading":"Service Limits","content":"The following are the limits of the Fermyon Cloudundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","url":"/cloud/faq#service-limits"},{"project":"cloud","title":"FAQ and Known Limitations","subheading":"Known Limitations","content":"The following are known limitations of the Fermyon Cloudundefinedundefinedundefinedundefined","url":"/cloud/faq#service-limits#known-limitations"},{"project":"cloud","title":"FAQ and Known Limitations","subheading":"Frequently Asked Questions","content":"undefined11:08:13 : Hello from Rust\n11:08:18 : Hello from Rust - updated\n11:08:19 : Hello from Rust\n11:08:23 : Hello from Rust - updated\n11:08:24 : Bad Gateway\n11:08:26 : Hello from Rust - updated\n11:08:27 : Bad Gateway\n11:08:29 : Hello from Rust - updatedundefined","url":"/cloud/faq#service-limits#known-limitations#frequently-asked-questions"},{"project":"cloud","title":"FAQ and Known Limitations","subheading":"Next Steps","content":"undefined","url":"/cloud/faq#service-limits#known-limitations#frequently-asked-questions#next-steps"},{"project":"cloud","title":"Fermyon Cloud","subheading":"","content":"undefinedundefined","url":"/cloud/fermyon-cloud"},{"project":"cloud","title":"Fermyon Cloud","subheading":"The Fermyon Cloud Explained","content":"undefined is a cloud application platform for WebAssembly microservices. It enables you to run undefined, at scale, in the cloud, without any infrastructure setup.In this article we describe the core technologies and concepts which are part of the Fermyon Cloud.","url":"/cloud/fermyon-cloud#the-fermyon-cloud-explained"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Core Components of the Fermyon Cloud","content":"The Fermyon Cloud is an expansion of the undefined, built to provide scalable and resilient hosting for Spin applications.The following core components are needed in a cloud platform:undefinedundefinedundefinedundefinedundefinedAll of the above are key to ensuring the high dynamism of a cloud platform where applications and traffic come and go in unpredictable patterns.","url":"/cloud/fermyon-cloud#the-fermyon-cloud-explained#core-components-of-the-fermyon-cloud"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Orchestration","content":"The core orchestration in the Fermyon Cloud is done using undefined. Nomad enables the Fermyon Cloud to spread workloads across servers, and run an optimized highly resilient cloud. Nomad guarantees quick placement of Spin applications, at deployment, upgrade and failures in the underlying infrastructure - which do happen, so we planned for it.","url":"/cloud/fermyon-cloud#the-fermyon-cloud-explained#core-components-of-the-fermyon-cloud#orchestration"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Service Resolution","content":"In order to successfully route traffic to your Spin applications, a service registry is needed to map application endpoints to sockets on servers. This is done using Consul, as an integrated part of Nomad. Consul helps ensure we can always find your application, as the orchestration engine may or may not move it around.","url":"/cloud/fermyon-cloud#the-fermyon-cloud-explained#core-components-of-the-fermyon-cloud#orchestration#service-resolution"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Traffic routing","content":"Traffic routing is done using undefined, which ensures that data is sent to the right places in the cloud.","url":"/cloud/fermyon-cloud#the-fermyon-cloud-explained#core-components-of-the-fermyon-cloud#orchestration#service-resolution#traffic-routing"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Application Packaging and Distribution","content":"To package and distribute application to and within the cloud, we rely on Bindle. For more information about deployment concepts in the Fermyon Cloud, see undefined.","url":"/cloud/fermyon-cloud#the-fermyon-cloud-explained#core-components-of-the-fermyon-cloud#orchestration#service-resolution#traffic-routing#application-packaging-and-distribution"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Web UI, API and CLI","content":"The Fermyon Cloud exposes a public undefined which is used by the undefined and the Spin CLI when logging in and deploying applications.","url":"/cloud/fermyon-cloud#the-fermyon-cloud-explained#core-components-of-the-fermyon-cloud#orchestration#service-resolution#traffic-routing#application-packaging-and-distribution#web-ui-api-and-cli"},{"project":"cloud","title":"Fermyon Cloud","subheading":"","content":"undefinedundefinedundefinedundefinedundefined is a cloud application platform for WebAssembly microservices. It enables you to run undefined, at scale, in the cloud, without any infrastructure setup.","url":"/cloud/index"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Documentation","content":"This site contains the documentation for the Fermyon Cloud. Here you will:undefinedundefinedundefinedundefinedundefinedundefined","url":"/cloud/index#documentation"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Getting support","content":"If you have any questions (and cannot find answers) on this site, please go to our undefined for assistance.","url":"/cloud/index#documentation#getting-support"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Open beta","content":"The Fermyon Cloud is currently an open beta service. This means that Fermyon Technologies does not provide any service-level agreements on the service, including the workloads you choose to deploy. We also reserve the right to break compatibility with:undefinedundefined","url":"/cloud/index#documentation#getting-support#open-beta"},{"project":"cloud","title":"Let's get started","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedThis guide will get you up and running in the Fermyon Cloud in less than two minutes. To do so, we've already made a Spin application ready for you to deploy to the cloud.","url":"/cloud/quickstart"},{"project":"cloud","title":"Let's get started","subheading":"Install Spin","content":"First, you need to have Spin installed on your computer. Use the command below to install the latest version of Spin.curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashThis command downloads and unpacks the latest Spin binary in the current directory. You can now run spin using the command ./spin.{{ details \"Learn more\" \"undefined is an open-source project used for creating, developing, building, running, and deploying Spin applications. It is both a CLI tool and a runtime, and provides SDKs for a variety of programming languages, including, but not limited to, Rust, TinyGo, and C#. \\n\\n The Spin project provides installers that are supported on Linux (amd64), macOS (amd64 and arm64), and Windows(amd64). \\n\\n The undefined documentation is a good starting place to learn more about using the framework to develop applications.\"}}","url":"/cloud/quickstart#install-spin"},{"project":"cloud","title":"Let's get started","subheading":"Log in to the Fermyon cloud","content":"Now, let's log in to the Fermyon Cloud. You will be using your undefined to sign in.$ ./spin login\n\nCopy your one-time code:\n\nXXXXXXXX\n\n...and open the authorization page in your browser:\n\nhttps://cloud.fermyon.com/device-authorization\n\nWaiting for device authorization...\nDevice authorized!This command will generate an authentication code for your current device to be authorized against the Fermyon Cloud. Follow the instructions in the prompt to complete the authorization process.{{ details \"Learn more\" \"The default behavior of spin login is to authenticate with the Fermyon Cloud. The command can authenticate against any instance of the undefined.\" }}","url":"/cloud/quickstart#install-spin#log-in-to-the-fermyon-cloud"},{"project":"cloud","title":"Let's get started","subheading":"Clone the quickstart repo","content":"To make this easy, we've already compiled a Webassembly module and created a Spin application for you to deploy.Let's go ahead and clone the undefined repository to your computer to retrieve that application.git clone https://github.com/fermyon/cloud-start && cd cloud-startThis command clones the repository into a local directory named cloud-start, and then enters that directory.{{ details \"Learn more\" \"To write your Spin application, you would start by using the command spin new [template name] [project name]. This gives you the option to select a template based on your preference of programming language and trigger for your module - e.g., spin new rust-http my_rust_http_trigger. \\n\\n The undefined guides you through creating a Spin application from scratch.\" }}","url":"/cloud/quickstart#install-spin#log-in-to-the-fermyon-cloud#clone-the-quickstart-repo"},{"project":"cloud","title":"Let's get started","subheading":"Deploy the application","content":"Let's deploy the application../spin deployThe ../spin command will run using the Spin binary in the parent directory of the current path and read the Spin application definition file spin.toml in the current directory to know what application to deploy.{{ details \"Learn more\" \"Deploying a Spin application to the Fermyon Cloud includes packaging the application and all the required files, uploading it to a Bindle registry, as well as instantiating the application on the cloud. \\n\\n You can learn more about the deployment process undefined.\" }}","url":"/cloud/quickstart#install-spin#log-in-to-the-fermyon-cloud#clone-the-quickstart-repo#deploy-the-application"},{"project":"cloud","title":"Let's get started","subheading":"Success","content":"This is what a successful Spin application deployment on Fermyon Cloud looks like:Uploading cloud_start version 0.1.0+XXXXXXXX...\nDeploying...\nWaiting for application to become ready... ready\nAvailable Routes:\n  cloud-start: https://cloud-start-XXXXXXXX.fermyon.app (wildcard)You can CTRL+Click on the link in the terminal to visit the web application you just deployed.Congratulations, you've now deployed your first Spin application to the undefined","url":"/cloud/quickstart#install-spin#log-in-to-the-fermyon-cloud#clone-the-quickstart-repo#deploy-the-application#success"},{"project":"cloud","title":"Let's get started","subheading":"Next Steps","content":"undefinedundefinedundefinedundefinedundefined","url":"/cloud/quickstart#install-spin#log-in-to-the-fermyon-cloud#clone-the-quickstart-repo#deploy-the-application#success#next-steps"},{"project":"cloud","title":"Rest API","subheading":"","content":"","url":"/cloud/rest-api"},{"project":"cloud","title":"Rest API","subheading":"OpenAPI","content":"The undefined project contains automatically generated client libraries for use with the Fermyon Cloud.","url":"/cloud/rest-api#openapi"},{"project":"cloud","title":"Rest API","subheading":"Rust Client","content":"To use undefined, go ahead and add a reference to the Fermyon Cloud OpenAPI in your project’s Cargo.toml file, as shown below:cloud-openapi = { git = \"https://github.com/fermyon/cloud-openapi\" }","url":"/cloud/rest-api#openapi#rust-client"},{"project":"cloud","title":"Rest API","subheading":"Documenting the Fermyon Cloud API","content":"The documentation for each client library is automatically generated and is available in the undefined.","url":"/cloud/rest-api#openapi#rust-client#documenting-the-fermyon-cloud-api"},{"project":"cloud","title":"Rest API","subheading":"Related Resources","content":"undefinedundefined","url":"/cloud/rest-api#openapi#rust-client#documenting-the-fermyon-cloud-api#related-resources"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"","content":"","url":"/cloud/spin-vs-code-extension"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"Visual Studio Code","content":"undefined is a source-code editor that can be used with a variety of programming languages. It was recently ranked the most popular developer environment tool (by 82, 000 respondents in the undefined).","url":"/cloud/spin-vs-code-extension#visual-studio-code"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"The Spin Extension","content":"VS Code extensions allow you to add tools to your installation, to support your development workflow. Fermyon's undefined integrates Spin developer tasks into the VS Code editor.","url":"/cloud/spin-vs-code-extension#visual-studio-code#the-spin-extension"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"Installation","content":"The Spin Extension for VS Code can be found in the undefined and can also be installed by searching for Fermyon Spin within the Extensions section of your VS Code editor. The extension downloads and uses a compatible version of Spin by default.","url":"/cloud/spin-vs-code-extension#visual-studio-code#the-spin-extension#installation"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"Supported Spin Commands","content":"At present, the Spin VS Code Extension supports the undefined, undefined and undefined commands. Simply open your VS Code terminal (from the main VS Code menu bar) to perform these commands.","url":"/cloud/spin-vs-code-extension#visual-studio-code#the-spin-extension#installation#supported-spin-commands"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"Fermyon Cloud and VS Code","content":"undefined shows you how to create, build, deploy, update and re-deploy a new Spin application, all from within VS Code. The video is based on using Fermyon Cloud","url":"/cloud/spin-vs-code-extension#visual-studio-code#the-spin-extension#installation#supported-spin-commands#fermyon-cloud-and-vs-code"},{"project":"cloud","title":"Support","subheading":"","content":"This article contains the following information:undefinedundefinedundefined","keywords":"abuse security concern","url":"/cloud/support"},{"project":"cloud","title":"Support","subheading":"Engage on Discord","content":"As the Fermyon Cloud is currently in Beta, support is being provided best effort through undefined. This link will take you to the undefined channel, which is a good place to start.For support related to undefined, undefined, and other projects, please use the appropriate channels on Discord as well.","keywords":"abuse security concern","url":"/cloud/support#engage-on-discord"},{"project":"cloud","title":"Support","subheading":"Report issues on GitHub","content":"To see any know issues and report a specific issue, feel free to use the undefined","keywords":"abuse security concern","url":"/cloud/support#engage-on-discord#report-issues-on-github"},{"project":"cloud","title":"Support","subheading":"Report Abuse","content":"To report suspected abuse of the Fermyon Cloud service, please e-mail abuse@fermyon.com.","keywords":"abuse security concern","url":"/cloud/support#engage-on-discord#report-issues-on-github#report-abuse"},{"project":"cloud","title":"Upgrade an Application","subheading":"","content":"undefinedundefinedTo upgrade your Spin application, there are just a few steps to take. This doesn’t require so much stress.","url":"/cloud/upgrade"},{"project":"cloud","title":"Upgrade an Application","subheading":"Upgrade your application","content":"To upgrade a Spin application running in the Fermyon Cloud, you first have to change the version of your application.undefinedversion = \"0.1.0\"In this case, we're changing the version from 0.1.0 to 0.1.1version = \"0.1.1\"{{ details \"Additional info\" \"Spin application are packaged using undefined. Bindle ensures immutability, meaning you cannot overwrite a Bindle (name+version), once it has been uploaded to a Bindle server. /n/n spin deploy will fail if you try to redeploy a version of an application, which already exists in the Fermyon Cloud.\" }}You can now deploy the upgraded version of your application by running this command:$ spin deployThat’s how to upgrade a Spin Application, just as simple as that!","url":"/cloud/upgrade#upgrade-your-application"},{"project":"cloud","title":"Upgrade an Application","subheading":"Next steps","content":"undefinedundefined","url":"/cloud/upgrade#upgrade-your-application#next-steps"},{"project":"robots.md","title":"Untitled","subheading":"","content":"This is the robots.txt file. It is autogenerated","url":"/robots"},{"project":"sitemap.md","title":"Sitemap XML file","subheading":"","content":"This is the autogenerated sitemap. Note that the suffix .xml is replaced with .md by Bartholomew","url":"/sitemap"},{"project":"spin","title":"Spin architecture and internals","subheading":"","content":"This document aims to offer an overview to the implementation of Spin, as well\nas explain how the code is structured and how all parts fit together. This\ndocument is continuously evolving, and if you want even more detailed\ninformation, make sure to review the code for a given part of Spin.","url":"/spin/architecture"},{"project":"spin","title":"Spin architecture and internals","subheading":"How Spin runs an application","content":"A Spin application is defined as a spin.toml file. It can either be run\ndirectly by spin up, passing the manifest file (--file spin.toml), or it can\nbe pushed to the registry then referenced using its remote ID\n(spin bindle push followed by spin up --bindle <id>).Regardless of the application origin (local file or remote reference from the\nregistry), a Spin application is defined by\nspin_manifest::Application (contained in the\nundefined crate),\nwhich is the canonical representation of a Spin application.The crate responsible for transforming a custom configuration into a canonical\nSpin application is undefined,\nwhich implements loading applications from local spin.toml files and from\nremote Bindle references (and ensures files referenced in the application\nconfiguration are copied and mounted at the location expected in the WebAssembly\nmodule). Once the canonical representation is loaded from an application source,\nit is passed to a trigger.The HTTP trigger (defined in the spin-http crate) takes an\napplication configuration (undefined\nexplores a trigger handling multiple applications), starts an HTTP listener, and\nfor each new request, it routes it to the component configured in the\napplication configuration. Then, it instantiates the WebAssembly module (using a\nspin_engine::ExecutionContext) and uses the appropriate executor (either the\nSpinHttpExecutor or the WagiHttpExecutor, based on the component\nconfiguration) to handle the request and return the response.","url":"/spin/architecture#how-spin-runs-an-application"},{"project":"spin","title":"Spin architecture and internals","subheading":"The Spin execution context","content":"The Spin execution context (or \"Spin engine\") is the part of Spin that executes\nWebAssembly components using the\nundefined WebAssembly runtime. It\nis implemented in the spin-engine crate, and serves as\nthe part of Spin that takes a fully formed application configuration and creates\nWasm instances based on the component configurations.There are two important concepts in this crate:undefinedundefined","url":"/spin/architecture#how-spin-runs-an-application#the-spin-execution-context"},{"project":"spin","title":"Configuration for Spin applications","subheading":"","content":"Spin applications are comprised of general information (metadata), and a collection\nof at least one undefined. Configuration for a Spin application lives in a TOML\nfile called spin.toml (the undefined). In the example below we can see\na simple HTTP application with a single component executed when the /hello endpoint\nis accessed:spin_version = \"1\"\nname = \"spin-hello-world\"\ndescription = \"A simple application that returns hello world.\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"hello\"\ndescription = \"A simple component that returns hello world.\"\nsource = \"target/wasm32-wasi/release/spinhelloworld.wasm\"\n[component.trigger]\nroute = \"/hello\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"","url":"/spin/configuration"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Application manifest reference","content":"","url":"/spin/configuration#application-manifest-reference"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Application configuration","content":"The following are the fields supported by the spin.toml manifest file:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","url":"/spin/configuration#application-manifest-reference#application-configuration"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Component configuration","content":"Each component object has the following fields:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","url":"/spin/configuration#application-manifest-reference#application-configuration#component-configuration"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Custom Configuration","content":"Spin applications may define custom configuration which can be looked up by\ncomponent code via the undefined.","url":"/spin/configuration#application-manifest-reference#application-configuration#component-configuration#custom-configuration"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Custom Config Variables","content":"Application-global custom config variables are defined in the top-level [variables]\nsection. These entries aren't accessed directly by components, but are referenced\nby undefined value templates. Each entry must\neither have a default value or be marked as required = true. \"Required\" entries\nmust be undefined with a value.Configuration keys may only contain lowercase letters and underscores between letters.[variables]\napi_host = { default = \"api.example.com\" }\napi_key = { required = true }","url":"/spin/configuration#application-manifest-reference#application-configuration#component-configuration#custom-configuration#custom-config-variables"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Component Custom Config","content":"The configuration entries available to a component are listed in its\n[component.config] section. Configuration values may reference\nundefined with simple\nundefined-inspired string templates.[[component]]\n# ...\n[component.config]\napi_base_url = \"https://{{ api_host }}/v1\"\napi_key = \"{{ api_key }}\"","url":"/spin/configuration#application-manifest-reference#application-configuration#component-configuration#custom-configuration#custom-config-variables#component-custom-config"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Custom Config Providers","content":"undefined values may be set at runtime by\nconfig \"providers\". Currently, there are two providers: the environment\nvariable provider and vault config provider.","url":"/spin/configuration#application-manifest-reference#application-configuration#component-configuration#custom-configuration#custom-config-variables#component-custom-config#custom-config-providers"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Environment Variable Provider","content":"The environment variable provider which gets config values from the spin process's\nenvironment (undefined the component environment). Config keys are translated\nto environment variables by upper-casing and prepending with SPIN_APP_:$ export SPIN_APP_API_KEY = \"1234\"  # Sets the `api_key` value.\n$ spin up","url":"/spin/configuration#application-manifest-reference#application-configuration#component-configuration#custom-configuration#custom-config-variables#component-custom-config#custom-config-providers#environment-variable-provider"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Vault Config Provider","content":"The Vault config provider gets secret values from undefined.\nCurrently, only undefined is supported.\nYou can set up v2 kv secret engine at any mount point and give Vault information in the undefined file:[[config_provider]]\ntype = \"vault\"\nurl = \"http://127.0.0.1:8200\"\ntoken = \"root\"\nmount = \"secret\"","url":"/spin/configuration#application-manifest-reference#application-configuration#component-configuration#custom-configuration#custom-config-variables#component-custom-config#custom-config-providers#environment-variable-provider#vault-config-provider"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Vault Config Provider Example","content":"undefinedundefined$ vault server -dev -dev-root-token-id rootundefined$ export VAULT_TOKEN=root\n$ export VAULT_ADDR=http://127.0.0.1:8200\n$ vault kv put secret/password value=\"test_password\"\n$ vault kv get secret/passwordundefinedundefined$ spin build\n$ spin up --runtime-config-file runtime_config.tomlundefined$ curl -i http://127.0.0.1:3000\nHTTP/1.1 200 OK\ncontent-length: 26\ndate: Tue, 18 Oct 2022 12:34:40 GMT\n\nGot password test_password","url":"/spin/configuration#application-manifest-reference#application-configuration#component-configuration#custom-configuration#custom-config-variables#component-custom-config#custom-config-providers#environment-variable-provider#vault-config-provider#vault-config-provider-example"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Runtime Configuration","content":"Runtime configuration contains config provider information like undefined.\nYou can use the runtime configuration by giving --runtime-config-file in spin up command.","url":"/spin/configuration#application-manifest-reference#application-configuration#component-configuration#custom-configuration#custom-config-variables#component-custom-config#custom-config-providers#environment-variable-provider#vault-config-provider#vault-config-provider-example#runtime-configuration"},{"project":"spin","title":"Configuration for Spin applications","subheading":"Examples","content":"undefined[[component]]\nsource = \"modules/spin_static_fs.wasm\"\nid = \"fileserver\"\nfiles = [ { source = \"static/\", destination = \"/\" } ]\n[component.trigger]\nroute = \"/static/...\"undefined[[component]]\nsource = { url = \"https://github.com/fermyon/spin-fileserver/releases/download/v0.0.1/spin_static_fs.wasm\", digest = \"sha256:650376c33a0756b1a52cad7ca670f1126391b79050df0321407da9c741d32375\" }\nid = \"fileserver\"\nfiles = [ { source = \"static/\", destination = \"/\" } ]\n[component.trigger]\nroute = \"/static/...\"undefined[[component]]\nsource = \"modules/env_wagi.wasm\"\nid = \"env\"\nfiles = [ \"content/**/*\" , \"templates/*\", \"scripts/*\", \"config/*\"]\n[component.trigger]\nroute = \"/...\"\nexecutor = { type = \"wagi\", argv = \"test ${SCRIPT_NAME} ${ARGS} done\", entrypoint = \"some-other-export-function\" }undefined[[component]]\nid = \"echo-message\"\nsource = \"spinredis.wasm\"\n[component.trigger]\nchannel = \"messages\"","url":"/spin/configuration#application-manifest-reference#application-configuration#component-configuration#custom-configuration#custom-config-variables#component-custom-config#custom-config-providers#environment-variable-provider#vault-config-provider#vault-config-provider-example#runtime-configuration#examples"},{"project":"spin","title":"Contributing to Spin","subheading":"","content":"We are delighted that you are interested in making Spin better! Thank you! This\ndocument will guide you through making your first contribution to the project.First, any contribution and interaction on any Fermyon project MUST follow our\nundefined. Thank you for being\npart of an inclusive and open community!\nWe welcome and appreciate contributions of all types — opening issues, fixing\ntypos, adding examples, one-liner code fixes, tests, or complete features.If you plan on contributing anything complex, please go through the issue and PR\nqueues first to make sure someone else has not started working on it. If it\ndoesn't exist already, please open an issue so you have a chance to get feedback\nfrom the community and the maintainers before you start working on your feature.","url":"/spin/contributing"},{"project":"spin","title":"Contributing to Spin","subheading":"Making code contributions to Spin","content":"The following guide is intended to make sure your contribution can get merged as\nsoon as possible. First, make sure you have the following prerequisites\nconfigured:undefinedundefinedundefinedundefinedundefinedundefinedOnce you have set up the prerequisites and identified the contribution you want\nto make to Spin, make sure you can correctly build the project:# clone the repository\n$ git clone https://github.com/fermyon/spin && cd spin\n# add a new remote pointing to your fork of the project\n$ git remote add fork https://github.com/<your-username>/spin\n# create a new branch for your work\n$ git checkout -b <your-branch>\n\n# if you are making a documentation contribution,\n# you can skip compiling and running the tests.\n\n# build a release version of the Spin CLI\n$ cargo build --release\n# make sure compilation is successful\n$ ./target/release/spin --help\n\n# run the tests and make sure they pass\n$ make testNow you should be ready to start making your contribution. To familiarize\nyourself with the Spin project, please read the\nundefined. Since most of Spin is implemented in\nRust, we try to follow the common Rust coding conventions (keep an eye on the\nrecommendations from Clippy!) If applicable, add unit or integration tests to\nensure your contribution is correct.Build the project and run the tests (make build test), and if everything is\nsuccessful, you should be ready to commit your changes. We try to follow the\nundefined\nguidelines for writing commit messages:$ git commit -S -s -m \"<your commit message that follows https://www.conventionalcommits.org/en/v1.0.0/>\"We try to only keep useful changes as separate commits — if you prefer to commit\noften, please\nundefined\nbefore opening a pull request. Once you are happy with your changes you can push\nthe branch to your fork:# \"fork\" is the name of the git remote pointing to your fork\n$ git push forkNow you are ready to create a pull request. Thank you for your contribution!","url":"/spin/contributing#making-code-contributions-to-spin"},{"project":"spin","title":"Deploying Spin applications to Fermyon","subheading":"","content":"undefined is the frictionless WebAssembly platform for deploying\nmicroservices and web apps. With Fermyon, you can deploy your spin applications onto a server in\nmoments.For instructions guiding you through running the Fermyon platform on your development workstation,\nfollow undefined.For instructions guiding you through running the Fermyon platform on AWS, follow\nundefined.","url":"/spin/deploying-to-fermyon"},{"project":"spin","title":"Developing Spin applications","subheading":"","content":"The Spin CLI offers a few commands to simplify developing applications.","url":"/spin/developing"},{"project":"spin","title":"Developing Spin applications","subheading":"Building Spin applications","content":"A Spin application is made up of one or more components. When developing a\nmulti-component application, it is very common to have multiple directories with\nsource code for components — and when making changes to components, having to\nmanually go into the each component directory, compile the component, then go\nback to the directory with spin.toml can be a very repetitive task.This is why Spin has a top-level command that will execute the build command\nset by each component, spin up:[component.build]\ncommand = \"cargo build --target wasm32-wasi --release --manifest-path http-rust/Cargo.toml\"Then, running spin build will execute, sequentially, each build command:$ RUST_LOG=spin=trace spin build\n2022-04-25T03:01:56.721630Z  INFO spin_build: Executing the build command for component rust-hello.\n    Finished release [optimized] target(s) in 0.05s\n2022-04-25T03:01:56.832360Z  INFO spin_build: Executing the build command for component rust-static-assets.\n    Finished release [optimized] target(s) in 0.02s\n2022-04-25T03:01:56.905424Z  INFO spin_build: Executing the build command for component rust-outbound-http.\n    Finished release [optimized] target(s) in 0.02sThe spin build command is intended to offer a built-in way to build more complex\nSpin applications without needing a separate build process.\nIt is not intended to replace complex build scripts — if\nyou have existing automated ways for building source code, those can be used\ninstead, or the build command can call that process.spin build --up can be used to start the application after the build process\nfinishes for all application components.","url":"/spin/developing#building-spin-applications"},{"project":"spin","title":"Developing Spin applications","subheading":"Component  workdir","content":"By default, the command to build a component is executed in the manifest's\ndirectory. This can be changed. For example, assume a component is located in\nsubdirectory deep:.\n├── deep\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlTo run the build command in directory deep, set the component's workdir:[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nworkdir = \"deep\"Note that workdir must be a relative path and it operates relative to the\nspin.toml. Specifying an absolute path leads to an error.","url":"/spin/developing#building-spin-applications#component-workdir"},{"project":"spin","title":"Packaging and distributing Spin applications","subheading":"","content":"Packaging and distributing Spin applications is done using undefined,\nan open source aggregate object storage system. This allows the packaging of the\napplication manifest, components, and static assets together, and\ntakes advantage of the features of a modern object storage system.To distribute applications, we first need a Bindle registry. You can\nundefined,\nor use the\nundefined\nVS Code extension (through the Bindle: Start command):$ bindle-server --address 127.0.0.1:8000 --directory . --unauthenticatedLet's push the application from the undefined to the registry:$ export BINDLE_URL=http://localhost:8000/v1\n$ spin bindle push --file spin.toml\npushed: spin-hello-world/1.0.0Now we can run the application using spin up directly from the registry:$ spin up --bindle spin-hello-world/1.0.0undefinedThe application can also be prepared in a local directory before pushing to the\nregistry by running spin bindle prepare.","url":"/spin/distributing-apps"},{"project":"spin","title":"Extending and embedding Spin","subheading":"","content":"undefinedSpin currently implements triggers and application models for:undefinedundefinedThe Spin internals and execution context (the part of Spin executing\ncomponents) are agnostic of the event source and application model.\nIn this document we will explore how to extend Spin with custom event sources\n(triggers) and application models built on top of the WebAssembly component\nmodel, as well as how to embed Spin in your application.In this article we will build a Spin trigger to run the applications based on a\ntimer, executing Spin components at configured time interval.The current application types that can be implemented with Spin have entry points\ndefined using\nundefined:// The entry point for an HTTP handler.\nhandle-http-request: function(req: request) -> response\n\n// The entry point for a Redis handler.\nhandle-redis-message: function(msg: payload) -> expected<_, error>The entry point we want to execute for our timer trigger takes a string as its\nonly argument (the trigger will populate that with the current date and time),\nand it expects a string as the only return value. This is purposefully chosen\nto be a simple function signature:// examples/spin-timer/spin-timer.wit\nhandle-timer-request: function(msg: string) -> stringThis is the function that all components executed by the timer trigger must\nimplement, and which is used by the timer executor when instantiating and\ninvoking the component.Let's have a look at building the timer trigger:// examples/spin-timer/src/main.rs\nwit_bindgen_wasmtime::import!({paths: [\"spin-timer.wit\"], async: *});\ntype ExecutionContext = spin_engine::ExecutionContext<spin_timer::SpinTimerData>;\n\n/// A custom timer trigger that executes a component on every interval.\n#[derive(Clone)]\npub struct TimerTrigger {\n    /// The interval at which the component is executed.\n    pub interval: Duration,\n    /// The Spin execution context.\n    engine: Arc<ExecutionContext>,\n}A few important things to note from the start:undefinedundefinedundefinedFinally, whenever there is a new event (in the case of our timer-based trigger\nevery n seconds), we execute the entry point of a selected component:/// Execute the first component in the application manifest.\nasync fn handle(&self, msg: String) -> Result<()> {\n    // create a new Wasmtime store and instance based on the first component's WebAssembly module.\n    let (mut store, instance) =\n        self.engine\n            .prepare_component(&self.app.components[0].id, None, None, None, None)?;\n\n    // spawn a new thread and call the entry point function from the WebAssembly module \n    let res = spawn_blocking(move || -> Result<String> {\n            // use the auto-generated WIT bindings to get the Wasm exports and call the `handle-timer-request` function.\n        let t = spin_timer::SpinTimer::new(&mut store, &instance, |host| {\n            host.data.as_mut().unwrap()\n        })?;\n        Ok(t.handle_timer_request(&mut store, &msg)?)\n    })\n    .await??;\n    // do something with the result.\n    log::info!(\"{}\\n\", res);\n    Ok(())\n}A few notes:undefinedundefinedundefinedThis is very similar to how the undefined and undefined\ntriggers are implemented, and it is the recommended way to extend Spin with your\nown trigger and application model.Writing components for the new trigger can be done by using the\nundefined from\nRust and other supported languages (see undefined):// automatically generate Rust bindings that help us implement the \n// `handle-timer-request` function that the trigger will execute.\nwit_bindgen_rust::export!(\"../spin-timer.wit\");\n...\nfn handle_timer_request(msg: String) -> String {\n    format!(\"ECHO: {}\", msg)\n}Components can be compiled to WebAssembly, then used from a spin.toml\napplication manifest.Embedding the new trigger in a Rust application is done by creating a new trigger\ninstance, then calling its run function:// app() is a utility function that generates a complete application configuration.\nlet trigger = TimerTrigger::new(Duration::from_secs(1), app()).await?;\n// run the trigger indefinitely\ntrigger.run().awaitundefinedIn this example, we built a simple timer trigger — building more complex triggers\nwould also involve updating the Spin application manifest, and extending\nthe application-level trigger configuration, as well as component-level\ntrigger configuration (an example of component-level trigger configuration\nfor this scenario would be each component being able to define its own\nindependent time interval for scheduling the execution).","url":"/spin/extending-and-embedding"},{"project":"spin","title":"Extending and embedding Spin","subheading":"Other ways to extend and use Spin","content":"Besides building custom triggers, the internals of Spin could also be used\nindependently:undefinedundefined","url":"/spin/extending-and-embedding#other-ways-to-extend-and-use-spin"},{"project":"spin","title":"Building Spin components in Go","subheading":"","content":"undefined is an implementation of the\nundefined for embedded systems and WebAssembly.\nThe Spin SDK for Go uses\nundefined\nto build programs written in Go as Spin components.undefinedundefined","url":"/spin/go-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Versions","content":"TinyGo 0.25.x is recommended, which requires Go 1.16.x or newer.undefined","url":"/spin/go-components#versions"},{"project":"spin","title":"Building Spin components in Go","subheading":"HTTP components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Go has improved support for\nwriting applications, through its SDK.Building a Spin HTTP component using the Go SDK means writing a single function,\ninit — below is a complete implementation for such a component:// A Spin component written in Go that returns \"Hello, Fermyon!\"\npackage main\n\nimport (\n \"fmt\"\n \"net/http\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n  w.Header().Set(\"Content-Type\", \"text/plain\")\n  fmt.Fprintln(w, \"Hello Fermyon!\")\n })\n}\n\nfunc main() {}The important things to note in the implementation above:undefinedundefinedundefined","url":"/spin/go-components#versions#http-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Sending outbound HTTP requests","content":"If allowed, Spin components can send outbound requests to HTTP endpoints. Let's\nsee an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:// A Spin component written in Go that sends a request to an API\n// with random dog facts.\n\npackage main\n\nimport (\n \"bytes\"\n \"fmt\"\n \"net/http\"\n \"os\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n  r, _ := spinhttp.Get(\"https://some-random-api.ml/facts/dog\")\n\n  fmt.Fprintln(w, r.Body)\n  fmt.Fprintln(w, r.Header.Get(\"content-type\"))\n\n  // `spin.toml` is not configured to allow outbound HTTP requests to this host,\n  // so this request will fail.\n  if _, err := spinhttp.Get(\"https://fermyon.com\"); err != nil {\n   fmt.Fprintf(os.Stderr, \"Cannot send HTTP request: %v\", err)\n  }\n })\n}\n\nfunc main() {}The component can be built using the tingygo toolchain:$ tinygo build -wasm-abi=generic -target=wasi -no-debug -o main.wasm main.goBefore we can execute this component, we need to add the\nsome-random-api.ml domain to the application manifest allowed_http_hosts\nlist containing the list of domains the component is allowed to make HTTP\nrequests to:# spin.toml\nspin_version = \"1\"\nname = \"spin-hello-tinygo\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"tinygo-hello\"\nsource = \"main.wasm\"\nallowed_http_hosts = [ \"some-random-api.ml\" ]\n[component.trigger]\nroute = \"/hello\"undefinedRunning the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /hello:$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\ncontent-type: text/plain; charset=utf-8\nserver: spin/0.1.0\ncontent-length: 85\ndate: Fri, 18 Mar 2022 23:27:33 GMT\n\n{{\"fact\":\"Seventy percent of people sign their dog's name on their holiday cards.\"}}undefinedundefined","url":"/spin/go-components#versions#http-components#sending-outbound-http-requests"},{"project":"spin","title":"Building Spin components in Go","subheading":"Redis components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger, which\nwill connect to a Redis instance and will execute components for new messages\non the configured channels.undefinedWriting a Redis component in Go also takes advantage of the SDK:package main\n\nimport (\n \"fmt\"\n\n \"github.com/fermyon/spin/sdk/go/redis\"\n)\n\nfunc init() {\n // redis.Handle() must be called in the init() function.\n redis.Handle(func(payload []byte) error {\n  fmt.Println(\"Payload::::\")\n  fmt.Println(string(payload))\n  return nil\n })\n}\n\n// main function must be included for the compiler but is not executed.\nfunc main() {}The manifest for a Redis application must contain the address of the Redis instance:spin_version = \"1\"\nname = \"spin-redis\"\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"echo-message\"\nsource = \"main.wasm\"\n[component.trigger]\nchannel = \"messages\"\n[component.build]\ncommand = \"tinygo build -wasm-abi=generic -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"The application will connect to redis://localhost:6379, and for every new message\non the messages channel, the echo-message component will be executed:# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin build --up\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component:INFO spin_redis_engine: Received message on channel \"messages\"\nPayload::::\nHello, there!","url":"/spin/go-components#versions#http-components#sending-outbound-http-requests#redis-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Storing data in Redis from Go components","content":"Using the Spin's Go SDK, you can use the Redis key/value store to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Go SDK to connect to Redis:package main\n\nimport (\n \"net/http\"\n \"os\"\n\n spin_http \"github.com/fermyon/spin/sdk/go/http\"\n \"github.com/fermyon/spin/sdk/go/redis\"\n)\n\nfunc init() {\n // handler for the http trigger\n spin_http.Handle(func(w http.ResponseWriter, r *http.Request) {\n\n  // addr is the environment variable set in `spin.toml` that points to the\n  // address of the Redis server.\n  addr := os.Getenv(\"REDIS_ADDRESS\")\n\n  // channel is the environment variable set in `spin.toml` that specifies\n  // the Redis channel that the component will publish to.\n  channel := os.Getenv(\"REDIS_CHANNEL\")\n\n  // payload is the data publish to the redis channel.\n  payload := []byte(`Hello redis from tinygo!`)\n\n  if err := redis.Publish(addr, channel, payload); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // set redis `mykey` = `myvalue`\n  if err := redis.Set(addr, \"mykey\", []byte(\"myvalue\")); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // get redis payload for `mykey`\n  if payload, err := redis.Get(addr, \"mykey\"); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n  } else {\n   w.Write([]byte(\"mykey value was: \"))\n   w.Write(payload)\n  }\n })\n}\n\nfunc main() {}This HTTP component demonstrates fetching a value from Redis by key, setting a\nkey with a value, and publishing a message to a Redis channel. The component is\ntriggered by an HTTP request served on the route configured in the spin.toml:[[component]]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\n[component.trigger]\nroute = \"/publish\"This HTTP component can be paired with a Redis component, triggered on new\nmessages on the messages Redis channel.undefined","url":"/spin/go-components#versions#http-components#sending-outbound-http-requests#redis-components#storing-data-in-redis-from-go-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Using Go packages in Spin components","content":"Any\nundefined that can be imported in TinyGo and that compiles to\nWASI can be used when implementing a Spin component.undefined","url":"/spin/go-components#versions#http-components#sending-outbound-http-requests#redis-components#storing-data-in-redis-from-go-components#using-go-packages-in-spin-components"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"","content":"An important workload in event-driven environments is represented by HTTP\napplications, and Spin has built-in support for creating and running HTTP\ncomponents. This document presents an overview of the HTTP trigger, as well as\nsome implementation details around the WebAssembly component model and how it\nis used in Spin.The HTTP trigger in Spin is a web server. It listens for incoming requests and\nbased on the undefined, it routes them to an\nundefined which instantiates the appropriate component, executes its\nentry point function, then returns an HTTP response.Creating an HTTP application is done when undefined\nby defining the top-level application trigger:# spin.toml\ntrigger = { type = \"http\", base = \"/\" }Then, when defining the component (in spin.toml), there are two pieces of\nconfiguration that can be set for the component trigger: the route,\nand the undefined (see details below about executors). For example:undefined[component.trigger]\nroute = \"/hello\"\nexecutor = { type = \"spin\" }undefined[component.trigger]\nroute = \"/goodbye\"\nexecutor = { type = \"wagi\" }","url":"/spin/http-trigger"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"Routing","content":"Routing an incoming request to a particular component is done using the\napplication base path (base in spin.toml) and the component defined routes\n(route in the component configuration) by prefixing the application base path\nto all component routes defined for that application.For example, if the application base path is base = /base, and a component\nhas defined route = /foo, that component will be executed for requests on\nhttp(s)://<spin-up-defined-address-and-port>/base/foo.Components can either define exact routes, for example route = /bar/baz, where\nthe component will be invoked only for requests on /base/bar/baz, or they\ncan define a wildcard as the last path segment, for example route = /bar/baz/...,\nwhich means the component will be invoked for every request starting with the\n/base/bar/baz/ prefix (such as /base/bar/baz, /base/bar/baz/qux,\n/base/bar/baz/qux/quux and so on).If multiple components could potentially handle the same request based on their\ndefined routes, the last component defined in spin.toml takes precedence.\nIn the following example:# spin.toml\n\ntrigger = { type = \"http\", base = \"/\"}\n\n[[component]]\nid = \"component-1\"\n[component.trigger]\nroute = \"/...\"\n\n[[component]]\nid = \"component-2\"\n[component.trigger]\nroute = \"/foo/...\"Any request starting with the  /foo/ prefix  will be handled by component-2,\nwhich is the last one defined in spin.toml.Every HTTP application has a special route always configured at /.well-known/spin/health, which\nreturns OK 200 when the Spin instance is healthy.Once Spin selects a component to handle an incoming request based on the route\nconfiguration, it will instantiate and execute that component based on its\ndefined undefined, and the next sections explore the two ways of building\nHTTP components based on the two available executors.","url":"/spin/http-trigger#routing"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"The Spin HTTP executor","content":"Spin is built on top of the\nundefined.\nWe undefined believe the component model represents the future of WebAssembly,\nand we are working with the undefined\ncommunity on building exciting new features and tools for it. As a result, the\nSpin HTTP undefined is defined using WebAssembly interfaces.undefinedWe define the HTTP objects as\nundefined\nobjects, currently using undefined:// wit/ephemeral/http-types.wit\n\n// The HTTP status code.\ntype http-status = u16\n// The HTTP body.\ntype body = list<u8>\n// The HTTP headers represented as a list of (name, value) pairs.\ntype headers = list<tuple<string, string>>\n// The HTTP parameter queries, represented as a list of (name, value) pairs.\ntype params = list<tuple<string, string>>\n// The HTTP URI of the current request.\ntype uri = string\n// The HTTP method.\nenum method { get, post, put,... }\n\n// An HTTP request.\nrecord request {\n    method: method,\n    uri: uri,\n    headers: headers,\n    params: params,\n    body: option<body>,\n}\n\n// An HTTP response.\nrecord response {\n    status: http-status,\n    headers: option<headers>,\n    body: option<body>,\n}undefinedThen, we define the entry point for a Spin HTTP component:// wit/ephemeral/spin-http.wit\n\nuse * from http-types\n// The entry point for an HTTP handler.\nhandle-http-request: function(req: request) -> responseThis is the function signature that all HTTP components must implement, and\nwhich is used by the Spin HTTP executor when instantiating and invoking the\ncomponent.\nThis interface (spin-http.wit) can be directly used together with the\nundefined\nto build a component that the Spin HTTP executor can invoke.\nThis is exactly how undefined is built, and,\nas more languages add support for the component model, how we plan to add\nsupport for them as well.","url":"/spin/http-trigger#routing#the-spin-http-executor"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"The Wagi HTTP executor","content":"The WebAssembly component model proposal is currently in its early stages, which\nmeans only a few programming languages fully implement it. While the language\ncommunities implement toolchain support for the component model (for emitting\ncomponents and for automatically generating bindings for importing other\ncomponents), we want to allow developers to use any language that compiles to\nWASI to build Spin HTTP applications. This is why Spin currently implements an\nHTTP executor based on undefined, or the\nWebAssembly Gateway Interface, a project that implements the\nundefined\nspecification for WebAssembly.undefinedWagi allows a module built in any programming language that compiles to undefined\nto handle an HTTP request by passing the HTTP request information to the module's\nstandard input, environment variables, and arguments, and expecting the HTTP\nresponses through the module's standard output.\nThis means that if a language has support for the WebAssembly System Interface,\nit can be used to build Spin HTTP components.\nThe Wagi model is only used to parse the HTTP request and response. Everything\nelse — defining the application, running it, or undefined\nis done the same way as a component that uses the Spin executor.Building a Wagi component in a particular programming language that can compile\nto wasm32-wasi does not require any special libraries — instead,\nundefined can\nbe done by reading the HTTP request from the standard input and environment\nvariables, and sending the HTTP response to the module's standard output.In pseudo-code, this is the minimum required in a Wagi component:undefinedundefinedundefinedprint(\"content-type: text/html; charset=UTF-8\\n\\n\");\nprint(\"hello world\\n\");The undefined supports the Spin executor.\nHere is another example, written in undefined,\na new programming language that natively targets WebAssembly:import Process from \"sys/process\";\nimport Array from \"array\";\n\nprint(\"content-type: text/plain\\n\");\n\n// This will print all the Wagi env variables\nprint(\"==== Environment: ====\");\nArray.forEach(print, Process.env());\n\n// This will print the route path followed by each query\n// param. So /foo?bar=baz will be [\"/foo\", \"bar=baz\"].\nprint(\"==== Args: ====\");\nArray.forEach(print, Process.argv());undefined","url":"/spin/http-trigger#routing#the-spin-http-executor#the-wagi-http-executor"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"The default headers set in Spin HTTP components","content":"Spin sets a few default headers on the request based on the base path, component\nroute, and request URI, which will always be available when writing a module:undefinedundefinedundefinedundefinedundefinedundefined","url":"/spin/http-trigger#routing#the-spin-http-executor#the-wagi-http-executor#the-default-headers-set-in-spin-http-components"},{"project":"spin","title":"The Spin HTTP trigger","subheading":"The default headers set in Wagi HTTP components","content":"For Wagi HTTP components, the following are set as environment variables for the\nhandler WebAssembly modules:undefinedundefinedundefinedundefinedundefinedundefinedBesides the headers above, components that use the Wagi executor also have set\nundefined.","url":"/spin/http-trigger#routing#the-spin-http-executor#the-wagi-http-executor#the-default-headers-set-in-spin-http-components#the-default-headers-set-in-wagi-http-components"},{"project":"spin","title":"Introducing Spin","subheading":"","content":"Spin is a framework for building and running event-driven microservice applications with WebAssembly (Wasm) components. With Spin, we’re trying to make it easier to get started with using WebAssembly on the server so that we can all take advantage of the security, portability, and speed WebAssembly provides when it comes to running microservices.undefined","url":"/spin/index"},{"project":"spin","title":"Introducing Spin","subheading":"Structure of a Spin Application","content":"undefinedundefinedSpin executes the component(s) as a result of events being generated by the trigger(s)\ndefined in the spin.toml file.","url":"/spin/index#structure-of-a-spin-application"},{"project":"spin","title":"Introducing Spin","subheading":"Example Spin Application","content":"The following illustrates how to define an HTTP application.","url":"/spin/index#structure-of-a-spin-application#example-spin-application"},{"project":"spin","title":"Introducing Spin","subheading":"HTTP Handler","content":"This hello_world function written in Rust defines a component that takes a Request and returns a Result<Response>.#[http_component]​\nfn hello_world(_req: Request) -> Result<Response> {​\n    Ok(http::Response::builder()​\n        .status(200)​\n        .body(Some(\"Hello, Fermyon!\".into()))?)​\n}​","url":"/spin/index#structure-of-a-spin-application#example-spin-application#http-handler"},{"project":"spin","title":"Introducing Spin","subheading":"Spin Manifest","content":"Once the code is compiled to a WebAssembly component, it can be referenced in a spin.toml\nfile to create an HTTP application like what you can see below:spin_version = \"1\"\nname = \"spin-hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"hello\"\nsource = \"<path to compiled Wasm module>\"\n[component.trigger]\nroute = \"/hello\"","url":"/spin/index#structure-of-a-spin-application#example-spin-application#http-handler#spin-manifest"},{"project":"spin","title":"Introducing Spin","subheading":"Running a Spin Application","content":"Running this application with the spin CLI is as simple as using the spin up command.\nBecause a trigger type of http is specified in the spin.toml file, spin up will start\na web server:$ spin up\nServing HTTP on address http://127.0.0.1:3000\nAvailable Routes:\n  hello: http://127.0.0.1:3000/helloAny time a request is made on the /hello route, it will invoke the\nhello_world function. Adding another component is as simple as adding another [[component]]\nstanza to the spin.toml file.","url":"/spin/index#structure-of-a-spin-application#example-spin-application#http-handler#spin-manifest#running-a-spin-application"},{"project":"spin","title":"Introducing Spin","subheading":"Deploying a Spin application","content":"Spin applications can be deployed to the fully managed undefined, or using the self-hosted undefined","url":"/spin/index#structure-of-a-spin-application#example-spin-application#http-handler#spin-manifest#running-a-spin-application#deploying-a-spin-application"},{"project":"spin","title":"Introducing Spin","subheading":"Next Steps","content":"undefinedundefinedundefined","url":"/spin/index#structure-of-a-spin-application#example-spin-application#http-handler#spin-manifest#running-a-spin-application#deploying-a-spin-application#next-steps"},{"project":"spin","title":"Install Spin","subheading":"","content":"","keywords":"install","url":"/spin/install"},{"project":"spin","title":"Install Spin","subheading":"Installing Spin","content":"Spin runs on Linux (amd64 and arm64), macOS (Intel and Apple Silicon), and Windows with WSL2 (amd64).There are multiple ways to install Spin. The easiest is to use the installer script, hosted on this site.This command will install the latest version of Spin in your current directory.$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashIt's highly recommended to add Spin to a folder, which is on your path, e.g.:$ sudo mv spin /usr/local/bin/","keywords":"install","url":"/spin/install#installing-spin"},{"project":"spin","title":"Install Spin","subheading":"Linux: Additional Libraries","content":"On a fresh Linux installation, you will also need the standard build toolchain\n(gcc, make, etc.), the SSL library headers, and on some distributions you may need pkg-config.On Debian-like distributions, including Ubuntu, you can install these with a command like this:$ sudo apt-get install build-essential libssl-dev pkg-config","keywords":"install","url":"/spin/install#installing-spin#linux-additional-libraries"},{"project":"spin","title":"Install Spin","subheading":"Installing a specific version of Spin","content":"To install a specific version, you can pass arguments to the install script this way:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v v0.6.0To install the canary version of spin, you should pass the argument -v canary. The canary version is always the latest commit to the main branch of Spin.$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v canary","keywords":"install","url":"/spin/install#installing-spin#linux-additional-libraries#installing-a-specific-version-of-spin"},{"project":"spin","title":"Install Spin","subheading":"Building Spin from source","content":"undefined for a detailed guide on building Spin from source:$ git clone https://github.com/fermyon/spin\n$ cd spin && make build\n$ ./target/release/spin --help","keywords":"install","url":"/spin/install#installing-spin#linux-additional-libraries#installing-a-specific-version-of-spin#building-spin-from-source"},{"project":"spin","title":"Install Spin","subheading":"Using Cargo to install Spin","content":"If you have undefined, you can clone the repo and install it to your path:$ git clone https://github.com/fermyon/spin -b v0.6.0\n$ cd spin\n$ rustup target add wasm32-wasi\n$ cargo install --locked --path .\n$ spin --help","keywords":"install","url":"/spin/install#installing-spin#linux-additional-libraries#installing-a-specific-version-of-spin#building-spin-from-source#using-cargo-to-install-spin"},{"project":"spin","title":"Install Spin","subheading":"Next Steps","content":"undefinedundefinedundefined","keywords":"install","url":"/spin/install#installing-spin#linux-additional-libraries#installing-a-specific-version-of-spin#building-spin-from-source#using-cargo-to-install-spin#next-steps"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"","content":"With JavaScript being a very popular language, Spin provides support for building components with it using the experimental SDK. The development of the JavaScript SDK is continually being worked on to improve user experience and add features.undefinedundefinedIn order to compile JavaScript programs to Spin components, you also need to install a Spin plugin js2wasm using the following command:$ spin plugin update\n$ spin plugin install js2wasm","url":"/spin/javascript-components"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Installing Templates","content":"The JavaScript/TypeScript templates can be installed from undefined using the following command:$ spin templates install --git https://github.com/fermyon/spin-js-sdkwhich will install the http-js and http-ts templates.Copying remote template source\nInstalling template http-ts...\nInstalling template http-js...\nInstalled 2 template(s)\n\n+-------------------------------------------------+\n| Name      Description                           |\n+=================================================+\n| http-js   HTTP request handler using Javascript |\n| http-ts   HTTP request handler using Typescript |\n+-------------------------------------------------+","url":"/spin/javascript-components#installing-templates"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Structure of a JS/TS Component","content":"A new JS/TS component can be created using the following command:$ spin new http-ts hello-world --accept-defaultsThis creates a directory of the following structure:hello-world/\n├── package.json\n├── package-lock.json\n├── README.md\n├── spin.toml\n├── src\n│   └── index.ts\n├── tsconfig.json\n└── webpack.config.jsThe source for the component is present in src/index.ts. undefined is used to bundle the component into a single .js file which will then be compiled to a .wasm module using the js2wasm plugin.","url":"/spin/javascript-components#installing-templates#structure-of-a-jsts-component"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Building and Running the Template","content":"First, the dependencies for the template need to be installed and then bundled into a single JavaScript file using the following commands:$ cd hello-world\n$ npm install\n$ npm run buildOnce a Spin compatible module is created, it can be run using$ spin up","url":"/spin/javascript-components#installing-templates#structure-of-a-jsts-component#building-and-running-the-template"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Javascript/TypeScript has improved support\nfor writing Spin components with the Spin JS/TS SDK.undefinedBuilding a Spin HTTP component using the JS/TS SDK means writing a single function\nthat takes an HTTP request as a parameter, and returns an HTTP response — below\nis a complete implementation for such a component in TypeScript:import { HandleRequest, HttpRequest, HttpResponse } from \"@fermyon/spin-sdk\"\n\nconst encoder = new TextEncoder()\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n\n    return {\n        status: 200,\n        headers: {\"foo\": \"bar\"},\n        body: encoder.encode(\"Hello from JS-SDK\").buffer\n    }\n}The important things to note in the implementation above:undefinedundefined","url":"/spin/javascript-components#installing-templates#structure-of-a-jsts-component#building-and-running-the-template#http-components"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:import { HandleRequest, HttpRequest, HttpResponse } from \"@fermyon/spin-sdk\"\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n\n    const dogFact = await fetch(\"https://some-random-api.ml/facts/dog\")\n\n    const dogFactBody = await dogFact.text()\n\n    const env = JSON.stringify(process.env)\n\n    const body = `Here's a dog fact: ${dogFactBody}\\n`\n\n    return {\n        status: 200,\n        headers: { \"foo\": \"bar\" },\n        body: encoder.encode(body).buffer\n    }\n}Before we can execute this component, we need to add the some-random-api.ml\ndomain to the application manifest allowed_http_hosts list containing the list of\ndomains the component is allowed to make HTTP requests to:# spin.toml\nspin_version = \"1\"\nauthors = [\"Fermyon Engineering <engineering@fermyon.com>\"]\nname = \"spin-http-js\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[variables]\nobject = { default = \"teapot\" }\n\n[[component]]\nid = \"hello\"\nsource = \"target/spin-http-js.wasm\"\nallowed_http_hosts = [\"https://some-random-api.ml\"]\n[component.trigger]\nroute = \"/hello\"\n[component.build]\ncommand = \"npm run build\"The component can be built using the spin build command. Running the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /hello:$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\ndate: Fri, 18 Mar 2022 03:54:36 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nserver: spin/0.1.0\n\nHere's a dog fact: {\"fact\":\"It's a myth that dogs only see in black and white. In fact, it's believed that dogs see primarily in blue, greenish-yellow, yellow and various shades of gray.\"}undefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.","url":"/spin/javascript-components#installing-templates#structure-of-a-jsts-component#building-and-running-the-template#http-components#sending-outbound-http-requests"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Storing Data in Redis from JS/TS Components","content":"undefinedUsing the Spin's JS SDK, you can use the Redis key/value store and to publish messages to Redis channels.Let's see how we can use the JS/TS SDK to connect to Redis:import { HandleRequest, HttpRequest, HttpResponse } from \"@fermyon/spin-sdk\"\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nconst redisAddress = \"redis://localhost:6379/\"\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n\n    spinSdk.redis.incr(redisAddress, \"test\")\n    spinSdk.redis.incr(redisAddress, \"test\")\n\n    console.log(decoder.decode(spinSdk.redis.get(redisAddress, \"test\")))\n\n    spinSdk.redis.set(redisAddress, \"test-set\", encoder.encode(\"This is a test\").buffer)\n\n    console.log(decoder.decode(spinSdk.redis.get(redisAddress, \"test-set\")))\n\n    spinSdk.redis.publish(redisAddress, \"test\", encoder.encode(\"This is a test\").buffer)\n\n    return {\n        status: 200,\n        headers: {\"foo\": \"bar\"},\n        body: encoder.encode(\"Hello from JS-SDK\").buffer\n    }\n}This HTTP component demonstrates fetching a value from Redis by key, setting a key with a value, and publishing a message to a Redis channel. The component is triggered by an HTTP request served on the route configured in the spin.toml:undefined","url":"/spin/javascript-components#installing-templates#structure-of-a-jsts-component#building-and-running-the-template#http-components#sending-outbound-http-requests#storing-data-in-redis-from-jsts-components"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Using External NPM Libraries","content":"undefinedSome NPM packages can be installed and used in the component. If a popular library does not work, please open an issue/feature request in the undefined.","url":"/spin/javascript-components#installing-templates#structure-of-a-jsts-component#building-and-running-the-template#http-components#sending-outbound-http-requests#storing-data-in-redis-from-jsts-components#using-external-npm-libraries"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Suggested Libraries for Common Tasks","content":"These are some of the suggested libraries that have been tested and confired to work with the SDK for common tasks.{{ details \"Parsing formdata\" \"- undefined\" }}{{ details \"Unique ID generator\" \"- undefined\\n- undefined\\n- undefined\" }}","url":"/spin/javascript-components#installing-templates#structure-of-a-jsts-component#building-and-running-the-template#http-components#sending-outbound-http-requests#storing-data-in-redis-from-jsts-components#using-external-npm-libraries#suggested-libraries-for-common-tasks"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Caveats","content":"undefinedundefinedundefined","url":"/spin/javascript-components#installing-templates#structure-of-a-jsts-component#building-and-running-the-template#http-components#sending-outbound-http-requests#storing-data-in-redis-from-jsts-components#using-external-npm-libraries#suggested-libraries-for-common-tasks#caveats"},{"project":"spin","title":"Building Spin components in other languages","subheading":"","content":"undefinedundefinedWebAssembly is becoming undefined, and as language toolchains add support for the\nundefined,\nbuilding Spin components will also become supported.As a general rule:undefinedundefinedundefinedundefined","url":"/spin/other-languages"},{"project":"spin","title":"Building Spin components in other languages","subheading":"AssemblyScript","content":"undefined is a TypeScript-based language that compiles directly to WebAssembly.\nAssemblyScript has WASI/Wagi support, and so can be used with Spin.undefinedundefinedundefined","url":"/spin/other-languages#assemblyscript"},{"project":"spin","title":"Building Spin components in other languages","subheading":"C/C++","content":"C and C++ are both broadly supported in the WebAssembly ecosystem. WASI/Wagi support means that both can be used to write Spin apps.undefinedundefinedundefined","url":"/spin/other-languages#assemblyscript#cc"},{"project":"spin","title":"Building Spin components in other languages","subheading":"C# and .NET languages","content":".NET has experimental support for WASI, so many (if not all) .NET languages, including C# and F#, can be used to write Spin applications.undefinedundefined","url":"/spin/other-languages#assemblyscript#cc#c-and-net-languages"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Grain","content":"undefined, a new functional programming language, has WASI/Wagi support and can be used to write Spin apps.undefinedundefinedundefined","url":"/spin/other-languages#assemblyscript#cc#c-and-net-languages#grain"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Python","content":"Python's interpreter can be compiled to WebAssembly, and it has WASI support. It is known to work for Spin.undefinedundefinedundefinedundefinedundefined","url":"/spin/other-languages#assemblyscript#cc#c-and-net-languages#grain#python"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Ruby","content":"Upstream undefined officially supports WebAssembly and WASI, and we here at Fermyon have successfully run Ruby apps in Spin.undefinedundefined","url":"/spin/other-languages#assemblyscript#cc#c-and-net-languages#grain#python#ruby"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Zig","content":"Zig is a low-level systems language that has support for Wasm and WASI, and can be used to write Spin apps.undefinedundefined","url":"/spin/other-languages#assemblyscript#cc#c-and-net-languages#grain#python#ruby#zig"},{"project":"spin","title":"Taking Spin for a spin","subheading":"","content":"undefined","keywords":"quickstart","url":"/spin/quickstart"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Getting the  spin  binary","content":"You can install the spin binary using the install.sh script hosted on this site.$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashAt this point, move the spin binary somewhere in your path, so it can be\naccessed from any directory. For example:$ sudo mv ./spin /usr/local/bin/spinMore ways to undefined","keywords":"quickstart","url":"/spin/quickstart#getting-the-spin-binary"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Creating a new Spin application from a template","content":"Spin helps you create a new application based on templates:$ spin templates list\nYou have no templates installed. Run\nspin templates install --git https://github.com/fermyon/spin\nto install a starter set.We first need to configure the undefined:$ spin templates install --git https://github.com/fermyon/spin\nCopying remote template source\nInstalling template redis-rust...\nInstalling template http-rust...\nInstalling template http-go...\n+--------------------------------------------------+\n| Name         Description                         |\n+==================================================+\n| http-go      HTTP request handler using (Tiny)Go |\n| http-rust    HTTP request handler using Rust     |\n| redis-rust   Redis message handler using Rust    |\n| ...                                              |\n+--------------------------------------------------+undefinedLet's create a new Spin application based on the Rust HTTP template:$ spin new\nPick a template to start your project with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-csharp (HTTP request handler using C# (EXPERIMENTAL))\n  http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n> http-rust (HTTP request handler using Rust)\n  http-swift (HTTP request handler using SwiftWasm)\n  http-zig (HTTP request handler using Zig)\n  redis-go (Redis message handler using (Tiny)Go)\n  redis-rust (Redis message handler using Rust)\n\nEnter a name for your new project: hello_rust\nProject description: My first Rust Spin application\nHTTP base: /\nHTTP path: /...\n$ tree\n├── .cargo\n│   └── config.toml\n├── .gitignore\n├── Cargo.toml\n├── spin.toml\n└── src\n    └── lib.rsThis command created all the necessary files we need to build and run our first\nSpin application. Here is spin.toml, the manifest file for a Spin application:spin_version = \"1\"\ndescription = \"A simple Spin HTTP component in Rust\"\nname = \"spin-hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"spin-hello-world\"\nsource = \"target/wasm32-wasi/release/spin_hello_world.wasm\"\n[component.trigger]\nroute = \"/hello\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"This represents a simple Spin HTTP application (triggered by an HTTP request), with\na single component called spin-hello-world. Spin will execute the spin_hello_world.wasm\nWebAssembly module for HTTP requests on the route /hello.\n(See the undefined for a detailed guide on the Spin\napplication manifest.)Now let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Rust — a regular Rust function that\ntakes an HTTP request as a parameter and returns an HTTP response, and it is\nannotated with the http_component macro:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn spin_hello_world(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req.headers());\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Fermyon\".into()))?)\n}undefinedFor Rust templates you need to install the wasm32-wasi target using rustup:$ rustup target add wasm32-wasi\ninfo: downloading component 'rust-std' for 'wasm32-wasi'\ninfo: installing component 'rust-std' for 'wasm32-wasi'\n 19.8 MiB /  19.8 MiB (100 %)  11.5 MiB/s in  1s ETA:  0sFor TinyGo templates you need the undefined.We can build this component using the regular Rust toolchain, targeting\nwasm32-wasi, which will produce the WebAssembly module and place it at\ntarget/wasm32-wasi/release/spinhelloworld.wasm as referenced in the\nspin.toml. For convenience, we can use the spin build command, which will\nexecute the command defined above in spin.toml and call the Rust toolchain:$ spin build\nExecuting the build command for component spin-hello-world: cargo build --target wasm32-wasi --release\n   Compiling spin_hello_world v0.1.0\n    Finished release [optimized] target(s) in 0.10s\nSuccessfully ran the build command for the Spin components.undefinedundefinedIf you run into errors, you might want to use rustup check to see if your Rust installation is up-to-date.","keywords":"quickstart","url":"/spin/quickstart#getting-the-spin-binary#creating-a-new-spin-application-from-a-template"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Running the application with  spin up","content":"Now that we configured the application and built our component, we can undefined\nthe application (pun intended):$ spin up\nServing HTTP on address http://127.0.0.1:3000\nAvailable Routes:\n  spin-hello-world: http://127.0.0.1:3000/helloOptionally, set the RUST_LOG environment variable for detailed logs, before running spin up.export RUST_LOG=spin=traceSpin will instantiate all components from the application manifest, and\nwill create the router configuration for the HTTP trigger accordingly. The\ncomponent can now be invoked by making requests to http://localhost:3000/hello\n(see route field in the configuration):$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\nfoo: bar\ncontent-length: 15\n\nHello, Fermyon!You can add as many components as needed in spin.toml, mount files and\ndirectories, allow granular outbound HTTP connections, or set environment variables\n(see the undefined for a detailed guide on\nthe Spin application manifest) and iterate locally with\nspin up --file spin.toml until you are ready to distribute the application.Congratulations! You just completed building and running your first Spin\napplication!\nNext, check out the undefined or undefined language\nguides, or have a look at undefined.","keywords":"quickstart","url":"/spin/quickstart#getting-the-spin-binary#creating-a-new-spin-application-from-a-template#running-the-application-with-spin-up"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Next Steps","content":"undefinedundefined","keywords":"quickstart","url":"/spin/quickstart#getting-the-spin-binary#creating-a-new-spin-application-from-a-template#running-the-application-with-spin-up#next-steps"},{"project":"spin","title":"The Spin Redis trigger","subheading":"","content":"Spin applications can be triggered by a new message on a undefined.\nSpin will connect to a configured Redis instance and will invoke components for\nnew messages on the configured channels.undefinedThe Redis instance address is specified in the application trigger:# spin.toml\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }undefinedThen, all components in the application are triggered when new messages are\npublished to channels in the instance. undefined the channel\nis done by setting the channel field in the component trigger configuration.[component.trigger]\nchannel = \"messages\"","url":"/spin/redis-trigger"},{"project":"spin","title":"The Spin Redis trigger","subheading":"The WebAssembly interface","content":"The Redis trigger is built on top of the\nundefined.\nThe current interface is defined using the\nundefined\nformat, and is a function that takes the message payload as its only parameter:// wit/ephemeral/spin-redis.wit\n\n// The message payload.\ntype payload = list<u8>\n\n// The entry point for a Redis handler.\nhandle-redis-message: function(msg: payload) -> expected<_, error>undefinedThis is the function that all Redis components must implement, and which is\nused by the Spin Redis executor when instantiating and invoking the component.\nThis interface (spin-redis.wit) can be directly used together with the\nundefined\nto build a component that the Spin HTTP executor can invoke.\nThis is exactly how undefined is built, and,\nas more languages add support for the component model, how we plan to add\nsupport for them as well.undefined","url":"/spin/redis-trigger#the-webassembly-interface"},{"project":"spin","title":"Building Spin components in Rust","subheading":"","content":"Spin aims to have best-in-class support for building components in Rust, and\nwriting such components should be familiar for Rust developers.undefinedundefinedIn order to compile Rust programs to Spin components, you also need the\nwasm32-wasi target. You can add it using rustup:$ rustup target add wasm32-wasi","url":"/spin/rust-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"HTTP components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, but Rust has improved support\nfor writing Spin components with the Spin Rust SDK.undefinedBuilding a Spin HTTP component using the Rust SDK means writing a single function\nthat takes an HTTP request as a parameter, and returns an HTTP response — below\nis a complete implementation for such a component:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn hello_world(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req);\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Fermyon!\".into()))?)\n}The important things to note in the implementation above:undefinedundefinedundefined","url":"/spin/rust-components#http-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Sending outbound HTTP requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:#[http_component]\nfn hello_world(_req: Request) -> Result<Response> {\n    let mut res = spin_sdk::http::send(\n        http::Request::builder()\n            .method(\"GET\")\n            .uri(\"https://some-random-api.ml/facts/dog\")\n            .body(None)?,\n    )?;\n\n    res.headers_mut()\n        .insert(http::header::SERVER, \"spin/0.1.0\".try_into()?);\n\n    Ok(res)\n}Before we can execute this component, we need to add the some-random-api.ml\ndomain to the application manifest allowed_http_hosts list containing the list of\ndomains the component is allowed to make HTTP requests to:# spin.toml\nspin_version = \"1\"\nname = \"spin-hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"hello\"\nsource = \"target/wasm32-wasi/release/spinhelloworld.wasm\"\nallowed_http_hosts = [ \"some-random-api.ml\" ]\n[component.trigger]\nroute = \"/outbound\"Running the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /outbound:$ curl -i localhost:3000/outbound\nHTTP/1.1 200 OK\ndate: Fri, 18 Mar 2022 03:54:36 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nserver: spin/0.1.0\n\n{\"fact\":\"It's rumored that, at the end of the Beatles song, \n\\\"A Day in the Life,\\\" Paul McCartney recorded an ultrasonic whistle, \naudible only to dogs, just for his Shetland sheepdog.\"}undefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.","url":"/spin/rust-components#http-components#sending-outbound-http-requests"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Redis components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger —\nwhich will connect to a Redis instance and will execute Spin components for\nnew messages on the configured channels.undefinedWriting a Redis component in Rust also takes advantage of the SDK:/// A simple Spin Redis component.\n#[redis_component]\nfn on_message(msg: Bytes) -> Result<()> {\n    println!(\"{}\", from_utf8(&msg)?);\n    Ok(())\n}undefinedundefinedundefinedThe component can be built with Cargo by executing:$ cargo build --target wasm32-wasi --releaseThe manifest for a Redis application must contain the address of the Redis\ninstance the trigger must connect to:spin_version = \"1\"\nname = \"spin-redis\"\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"echo-message\"\nsource = \"target/wasm32-wasi/release/spinredis.wasm\"\n[component.trigger]\nchannel = \"messages\"This application will connect to redis://localhost:6379, and for every new\nmessage on the messages channel, the echo-message component will be executed.# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin up --file spin.toml\n# the application log file will output the following\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the  messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component we just built, which will emit the println! message to the application log file:INFO spin_redis_engine: Received message on channel \"messages\"\nHello, there!If you would also like to see the println! messages echoed to the console as they happen, please include the additional --follow-all option, when starting the spin application. For example:spin up --file spin.toml --follow-allundefined","url":"/spin/rust-components#http-components#sending-outbound-http-requests#redis-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Storing data in Redis from Rust components","content":"Using the Spin's Rust SDK, you can use the Redis key/value store and to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Rust SDK to connect to Redis:#[spin_sdk::http_component]\nfn publish(_req: Request) -> Result<Response> {\n    let address = std::env::var(REDIS_ADDRESS_ENV)?;\n    let channel = std::env::var(REDIS_CHANNEL_ENV)?;\n\n    // Get the message to publish from the Redis key \"mykey\"\n    let payload = spin_sdk::redis::get(&address, &\"mykey\").map_err(|_| anyhow!(\"Error querying Redis\"))?;\n\n    // Set the Redis key \"spin-example\" to value \"Eureka!\"\n    spin_sdk::redis::set(&address, &\"spin-example\", &b\"Eureka!\"[..])\n        .map_err(|_| anyhow!(\"Error executing Redis command\"))?;\n\n    // Publish to Redis\n    match spin_sdk::redis::publish(&address, &channel, &payload) {\n        Ok(()) => Ok(http::Response::builder().status(200).body(None)?),\n        Err(_e) => internal_server_error(),\n    }\n}This HTTP component demonstrates fetching a value from Redis by key, setting a\nkey with a value, and publishing a message to a Redis channel. The component is\ntriggered by an HTTP request served on the route configured in the spin.toml:[[component]]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\n[component.trigger]\nroute = \"/publish\"This HTTP component can be paired with a Redis component, triggered on new\nmessages on the messages Redis channel.undefined","url":"/spin/rust-components#http-components#sending-outbound-http-requests#redis-components#storing-data-in-redis-from-rust-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Using external crates in Rust components","content":"In Rust, Spin components are regular libraries that contain a function\nannotated using the http_component macro, compiled to the\nundefined.\nThis means that any undefined that compiles to wasm32-wasi can\nbe used when implementing the component.","url":"/spin/rust-components#http-components#sending-outbound-http-requests#redis-components#storing-data-in-redis-from-rust-components#using-external-crates-in-rust-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Troubleshooting","content":"Sometimes things can go wrong, especially such early projects. If you bump into\nissues building and running your Rust component:undefinedundefinedundefinedundefinedundefined","url":"/spin/rust-components#http-components#sending-outbound-http-requests#redis-components#storing-data-in-redis-from-rust-components#using-external-crates-in-rust-components#troubleshooting"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Manually creating new projects with Cargo","content":"The recommended way of creating new Spin projects is by starting from a template.\nThis section shows how to  manually create a new project with Cargo.When creating a new Spin projects with Cargo, you should use the --lib flag.$ cargo init --libA Cargo.toml with standard Spin dependencies looks like this:[package]\nname = \"your-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\n# Required to have a `cdylib` (dynamic library) to produce a Wasm module.\ncrate-type = [ \"cdylib\" ]\n\n[dependencies]\n# Useful crate to handle errors.\nanyhow = \"1\"\n# Crate to simplify working with bytes.\nbytes = \"1\"\n# General-purpose crate with common HTTP types.\nhttp = \"0.2\"\n# The Spin SDK.\nspin-sdk = { git = \"https://github.com/fermyon/spin\" }\n# Crate that generates Rust Wasm bindings from a WebAssembly interface.\nwit-bindgen-rust = { git = \"https://github.com/bytecodealliance/wit-bindgen\", rev = \"cb871cfa1ee460b51eb1d144b175b9aab9c50aba\" }At the time of this writing, wit-bindgen must be pinned to a specific rev.\nThis will change in the future.","url":"/spin/rust-components#http-components#sending-outbound-http-requests#redis-components#storing-data-in-redis-from-rust-components#using-external-crates-in-rust-components#troubleshooting#manually-creating-new-projects-with-cargo"},{"project":"spin","title":"Creating Spin templates","subheading":"","content":"Spin templates allow a Spin developer to quickly create the skeleton of an\napplication or component, ready for the application logic to be filled in.A template consists of two directories, content and metadata.undefinedundefinedFor examples of the directory contents, see the templates directory in the\nundefined.Templates must always be shared in a templates directory.  This allows the\ninstaller to locate them in repos that contain other content.","url":"/spin/template-authoring"},{"project":"spin","title":"Creating Spin templates","subheading":"Authoring the content","content":"Copy all the files that you want to be copied as part of the template into\nthe content directory. If you do nothing more, they will be copied\nverbatim. Often, though, you'll want to allow the user to put their own\nvalues in - for example, a project name, or a HTTP route.To do this, replace the text you want the user to be able to substitute\nwith an expression of the form {{parameter-name}}, where parameter-name\nis an identifier of your choice.  undefined - see below.You can reuse a parameter in more than one place - it will be prompted for\nonly once and will get the same value in each place.You can also transform the user value by specifying a filter after a bar:\n{{parameter-name | filter-name}}.  This is particularly useful when you\nwant to conform to specific language conventions. The following filters\nare supported:| Name          | Effect |\n|---------------|--------|\n| kebab_case  | Transforms input into kebab case, e.g. My Application to my-application |\n| snake_case  | Transforms input into snake case, e.g. My Application to my_application |\n| pascal_case | Transforms input into Pascal case, e.g. my appplication to MyApplication |","url":"/spin/template-authoring#authoring-the-content"},{"project":"spin","title":"Creating Spin templates","subheading":"Authoring the manifest","content":"The template manifest is a TOML file. It must be named spin-template.toml.manifest_version = \"1\"\nid = \"my-application\"\ndescription = \"An application\"\n\n[parameters]\n# Example parameter\nproject-name = { type = \"string\", prompt = \"Project name\" }undefinedundefinedundefinedThe parameters table is where you list the placeholders that you edited\ninto your content for the user to substitute. You should include an entry\nfor each parameter. The key is the parameter name, and the value a JSON\ndocument that contains at minimum a type and prompt.  type must\ncurrently be string.  prompt is displayed when prompting the user\nfor the value to substitute.The document may also have a default, which will be displayed to the user\nand can be accepted by pressing Enter. It may also specify constraints\non what the user is allowed to enter. The following constraints are\nsupported:| Key           | Value and usage |\n|---------------|-----------------|\n| pattern     | A regular expression. The user input must match the regular expression to be accepted. |","url":"/spin/template-authoring#authoring-the-content#authoring-the-manifest"},{"project":"spin","title":"Creating Spin templates","subheading":"Supporting  spin add","content":"The spin add command lets users add your template as a new component in\nan existing application. If you'd like to support this, you'll need to\nadd a few items to your metadata.undefinedundefined| Key             | Value and usage |\n|-----------------|-----------------|\n| snippets      | A subtable with an entry named component, whose value is the name of the file containing the component manifest template. (Don't include the snippets directory prefix - Spin knows to look in the snippets directory.) |\n| skip_files    | Optional array of content files that should undefined be copied when running in \"add component\" mode. For example, if your template contains a spin.toml file, you should use this setting to exclude that, because you want to add a new entry to the existing file, not overwrite it. |\n| skip_parameters | Optional array of parameters that Spin should undefined prompt for when running in \"add component\" mode. For example, the HTTP templates don't prompt for the base path, because that's defined at the application level, not set on an individual component. |Here is an example add_component table from a HTTP template:[add_component]\nskip_files = [\"spin.toml\"]\nskip_parameters = [\"http-base\"]\n[add_component.snippets]\ncomponent = \"component.txt\"undefined","url":"/spin/template-authoring#authoring-the-content#authoring-the-manifest#supporting-spin-add"},{"project":"spin","title":"Creating Spin templates","subheading":"Hosting templates in Git","content":"You can publish templates in a Git repo.  The templates must be in the /templates\ndirectory, with a subdirectory per template.When a user installs templates from your repo, by default Spin looks for a tag\nto identify a compatible version of the templates.  This tag is of the\nform spin/templates/vX.Y, where X is the major version, and Y the minor\nversion, of the user's copy of Spin. For example, if the user is on\nSpin 0.3.1, templates will be installed from spin/templates/v0.3.  If this\ntag does not exist, Spin installs templates from HEAD.","url":"/spin/template-authoring#authoring-the-content#authoring-the-manifest#supporting-spin-add#hosting-templates-in-git"},{"project":"spin","title":"Building a URL shortener with Spin","subheading":"","content":"This tutorial will walk you through building a Spin component that\nredirects short URLs to their configured destinations.\nIn essence, this is a simple HTTP component that returns a response that contains\nredirect information based on the user-defined routes.This is an evolving tutorial. As Spin allows building more complex components\n(through supporting access to services like databases), this tutorial will be\nupdated to reflect that.undefinedFirst, our URL shortener allows users to configure their own final URLs —\ncurrently, that is done through a configuration file that contains multiple\n[[route]] entries, each containing the shortened path as source, and\nthe destination URL:[[route]]\nsource = \"/spin\"\ndestination = \"https://github.com/fermyon/spin\"\n\n[[route]]\nsource = \"/hype\"\ndestination = \"https://www.fermyon.com/blog/how-to-think-about-wasm\"Whenever a request for https://<domain>/spin is sent, our component will\nredirect to https://github.com/fermyon/spin. Now that we have a basic\nunderstanding of how the component should behave, let's see how to implement it\nusing Spin.First, we start with undefined:/// A Spin HTTP component that redirects requests \n/// based on the router configuration.\n#[http_component]\nfn redirect(req: Request) -> Result<Response> {\n    let router = Router::default()?;\n    router.redirect(req)\n}All the component does is create a new router based on the default configuration,\nthen use it to redirect the request. Let's see how the router is defined:#[derive(Debug, Deserialize, Serialize)]\npub struct Route {\n    pub source: String,\n    pub destination: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Router {\n    #[serde(rename = \"route\")]\n    pub routes: Vec<Route>,\n}The Router structure is a Rust representation of the TOML configuration above.pub fn redirect(self, req: Request) -> Result<Response> {\n    // read the request path from the `spin-path-info` header\n    let path_info = req\n        .headers()\n        .get(\"spin-path-info\")\n        .expect(\"cannot get path info from request headers\");\n    // if the path is not present in the router configuration,\n    // return 404 Not Found.\n    let route = match self.path(path_info.to_str()?) {\n        Some(r) => r,\n        None => return not_found(),\n    };\n    // otherwise, return the redirect to the destination\n    let res = http::Response::builder()\n        .status(http::StatusCode::PERMANENT_REDIRECT)\n        .header(http::header::LOCATION, route.destination)\n        .body(None)?;\n    Ok(res)\n}The redirect function is straightforward — it reads the request path from the\nspin-path-info header (make sure to read the undefined\nfor an overview of the HTTP headers present in Spin components), selects the\ncorresponding destination from the router configuration, then sends the\nHTTP redirect to the new location.At this point, we can build the module with cargo and run it with Spin:$ cargo build --target wasm32-wasi --release\n$ spin up --file spin.tomlAnd the component can now handle incoming requests:# based on the configuration file, a request\n# to /spin should be redirected\n$ curl -i localhost:3000/spin\nHTTP/1.1 308 Permanent Redirect\nlocation: https://github.com/fermyon/spin\ncontent-length: 0\n# based on the configuration file, a request\n# to /hype should be redirected\n$ curl -i localhost:3000/hype\nHTTP/1.1 308 Permanent Redirect\nlocation: https://www.fermyon.com/blog/how-to-think-about-wasm\ncontent-length: 0\n# /abc is not present in the router configuration,\n# so this returns a 404.\n$ curl -i localhost:3000/abc\nHTTP/1.1 404 Not Found\ncontent-length: 9\n\nNot FoundundefinedWe can now undefined (together\nwith router configuration file):$ spin bindle push --file spin.toml\npushed: url-shortener/1.0.0And now we can run the application directly from the registry:$ spin up --bindle url-shortener/1.0.0In this tutorial we built a simple URL shortener as a Spin component.\nIn the future we will expand this tutorial by storing the router configuration\nin a database supported by Spin, and potentially create another component that\ncan be used to add new routes to the configuration.","url":"/spin/url-shortener"}]