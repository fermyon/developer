[{"project":"bartholomew","title":"Bartholomew configuration","subheading":"","content":"undefined is a simple configuration format.\nBartholomew uses TOML for undefined as well as\nin the site configuration. In this chapter, we will focus on site configuration.Your site's config/ directory has one configuration file in it, called site.toml:title = \"Bartholomew\"\n# logo = \"URL to logo\"\nbase_url = \"http://localhost:3000\"\nabout = \"This site is generated with Bartholomew, the Spin micro-CMS. And this message is in site.toml.\"\ntheme = \"fermyon\"\nindex_site_pages = [\"main\"]\n\n[extra]\ncopyright = \"The Site Authors\"\ngithub = \"https://github.com/technosophos/bartholomew\"\ntwitter = \"https://twitter.com/technosophos\"You can think of this as \"header for your site\".It has a few pre-defined fields:undefinedundefinedundefinedundefinedundefinedundefinedYou can define your own fields in the [extra] section. Anything in [extra] is not\nused by the system itself. But it's a useful way to pass information from one central\nplace to all of your templates. For example, a template can access the copyright value\nusing {{site.info.extra.copyright}}.Let's take a look at how you can configure your site to use undefined.","url":"/bartholomew/configuration"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"","content":"To contribute to the Bartholomew project, please follow these steps.undefinedThe first step in contributing to Bartholomew is to create a fork of the GitHub repository. Let's get started.","url":"/bartholomew/contributing-bartholomew"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Create a Fork of the Bartholomew GitHub Repository","content":"undefinedEnsure that you are forking Bartholomew to undefined; where you have full editing privileges.","url":"/bartholomew/contributing-bartholomew.md#create-a-fork-of-the-bartholomew-github-repository"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Clone the Fork","content":"Go ahead and clone the new fork that you just created (the one which resides in your own GitHub account).undefinedCloning is performed using the following commands:# Change into home directory\ncd ~\n# Clone\ngit clone git@github.com:yourusername/bartholomew.gitChange into the new Bartholomew directory (repo):cd ~/bartholomew","url":"/bartholomew/contributing-bartholomew.md#clone-the-fork"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Building the Bartholomew Server","content":"Rust and the wasm32-wasi target are prerequisites that are required to build Bartholomew from the source code. Please see the next section if you require these prerequisites on your system.","url":"/bartholomew/contributing-bartholomew.md#building-the-bartholomew-server"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Prerequisites (Rust, wasm32-wasi and wasm-opt)","content":"You will need Rust installed.\nYou also need to install and add wasm32-wasi target once you have Rust installed.\nLastly, for prerequisites, you will need wasm-opt.undefinedInstalling Rust via the<a href=\"https://www.rust-lang.org/tools/install\" target=\"_blank\"> official Rust installation tool</a> is recommended.undefinedInstalling the <a href=\"https://doc.rust-lang.org/stable/nightly-rustc/rustc_target/spec/wasm32_wasi/index.html\" target=\"_blank\">wasm32-wasi</a> target is done using the following commands:rustup target install wasm32-wasi\nrustup target add wasm32-wasiIf you would like more details about the WebAssembly System Interface (WASI) there is an <a href=\"https://wasi.dev/\" target=\"_blank\">official specification</a> and an <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-intro.md\" target=\"_blank\">'intro' document</a> available.undefinedPlease go to the undefined of binaryen and download the compressed package that suits your specific operating system. Unpack the compressed file to a location of your choice. We are just using ~/ (home directory) for presentation purposes. For example:# Download binaryen tar.gz file to home directory first\n# Then change into home directory\ncd ~\n# Unpack .tar.gz\ntar -zxvf binaryen-version_109-arm64-macos.tar.gzOnce unpacked, ensure that binaryen's bin folder is in your path. For example, open your .zshrc or .bash_profile file (depending on your OS) for editing:# macOS example\nvi ~/.zshrc\n# Ubuntu Linux example\nvi ~/.bash_profileThen add the path to binaryen's bin folder to the last line of your file like this:export PATH=\"${HOME}/binaryen-version_109/bin:${PATH}\"Run whichever file you just edited. For example:# macOS example\n. ~/.zshrc\n# Ubuntu Linux example\n. ~/.bash_profileYou can check this has worked by echoing your path. For example:echo $PATHThe output from the above command will be similar to the following:~/binaryen-version_109/bin:/other/things/in/your/pathOnce the prerequisites are satisfied, you can go ahead and build Bartholomew:make buildThe make build command does a cargo build --target wasm32-wasi --release.undefinedThe above make build command creates a bartholomew.wasm file in the bartholomew/target/wasm32-wasi/release directory. You will need to copy that file into Bartholomew's modules/` directory for Spin to run Bartholomew.","url":"/bartholomew/contributing-bartholomew.md#prerequisites-rust-wasm32wasi-and-wasmopt"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Building the Bartholomew Command Line Interface (CLI) Tool","content":"The Bartholomew Command Line Interface (CLI) Tool is called bart. this CLI is different from what we just built above. The CLI is a useful tool that can be used to create a new blog post using a single-line command and more. Installing the Bartholomew CLI is worth it, so take a few seconds to make it happen.To build the Bartholomew CLI from source, perform the following commands:cd ~/bartholomew\nmake bartOnce built, you will find the very useful bart CLI executable in the ~/bartholomew/target/release directory.For more information about how to use the CLI, please type ~/bartholomew/target/release/bart --help, as shown below:~/bartholomew/target/release/bart --help    \nbart 0.1.0\nThe Bartholomew CLI\n\nUSAGE:\n    bart <SUBCOMMAND>\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nSUBCOMMANDS:\n    calendar    Print the content calendar for a Bartholomew website\n    check       Check content and identify errors or warnings\n    help        Prints this message or the help of the given subcommand(s)\n    new         Create a new postThe Bartholomew CLI also has some other great features i.e. the bart command can automatically check the content (i.e. parse your web page and/or blog post markdown files) and identify & report any issues. See the example of test output below.","url":"/bartholomew/contributing-bartholomew.md#building-the-bartholomew-command-line-interface-cli-tool"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Check Web Pages","content":"# Note the \"bart check\" command is being run, as an absolute path, from where we installed bartholomew from source (notice how we are passing in the \"content/*\" as a parameter to bart's \"check\" subcommand).\n~/bartholomew/target/release/bart check content/*The output from the above command will be similar to the following (depending on the web pages on your system):✅ content/about.md","url":"/bartholomew/contributing-bartholomew.md#check-web-pages"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Check Blog Posts","content":"# Note the \"bart check\" command is still being run, as an absolute path, from where we installed bartholomew from source (notice how we are passing in the \"blog/*\" as a parameter to bart's \"check\" subcommand this time around).\n~/bartholomew/target/release/bart check blog/*The output from the above command will be similar to the following (depending on the blog posts on your system):✅ content/blog/2022-02-08-hello-world.md\n✅ content/blog/why-and-how-wasm-cms-bartholomew.md","url":"/bartholomew/contributing-bartholomew.md#check-blog-posts"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"The Relationship Between Bartholomew and Spin","content":"To run Bartholomew, you will need a Spin-capable runtime.For Spin, follow undefined which details how to either:undefinedundefinedundefined","url":"/bartholomew/contributing-bartholomew.md#the-relationship-between-bartholomew-and-spin"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"The Relationship Between Bartholomew and the Spin Fileserver","content":"Bartholomew uses an external file server called undefined. This file server facilitates the presentation of files to the end users. For example, whilst the web page contents (HTML) are generated dynamically upon request, image elements in that HTML page source can point to images that are stored on the host server. The Spin file server ensures that these static images are correctly served to the client's web browser (as per the HTML's requirements.)Please build the spin-fileserver and then copy the resulting spin_static_fs.wasm file into Bartholomew's modules/ directory. This will ensure that you are running the latest release of the spin-fileserver.","url":"/bartholomew/contributing-bartholomew.md#the-relationship-between-bartholomew-and-the-spin-fileserver"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Create a New Branch","content":"Create a new branch that will house all of your changes for this specific contribution:git checkout -b my_new_branch","url":"/bartholomew/contributing-bartholomew.md#create-a-new-branch"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Create a New Remote","content":"Create a new remote for the upstream (a pointer to the original repository to which you are contributing):git remote add upstream https://github.com/fermyon/bartholomew","url":"/bartholomew/contributing-bartholomew.md#create-a-new-remote"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Modify Your Code","content":"Now is the time to make any changes to the code base and/or the documentation. This can include anything from updating files, creating new folders/files, writing documentation, writing tests, adding images and so much more.","url":"/bartholomew/contributing-bartholomew.md#modify-your-code"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Collaborating When Submitting Your Code And/or Content","content":"Keep in mind that the developers who potentially merge your changes into the original repository will thoroughly check all of your work. There may be some back and forth as the final touches are added and your contribution is polished in readiness to deploy. Fermyon proudly hosts a undefined document. Taking a few minutes of your valuable time to view this page would be greatly appreciated.Also, when contributing, please ensure that you notice any unwritten conventions which are obvious. For example, if an entire folder of images is named using underscores i.e. image_1.png, image_2.png ensure that you don't upload an image with a different format like Image3.png or image-4.png. The same applies to written code, keep an eye out for conventions such as camel case and so forth when creating new variables. This will surely make the collaboration process smoother and faster.","url":"/bartholomew/contributing-bartholomew.md#collaborating-when-submitting-your-code-andor-content"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Testing Your Changes","content":"Once you have made the required changes, test the code to make sure all the test cases are satisfied. You can test the code using the following command in the top-level directory, under which your changes exist.make test","url":"/bartholomew/contributing-bartholomew.md#testing-your-changes"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Viewing Your Changes","content":"If you made changes that will have a visual effect when Bartholomew has hosted i.e. changes to page layout and so forth, you can run the Bartholomew instance and view your changes on localhost. When you navigate to http://localhost:3000, you should see the website running.Running Bartholomew using Spin:$ spin upRunning Bartholomew using make:$ make serveFor convenience, make serve builds the code, and then runs spin up.undefined","url":"/bartholomew/contributing-bartholomew.md#viewing-your-changes"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Preview Mode","content":"If you have created changes to a web page or a blog post on a Bartholomew instance, you can preview your changes. For example, if you are contributing to the official documentation and want to render the site locally to preview your changes, you can navigate to the bartholomew/docs directory and run the site in preview mode, as shown below.undefinedundefinedundefinedTo view unpublished content i.e. if you are creating a new file, turn on PREVIEW_MODE.Spin:$ spin up -e PREVIEW_MODE=1Make:$ PREVIEW_MODE=1 make serve","url":"/bartholomew/contributing-bartholomew.md#preview-mode"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"The Page Cache","content":"Unless the environment variable -e DISABLE_CACHE=1 is set, the first load of a site will create a cache of page metadata in config/_cache.json. This is an optimization to reduce the number of file IO operations Bartholomew needs to make. If you are actively developing content, we suggest setting DISABLE_CACHE=1. By default, the Makefile's make serve target disables the cache, as make serve is assumed to be used only for developers.","url":"/bartholomew/contributing-bartholomew.md#the-page-cache"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Adding, Committing and Pushing via Github","content":"Once you are satisfied with your contribution, please ensure that your GitHub installation is configured sufficiently so that you can --signoff as part of the git commit command. For example, please ensure that the user.name and user.email are configured in your terminal. You can check if these are set by typing git config --list.If you need to set these values please use the following commands:git config user.name \"yourname\"\ngit config user.email \"youremail@somemail.com\"More information can be found at this GitHub documentation page called undefined.","url":"/bartholomew/contributing-bartholomew.md#adding-committing-and-pushing-via-github"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Add Changes","content":"Move to a top-level directory, under which your changes exist i.e. cd ~/bartholomew.Add your changes using the following command:git add .","url":"/bartholomew/contributing-bartholomew.md#add-changes"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Commit Changes","content":"Type the following commit command to ensure that you sign off (--signoff), sign the data (-S) - recommended, and also leave a short message (-m):git commit -S --signoff -m \"Updating documentation about testing process\"undefined","url":"/bartholomew/contributing-bartholomew.md#commit-changes"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Push Changes","content":"At this stage, it is a good idea to just quickly check what GitHub thinks the origin is. For example, if we type git remote -v we can see that the origin is our repo; which we a) forked the original repo into and b) which we then cloned to our local disk so that we could edit:git remote -v\norigin\tgit@github.com:yourusername/bartholomew.git (fetch)\norigin\tgit@github.com:yourusername/bartholomew.git (push)Next, we push the changes (explicitly mentioning the origin and also the new branch which we created in one of the earlier steps in this tutorial):git push -u origin my_new_branch","url":"/bartholomew/contributing-bartholomew.md#push-changes"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Create a Pull Request (PR)","content":"If you return to your GitHub repository in your browser, you will notice that a PR has automatically been generated for you.undefinedClicking on the green \"Compare and pull request\" button will allow you to add a title and description as part of the PR. You can also add any information in the textbox provided below the title. For example, screen captures and/or code/console/terminal snippets of your contribution working correctly and/or tests passing etc.There is one final step (another green button to push) ... Create Pull Request!Once you have finished creating your PR, please keep an eye on the PR; answering any questions as part of the collaboration process.","url":"/bartholomew/contributing-bartholomew.md#create-a-pull-request-pr"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Merged","content":"The final stage of a successful contribution will be a notification that the PR has been merged.undefined","url":"/bartholomew/contributing-bartholomew.md#merged"},{"project":"bartholomew","title":"Contributing to Bartholomew","subheading":"Thank You","content":"At this point, you have performed a significant amount of work which is greatly appreciated.Thank you for contributing!Please keep in touch and contribute again in the future. We would love to see you back here.","url":"/bartholomew/contributing-bartholomew.md#thank-you"},{"project":"bartholomew","title":"Introducing Bartholomew","subheading":"","content":"Bartholomew is a simple CMS-like (Content Management System) tool for managing a\nwebsite. It is compiled to WebAssembly, and can run in any undefined\nenvironment.At a glance, with Bartholomew you can:undefinedundefinedundefinedundefined","url":"/bartholomew/index"},{"project":"bartholomew","title":"Introducing Bartholomew","subheading":"Overview","content":"Bartholomew is built using a Functions-as-a-Service (FaaS) model, similar to\none you might find in AWS Lambda or Azure Functions. The CMS is only running when\nit needs to handle incoming requests, reducing the load on the servers\nrunning it.Bartholomew is a undefined component, and\nwebsites built with Bartholomew are Spin applications that can run in any\nenvironment that is capable of running Spin. At Fermyon, we run all of our\nwebsites using Bartholomew and Spin, on our undefined.In the next page, we will undefined.","url":"/bartholomew/index.md#overview"},{"project":"bartholomew","title":"Markdown guide","subheading":"","content":"To write content for a Bartholomew website, there are two steps:undefinedundefined","url":"/bartholomew/markdown"},{"project":"bartholomew","title":"Markdown guide","subheading":"Creating a New File","content":"To create a new page, run the bart new post command, with the path to where\nthe file should be created as the first argument (it should be in the root or in\na subdirectory of content/) and the file name as the second argument, making\nsure the file has the .md extension.\nFor example, if the new post was created in content/foo.md, this file will be\nrendered by Bartholomew as <base_url>/foo.undefinedBartholomew supports Markdown via the undefined library.","url":"/bartholomew/markdown.md#creating-a-new-file"},{"project":"bartholomew","title":"Markdown guide","subheading":"Editing the Page Head","content":"The first part of any Bartholomew document is the undefined. You can think of every piece of content as having a undefined and a undefined. (Shoulders, knees, and toes will be added in a forthcoming release.)The head is formatted as TOML, which for the most part is just names and values.Here is an example head for a blog post:title = \"A New Article\"\ndescription = \"This article is really interesting and full of useful material.\"\ndate = \"2021-12-23T15:05:19Z\"\ntemplate = \"post\"\ntags = [\"news\", \"article\"]\nenable_shortcodes = false\n\n[extra]\nauthor = \"Matt Butcher\"\nauthor_page = \"/author/butcher\"\n---Here is an example head for a web page:title = \"The title\"\ndescription = \"A short description\"\ndate = \"2021-12-23T23:20:57Z\"\ntemplate = \"main\" # The default is `main`, which correlates to `templates/main.hbs`\n\n[extra]\nkey = \"your custom name value pairs go hear, but values MUST be strings\"\n---","url":"/bartholomew/markdown.md#editing-the-page-head"},{"project":"bartholomew","title":"Markdown guide","subheading":"Markdown Body","content":"Markdown support includes all the usual stuff plus fenced codeblocks. Image links are\nsupported, but you need to use the external undefined\nlibrary to display the images. If you are using your deployment of Spin and Bartholomew, you can undefined from source.The last line of the example above is very important. The --- tells Bartholomew that the head is done, and the body is coming up.Every head must have a title. It is undefined recommended that it also have a date as well because dates are tied to some of Bartholomew's features. There are several other defined fields. When you want to add your own fields, put them after the [extra] marker.\nYou can add your own fields as name/value pairs. Just make sure you quote these string values.The following fields are defined for Bartholomew:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedAfter the ---, you can write the content's body in Markdown.","url":"/bartholomew/markdown.md#markdown-body"},{"project":"bartholomew","title":"Markdown guide","subheading":"Writing a Markdown Body","content":"undefined When writing a blog post with more than one paragraph, the <!-- break --> syntax must be placed between the end of the first paragraph and the beginning of the second paragraph. The paragraph content above the <!-- break --> will be shown in the HTML as having a slightly larger font size (relative to the rest of the page's content). The first paragraph will also appear when viewing the list of all blog posts (from the blog index page). Here is an example:This is my first paragraph which introduces my blog post.\n\n<!-- break -->\n\nThis is the second paragraph, note the line breaks used in this code block example.\n\nThis is the third paragraph, it is treated exactly like the second paragraph.As you would have already seen, all documents in Bartholomew are written in Markdown.undefined is a simple text format designed to make it easy (and very fast) to write the text that can then be converted into HTML.For example, the Markdown *hello* is transformed into undefined. And the Markdown [example](http://example.com) is transformed into the link undefined.To make a header, you just use hash marks: # for a title, ## for a sub-header, and so on. Bullet lists are just plain text hyphen or asterisk lists.For example:- This\n- Is\n- A\n- ListThe above produces:undefinedundefinedundefinedundefinedMake text italic by wrapping it in underscores: _hello_ becomes undefined. And use double asterisks for bold. **goodbye** becomes undefined.There are other Markdown goodies, but one you should know is how to make a link. Links are built by putting text in square brackets, and the URL in parentheses.Say [Hello](http://example.com)Say undefined.If you want to reference an image, just add ! in front of the square bracket. In that situation, the text in the square brackets becomes the image description.","url":"/bartholomew/markdown.md#writing-a-markdown-body"},{"project":"bartholomew","title":"Markdown guide","subheading":"Why Is Markdown the Only Supported Format?","content":"Some static site generators allow you to use other formats like asciidoc. Bartholomew only supports Markdown. The reason for this is pragmatic: We are trying to keep the binary size as small as we can to make Bartholomew faster.","url":"/bartholomew/markdown.md#why-is-markdown-the-only-supported-format"},{"project":"bartholomew","title":"Markdown guide","subheading":"Can I Embed HTML?","content":"Yes, you can embed HTML tags inside of your Markdown.Bartholomew supports reusable content using snippets in the form of shortcodes, so let's take a look at the undefined support in Bartholomew.Lastly, let's take a look at how templating is used in Bartholomew.","url":"/bartholomew/markdown.md#can-i-embed-html"},{"project":"bartholomew","title":"Markdown guide","subheading":"Templates","content":"Bartholomew uses a undefined.\nThe template syntax is described in the undefined.Every file in the templates/ directory will be compiled into a template. The file is then accessible by its relative name, minus the extension. For example. templates/main.hbs will be accessible as main.Note that Bartholomew undefined to find a template named main. This template is used as a default when the content head does not contain a template directive. It is also used when an error occurs. You must have a main template.","url":"/bartholomew/markdown.md#templates"},{"project":"bartholomew","title":"Markdown guide","subheading":"Accessing The Head (Front Matter) and the Body","content":"The head is available in the template using the {{ page.head }} object. For example, to print the title, use {{ page.head.title }}. To access your custom [extra] field named foo, use {{ page.head.extra.foo }}. The body is injected into the template and converted to HTML. That is, the template does not have access to the Markdown version of the document.To print the HTML body without having the output escaped, use {{{ page.body }}} (note the triple curly braces).","url":"/bartholomew/markdown.md#accessing-the-head-front-matter-and-the-body"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"","content":"This is a quickstart example of using Spin to deploy a Bartholomew CMS instance, locally on your machine. In this quickstart session, we use a Bartholomew site template which contains some pre-built parts (for your convenience). If you would like to build all of the parts separately from source (Spin, Bartholomew, File Server), please see the undefined which dives a lot deeper than this quickstart example.","url":"/bartholomew/quickstart"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Getting the  spin  Binary","content":"For Spin, follow undefined which details how to either:undefinedundefinedundefined","url":"/bartholomew/quickstart.md#getting-the-spin-binary"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Templates","content":"This quickstart method uses a Bartholomew site template. So while we do require spin (as per the details above) everything else we need (to launch our Bartholomew CMS website) is packaged up in the Bartholomew site template. Including the bartholomew.wasm and the spin_static_fs.wasm files which take care of Bartholomew's business logic and undefined needs, respectively. We will start working with the template in the next section.","url":"/bartholomew/quickstart.md#templates"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Use the Bartholomew Site Template","content":"We can now generate a new repository with the same directory and file structure as the aforementioned Bartholomew site template. Simply visit undefined on undefined. Then click on the green Use this template button and follow the prompts. This will create a new repository in your GitHub account.Here are some additional details about undefined if you are interested.undefined","url":"/bartholomew/quickstart.md#use-the-bartholomew-site-template"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Fetch Your Site","content":"Clone the repository which you created in the previous step:$ git clone <your-github-account> <your-repo-name>Navigate into your newly cloned repository:$ cd <your-repo-name>","url":"/bartholomew/quickstart.md#fetch-your-site"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Spin Up Your Site","content":"Issue the following spin up command to launch your site on localhost:$ spin up --follow-allWhen you navigate to http://localhost:3000, you should see the website running.","url":"/bartholomew/quickstart.md#spin-up-your-site"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Creating Your Content","content":"Creating content is made easy with the Bartholomew Command Line Interface (CLI) tool. The Bartholomew CLI can create new blog posts in a single command and also validate the content (Markdown files) that you write. Let's go ahead and install the Bartholomew CLI.","url":"/bartholomew/quickstart.md#creating-your-content"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Bartholomew CLI","content":"For the bart CLI, there are two options:undefinedundefined$ git clone https://github.com/fermyon/bartholomew.git\n$ cd bartholomew\n$ make bart","url":"/bartholomew/quickstart.md#bartholomew-cli"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Create Your First Blog Post","content":"You are now ready to start adding content to your new website. You will recall that we installed the bart CLI in a previous step. We can use this CLI to create a new blog post page.Note below how we:undefinedundefinedundefinedFeel free to change these values when you run the command on your system:$ mkdir content/blog\n$ bart new post content/blog protons.md --author \"Enrico Fermi\" --template \"blog\" --title \"On the Recombination of Neutrons and Protons\"The output from the above command will look similar to the following:Wrote new post in file content/blog/protons.md","url":"/bartholomew/quickstart.md#create-your-first-blog-post"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Validate Your Content","content":"If you would like to check the validity of your content, you can use the following bart check command. Notice how we specify the location of the content we want to check. In this case, we are checking all of the Markdown files in the blog directory:bart check content/blog/*If your syntax in the .md file is undefined, you will receive an output similar to the following. Otherwise, you will receive an informative error message and a cross:✅ content/blog/protons.md","url":"/bartholomew/quickstart.md#validate-your-content"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Validating Content With Shortcodes","content":"If some of your documents uses shortcodes, then directory from which the shortcodes must be loaded needs to be specified using the --shortcodes flag.bart check content/blog/* --shortcode ./shortcodes","url":"/bartholomew/quickstart.md#validating-content-with-shortcodes"},{"project":"bartholomew","title":"Taking Bartholomew for a spin","subheading":"Viewing Your Changes","content":"Running the spin up command from above (again) will render the post content at http://localhost:3000/blog/protonsundefinedNext, let's explore how to undefined.","url":"/bartholomew/quickstart.md#viewing-your-changes"},{"project":"bartholomew","title":"Scripting guide","subheading":"","content":"Sometimes you want to do something special in your templates. Perhaps it's some\nfancy formatting or iterating through some content and finding specific information.\nBartholomew provides the Rhai scripting language for this.undefined is a simple scripting language that has many stylistic similarities to\nRust, Go, and Python. The integration with Bartholomew is easy to work with.","url":"/bartholomew/scripting"},{"project":"bartholomew","title":"Scripting guide","subheading":"The Basic","content":"undefinedundefinedundefinedundefinedFor example, let's take a look at the scripts/echo.rhai script. Note that because\nit is named echo.rhai, it will be accessible inside of templates as echo (just remove\nthe .rhai).let msg = params[0];\n\n\"hello \" + msg;On the first line, we accept the first parameter from the template (params[0]) and\nassign it to the variable named msg.undefinedThe second line returns the string \"hello\"  concatenated with the value of msg.\nThat's all there is to a simple Rhai script.From a template, we can then use this script like this:{{ echo \"world\" }}When we run the template, we will see:hello world","url":"/bartholomew/scripting.md#the-basic"},{"project":"bartholomew","title":"Scripting guide","subheading":"A More Complicated Example.","content":"Let's take a look at scripts/blogs.rhai, which is called in a template as blogs.\nThis script makes a list of all of the blog posts for the site.// Param 1 should be `site.pages`\nlet pages = params[0];\n\n// Loop through them and return all of the page objects that are in\n// the blog path. We want the results in an array to preserve ordering.\nlet blog_pages = [];\n\n// Get each blog post, assigning it to {path: object}.\nlet keys = pages.keys();\nfor item in keys {\n    if item.index_of(\"/content/blog/\") == 0 {\n        // Remove /content and .md\n        let path = item.sub_string(8);\n        path = path.sub_string(0, path.index_of(\".md\"));\n\n        // Build an object that has `uri` and `page` keys.\n        blog_pages.push(#{\n            uri: path,\n            page: pages[item],\n        });\n        //blog_pages[path] = pages[item];\n    }\n   \n}\n// Newest to oldest, assuming you put the date in the URI\nblog_pages.reverse();\n\n// Return the array of blog pages\nblog_pagesAgain note that this is one long procedural script that starts by fetching a parameter\nfrom the params array, and ends by sending back the output of the last line, blog_pages.The script returns a more complex data type, so let's see how this one is used in the\ncontent_sidebar.hbs template:<div class=\"p-4\">\n    <h4 class=\"fst-italic\">Recent Posts</h4>\n    <ol class=\"list-unstyled mb-0\">\n        {{#each (blogs site.pages)}}<li><a href=\"{{uri}}\">{{page.head.title}}</a></li>\n        {{/each }}\n    </ol>\n</div>The code {{#each (blogs site.pages)}} calls blogs with param[0] set to site.pages.\nThen the each loops through the results.The value of this within the #each loop is the object that we created in Rhai:#{\n    uri: \"/some/path\"\n    page: #{head: #{...}, body: \"some html\" }\n}So <a href=\"{{uri}}\">{{page.head.title}}</a> will use this.uri, and the title\nfrom the page object.That's how you can use Rhai to add custom formatters to the site.No site would be complete without quality content, so let's take a look at the undefined which will help you create and format your awesome content.","url":"/bartholomew/scripting.md#a-more-complicated-example"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"","content":"","url":"/bartholomew/seo"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Google Verification Using Bartholomew","content":"Your Bartholomew implementation can be <a href=\"https://support.google.com/webmasters/answer/9008080?hl=en\" target=\"_blank\">officially verified with Google</a>. This is an important first step because the verification process provides you with access to the <a href=\"https://g.co/kgs/UcBemE\" target=\"_blank\">Google Search Console</a>. The Google Search Console (formerly Google Webmaster Tools) allows webmasters to check indexing status, search queries, crawling errors and also optimize visibility of their site.Let's take a look at how the verification process is accomplished using Bartholomew.","url":"/bartholomew/seo.md#google-verification-using-bartholomew"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Markdown","content":"The first step in the Google verification process is where Google provides you (the owner) of the specific website with a specially named file i.e. abcdefg.html. Google now wants you, the owner, to make this file available on your site, so that Google can fetch it as proof that you are the site's owner which has access control to the site. This is a really simple task. First you create a Markdown file (in Bartholomew's content directory) called abcdefg.md (the name of this file just has to match the name of the file which Google provided). undefined.Bartholomew uses templating so you just have to be explicit about a couple of things inside that new .md file. Specifically,  Make sure that there is a template name (we will create the template next) and that the content type (of this file) is rendered as text/html. This is shown in the source code of the new abcdefg.md file below.title = \"Google Verification\"\ndescription = \"Google verification file which provides us with access to Google Search Console\"\ndate = \"2022-07-11T00:01:01Z\"\ntemplate = \"google_verification\"\ncontent_type = \"text/html\"\n---\n\nThis is the abcdefg.html file that Google can see openly at the root of the website.","url":"/bartholomew/seo.md#markdown"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Template","content":"Bartholomew uses <a href=\"https://handlebarsjs.com/\" target=\"_blank\">Handlebars</a> templating. Therefore the next step is for you to go ahead and create a new google_verification.hbs file in Bartholomew's template directory. Once the file is created, populate it with the content which Google requested, below is just an example.{{! \nFor info on what can be placed here, see https://support.google.com/webmasters/answer/9008080#html_verification&zippy=%2Chtml-file-upload\n}}\ngoogle-site-verification: abcdefg.htmlAt this point the verification button in the Google dashboard can be pressed; Google fetches the file from your site and the verification is complete!","url":"/bartholomew/seo.md#template"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Search Engine Optimization (SEO) Using Bartholomew","content":"In addition to just verifying the ownership of a site/domain, You can see that there are <a href=\"https://developers.google.com/search/docs/beginner/seo-starter-guide\" target=\"_blank\">specific SEO requirements</a> in relation to how the <a href=\"https://g.co/kgs/p6qtQs\" target=\"_blank\">Googlebot</a> indexes content. Googlebot is the web crawler software used by Google.Let's take a look at how the SEO compliance (i.e. sitemap and robots.txt) is accomplished using Bartholomew.","url":"/bartholomew/seo.md#search-engine-optimization-seo-using-bartholomew"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Generating a Sitemap","content":"Google <a href=\"https://developers.google.com/search/docs/advanced/sitemaps/build-sitemap\" target=\"_blank\">expects the standard sitemap protocol to be implemented</a>. Thankfully, Bartholomew automatically builds a sitemap file based on the entire set of content in the CMS. The heavy lifting of the work is performed using the <a href=\"https://rhai.rs/\" target=\"_blank\">Rhai</a> scripting language. Here is an example of the sitemap.rhai file that you would store in Bartholomew's scripts directory.// This function lists all of the posts, filtering a few.\n//\n// It returns an array of objects of the form:\n//  [\n//    #{ uri: \"path/to/page\", page: PageObject }\n// ]\n\n// These should be skipped.\nlet disallow = [\n    \"/sitemap\", // Don't list self.\n    // \"/tag\", // tag will list all of the tags on a site. If you prefer this not be indexed, uncomment this line.\n    \"/index\", // This is a duplicate of /\n    \"/atom\",\n    \"/robots\",\n];\n\n// Param 1 should be `site.pages`\nlet pages = params[0];\n\nlet site_pages = [];\nlet keys = pages.keys();\nfor item in keys {\n    let path = item.sub_string(8);\n    let page = pages[item];\n\n    path = path.sub_string(0, path.index_of(\".md\"));\n    if !disallow.contains(path) {\n        site_pages.push(#{\n            uri: path,\n            page: page,\n            priority: prioritize(path),\n            frequency: \"weekly\",\n        });\n    }\n   \n}\n\n// This is an example of how we could prioritize based on information about the page.\n//\n// Specifically, here we use path to boost docs and blogs while reducing the priority\n// of author pages and features.\nfn prioritize(path) {\n    let boost = [\"/blog/\", \"/docs/\"];\n    for sub in boost {\n        if path.contains(sub) {\n            return 0.8\n        }\n    }\n    let nerf = [\"/author/\", \"/features/\"];\n    for sub in nerf {\n        if path.contains(sub) {\n            return 0.3\n        }\n    }\n    0.5\n}\n\n// Return the blogs sorted newest to oldest\nfn sort_by_date(a, b) {\n    if a.page.head.date < b.page.head.date {\n        1\n    } else {\n        -1\n    }\n}\n\n// Sort by the value of the page date.\nsite_pages.sort(Fn(\"sort_by_date\"));\n\nsite_pagesWhen Bartholomew sees an incoming request for the sitemap.xml URL, it will look inside the scripts directory for a Rhai file named sitemap.rhai (as shown above) and execute the script on demand.In conjunction to the above scripting, the aforementioned <a href=\"https://handlebarsjs.com/\" target=\"_blank\">Handlebars</a> templating assists in this work being performed dynamically (using variables common between the script and the template); as shown in the sitemap.hbs file's contents below.<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n{{!\n    For sitemap.xml, see https://www.sitemaps.org/protocol.html\n    For date/time format, see https://www.w3.org/TR/NOTE-datetime\n}}\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n    <url>\n        <loc>{{site.info.base_url}}/</loc>\n        <changefreq>daily</changefreq>\n        <priority>0.8</priority>\n    </url>\n    {{#each (sitemap site.pages) }}\n    <url>\n        <loc>{{../site.info.base_url}}{{uri}}</loc>\n        {{#if page.head.date }}<lastmod>{{date_format \"%Y-%m-%dT%H:%M:%SZ\" page.head.date}}</lastmod>{{/if}}\n        <changefreq>{{frequency}}</changefreq>\n        <priority>{{priority}}</priority>\n    </url>\n    {{/each}}\n</urlset>undefinedFrom a display point of view we again just use Markdown (create a sitemap.md file in the site's content directory, correctly reference the name of the template (sitemap) and then ensure that the content type is set to text/xml). The above process will generate an XML sitemap called sitemap.xml at the root of the site. Perfect!title = \"Sitemap XML file\"\ndescription = \"This is the sitemap.xml file\"\ndate = \"2021-12-29T22:36:33Z\"\ntemplate = \"sitemap\"\ncontent_type = \"text/xml\"\n---\n\nThis is the autogenerated sitemap. Note that the suffix .xml is replaced with .md by Bartholomew.","url":"/bartholomew/seo.md#generating-a-sitemap"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Creating a Robots File","content":"You can actually control the Googlebot and tell it which files it may access on the site. This is done via the use of <a href=\"https://developers.google.com/search/docs/advanced/robots/create-robots-txt\" target=\"_blank\">a robots.txt file</a>.Similarly to the process above, you create a robots.md Markdown file in the content directory and also a robots.hbs in the template directory. These are shown below (in that order).title = \"Robots\"\ndescription = \"This is the robots.txt file\"\ndate = \"2021-12-30T03:17:26Z\"\ntemplate = \"robots\"\ncontent_type = \"text/plain\"\n---\n\nThis is the robots.txt file. It is autogenerated.{{! \nFor info on what can be placed here, see http://www.robotstxt.org/\nSee also: https://developers.google.com/search/docs/advanced/robots/intro\n}}\nUser-agent: *\nSitemap: {{site.info.base_url}}/sitemap.xml\nDisallow: /index","url":"/bartholomew/seo.md#creating-a-robots-file"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Google Search Console","content":"The above steps of a) verifying and b) complying to the SEO requirements will give you great control over what is indexed by the Googlebot, and other Web Crawlers also. From a Google Search Console perspective specifically, you can now enjoy specific features and benefits such as on-demand page indexing i.e. allowing Google to go ahead and index specific content (like a new blog post) and much more.","url":"/bartholomew/seo.md#google-search-console"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Google Search Analytics","content":"<a href=\"https://g.co/kgs/xZqj9L\" target=\"_blank\">Google Analytics</a> tracks and reports web site traffic. Showing not only where users are visiting from but how long they are staying and which pages they are reading and so forth. Once Google Analytics is configured you can even see how many users are on the site in real time. It is recommended that Google Analytics be used in conjunction with the above SEO.","url":"/bartholomew/seo.md#google-search-analytics"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Rich Results","content":"Implementing rich results will make your listings stand out from other listings. Events, job listings, COVID-19 announcements and recipes all qualify to use rich results (a structured data markup approach to content). Whilst rich results can make your content more visually appealing, implementing rich results can also help search engines to crawl and rank your content which may result in higher rankings.","url":"/bartholomew/seo.md#rich-results"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Structured Data","content":"Rich results are created using structured data inside your content. For example, <a href=\"https://www.w3.org/TR/json-ld11/\" target=\"_blank\">JSON-LD</a>, a JSON-based serialization for linked data.","url":"/bartholomew/seo.md#structured-data"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Video","content":"Let's go ahead and create a JSON-LD code snippet for a video. In this case, we go straight to <a href=\"https://developers.google.com/search/docs/advanced/structured-data/video\" target=\"_blank\">Google Search Console Documentation</a>, specifically the <a href=\"https://developers.google.com/search/docs/advanced/structured-data/video#video-object\" target=\"_blank\">JSON-LD Video Object</a> section and read about the properties i.e. name, description, contentUrl and so forth.undefinedThe following is an example of the JSON-LD that we used (in a particular blog post).undefined<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"VideoObject\",\n  \"name\": \"Fermyon Technologies, Inc. are attending Open Source Summit Europe 2022 Dublin Ireland.\",\n  \"description\": \"Fermyon Technologies, Inc. are thrilled to be joining the Open Source Summit Europe 2022 in Dublin Ireland; from September 13th to 16th.\",\n  \"thumbnailUrl\": \"https://www.fermyon.com/static/image/icon/mstile-150x150.png\",\n  \"uploadDate\": \"2022-08-13T08:00:00+08:00\",\n  \"duration\": \"PT0M24S\",\n  \"contentUrl\": \"https://youtu.be/UUzscJY6j2A\",\n  \"embedUrl\": \"https://www.youtube.com/embed/UUzscJY6j2A\"\n}\n</script>Once the rich results code is created we can simply embed it into our Bartholomew blog post's Markdown file.","url":"/bartholomew/seo.md#video"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Testing Rich Results","content":"When you are finished adding the rich media, you can go ahead and make sure that the content passes the \"rich results test\" undefined. This is a free online tool, which allows you to test both public URLs to content and also pasted-in HTML source code.Here is an example of how the code block from above is rendering in the site's HTML and therefore passing the rich results test.undefinedThe test only takes a couple of seconds, and as you can see we have successfully added rich result video data to our blog post.undefined","url":"/bartholomew/seo.md#testing-rich-results"},{"project":"bartholomew","title":"Search Engine Optimization (SEO)","subheading":"Monitoring Rich Results","content":"Once deployed be sure to check your rich result undefined. The status reports essentially monitor the health of your existing pages, on an ongoing basis. A great way to quickly check that everything is still working as time goes by.","url":"/bartholomew/seo.md#monitoring-rich-results"},{"project":"bartholomew","title":"Bartholomew shortcodes","subheading":"","content":"Shortcodes are simple reusable snippets can be used inside the markdown content.Bartholomew supports shortcodes simplify sharing content between different markdown files.","url":"/bartholomew/shortcodes"},{"project":"bartholomew","title":"Bartholomew shortcodes","subheading":"The Basic","content":"undefinedundefinedundefinedundefinedundefined","url":"/bartholomew/shortcodes.md#the-basic"},{"project":"bartholomew","title":"Bartholomew shortcodes","subheading":"Creating a Shortcode","content":"An example of a shortcode is in shortcodes/alert.rhai. The shortcode is available in the markdown file as alert just like for scripts.let type = params[0];\nlet msg = params[1];\n\n\nlet colors = #{\n  primary:`alert-primary`,\n  success:`alert-success`,\n  warning: `alert-warning`,\n  danger: `alert-danger`,\n};\n\nlet icons = #{\n  primary:`#info-fill`,\n  success:`#check-circle-fill`,\n  warning: `#exclamation-triangle-fill`,\n  danger: `#exclamation-triangle-fill`,\n};\n`<svg xmlns=\"http://www.w3.org/2000/svg\" style=\"display: none;\">\n  <symbol id=\"check-circle-fill\" fill=\"currentColor\" viewBox=\"0 0 16 16\">\n    <path d=\"M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 \n    0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75\n     0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z\"/>\n  </symbol>\n  <symbol id=\"info-fill\" fill=\"currentColor\" viewBox=\"0 0 16 16\">\n    <path d=\"M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm.93-9.412-1 4.705c-.07.34.029.533.304.533.194\n     0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703\n      0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381\n       2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2z\"/>\n  </symbol>\n  <symbol id=\"exclamation-triangle-fill\" fill=\"currentColor\" viewBox=\"0 0 16 16\">\n    <path d=\"M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98\n     1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35\n      3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z\"/>\n  </symbol>\n</svg>\n\n<div class=\"alert ` + colors[type] + ` d-flex align-items-center\" role=\"alert\">\n  <svg class=\"bi flex-shrink-0 me-2\" width=\"24\" height=\"24\" role=\"img\" aria-label=\"Info:\"><use xlink:href=\"` + icons[type]  +`\"/></svg>\n  <div>\n` + msg + `\n  </div>\n</div>\n`\n\n","url":"/bartholomew/shortcodes.md#creating-a-shortcode"},{"project":"bartholomew","title":"Bartholomew shortcodes","subheading":"Enabling Shortcodes","content":"To enable shortcodes support for a particular document, the value of enable_shortcodes = true must be set in the page head.title = \"A New Article\"\ndescription = \"This article is really interesting and full of useful material.\"\ndate = \"2021-12-23T15:05:19Z\"\n...\n...\nenable_shortcodes = true\n---","url":"/bartholomew/shortcodes.md#enabling-shortcodes"},{"project":"bartholomew","title":"Bartholomew shortcodes","subheading":"Using Shortcodes","content":"Now the shortcode can be used in the markdown file by calling it with the required arguments. For the alerts script, this is the type of alert and the message to be displayed.\\{{ alert \"warning\" \"Bartholomew is a work in progress\" }}Which renders as the following.{{ alert \"warning\" \"Bartholomew is a work in progress\" }}","url":"/bartholomew/shortcodes.md#using-shortcodes"},{"project":"bartholomew","title":"Bartholomew shortcodes","subheading":"Note While Using Shortcodes","content":"An important note to be considered while using shortcodes is that the \\{{ }} must be escaped if they are not meant to be executed. This is only required in the content files where shortcodes are enabled.To escape the code, the \\ is used like\n{{{{raw}}}}\n\\\\{{ alert \"warning\" \"Bartholomew is a work in progress\" }}\n{{{{/raw}}}}\nwhich will render \\{{ alert \"warning\" \"Bartholomew is a work in progress\" }} instead of running the shortcode.","url":"/bartholomew/shortcodes.md#note-while-using-shortcodes"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"","content":"In Bartholomew, layout is handled via templates. All templates are in the\ntemplates/ directory.undefined is a simple template language well-tuned to HTML.\nWhile the version of Handlebars used in Bartholomew is written in Rust, not JavaScript,\nit works almost identically.","url":"/bartholomew/templates"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"A Simple Template","content":"Here is a simple HTML template with Handlebars:<!DOCTYPE html>\n<html>\n\n<head>\n    <title>{{page.head.title}}</title>\n</head>\n\n<body>\n    {{{page.body}}}\n</body>\n\n</html>The above sets the HTML document's title to whatever is in page.head.title, and\nthen fills in the body with the value of page.body.Let's take a brief look at the page object to understand what is happening here.","url":"/bartholomew/templates.md#a-simple-template"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"The  page  Object","content":"In JSON, the page object looks like this:{\n    head: {\n        title: \"Some title\",\n        description: \"Some description\",\n        template: \"an optional template rather than using main.hbs\"\n        extra: {\n            \"key\": \"value\",\n            \"description\": \"whatever is in the [extra] section of your Markdown doc's header\"\n        }\n    },\n    body: \"<p>Some rendered Markdown content</p>\",\n    published: true\n}To access a part, you simply use a dotted path notation. So to get the value of key in\nthe extra section, we use {{ page.head.extra.key }}.","url":"/bartholomew/templates.md#the-page-object"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"The  site  Object","content":"In addition to the page object, there is also a site object. site.pages contains the head section and content of every page in the site. site.pages is only populated for templates included in index_site_pages in site.toml as described in the undefined:{\n    info: {\n        title: \"site title\"\n        about: \"Site about information\"\n        base_url: \"http://localhost:3000\"\n        extra: {\n            copyright: \"site-wide copyring (this is not required, since it's in extra)\"\n        }\n    },\n    pages: [\n        {...},\n        {...}\n    ]\n}Note that the site.pages array has access to every single document in the content folder.\nThis part of the API may change in the future, as it does not scale terribly well.","url":"/bartholomew/templates.md#the-site-object"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"The  env  Object","content":"The third top-level object is env, which holds all of the environment data.The env object is a set of keys and values:{\n    PREVIEW_MODE: \"0\"\n    ...\n}You can dump the entire contents of env using a template like this:<ul>\n    {{#each env}}\n    <li><code>{{@key}}</code>: <code>\"{{this}}\"</code></li>\n    {{/each}}\n</ul>","url":"/bartholomew/templates.md#the-env-object"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"The  request  Object","content":"The fourth top-level object is request, which holds all the details about\nthe HTTP request, the path of this resource, and other Spin information.The request object is a set of keys and values:{\n    spin-full-url: \"http://localhost:3000/test\"\n    ...\n}You can dump the entire contents of request using a template like this:<ul>\n    {{#each request}}\n    <li><code>{{@key}}</code>: <code>\"{{this}}\"</code></li>\n    {{/each}}\n</ul>","url":"/bartholomew/templates.md#the-request-object"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"Including a Template","content":"It is possible to include a template into another template.\nFor example, if we want to include the navbar.hbs template, we use a \"partial\" include\nlike this:{{> navbar }}Note that we drop the .hbs suffix when including this way.","url":"/bartholomew/templates.md#including-a-template"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"Calling Template Helpers","content":"There are a few template helpers defined in Bartholomew.For example, to change a piece of text to all-caps, use the upper helper:{{ upper \"hello\" }}The above will render HELLO.Note that you can create custom template helpers using undefined.","url":"/bartholomew/templates.md#calling-template-helpers"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"Defined Helper Functions","content":"The following helper functions are provided with Bartholomewundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","url":"/bartholomew/templates.md#defined-helper-functions"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"Values Reference","content":"The following values are available in the template. This is formatted in YAML for readability. The four top-level objects are:undefinedundefinedundefinedundefinedTo reference a particular value, use dotted notation. For example, page has a head, which has the page's title.\nTo access the title, use {{ page.head.title }}.# Page holds data specific to the page that matches the URI. For example, the URI /foo loads page data from /content/foo.md\npage:\n    # The info from the TOML head:\n    head:\n        date: \"2022-01-11T20:08:47Z\" # In templates, use `date_format \"%B %m, %Y\" page.head.date` to format\n        title: \"WebAssembly Language Support Matrix\" # The H1 title\n        description: \"Tracking the programming languages that compile to WebAssembly (Wasm).\"\n        template: \"page\"\n        tags: [\"webassembly\", \"programming languages\", \"javascript\", \"python\", \"rust\", \"dotnet\", \"ruby\"]\n\n        extra: # Remember that everything in extra is optional, so wrap in #if\n            author: \"Fermyon Staff\"\n            author_page: \"/author/\"\n            image: \"/static/some/thing.png\"\n            last_modified: \"2022-01-11T20:08:47Z\" # Only if the page is modified\n    body: \"The HTML content\"\n    published: true # Set to false if either manually disabled by author or if `date` is in the future\n\n# Site holds sitewide data\nsite:\n    # Info keeps all of the information from `site.toml`\n    info:\n        title: \"The site title\"\n        base_url: \"https://something\" # Note no trailing slash\n        about: \"Pithy site summary\"\n        extra:\n            your_defined_field: \"Value\"\n\n    pages: # Metadata for every page on the site. Note that there is no guarantee that `body` will be set.\n        \"/foo\":\n            head:\n                date: \"2022-01-11T20:08:47Z\"\n                title: \"Some title\"\n                # These are all optional\n                description: \"Some Description (if set)\"\n                tags: [\"tags\", \"if\", \"set\"]\n                template: \"template-if-set\"\n                # user-defined extras go here\n                extras:\n                    any: \"extras go here\"\n            published: true\n        \"/bar\":\n            head:\n                # These fields will always be set.\n                date: \"2022-01-11T20:08:47Z\"\n                title: \"Some other title\"\n            published: true\n\nenv: # Environment variables set in the Bartholomew Wasm module\n\nrequest: # HTTP request data along with spin information.Given the above, for example, you can write a template to create a link to the current page:<a href=\"{{site.info.base_url}}{{env.PATH_INFO}}\">{{page.head.title}}</a>The above will output something like:<a href=\"https://example.com/in-action\">WebAssembly In Action</a>","url":"/bartholomew/templates.md#values-reference"},{"project":"bartholomew","title":"Bartholomew templates","subheading":"Template Functions and Rhai Scripts","content":"The following template functions are built into Bartholomew:undefinedundefinedundefinedundefinedNext, let's dive into undefined.","url":"/bartholomew/templates.md#template-functions-and-rhai-scripts"},{"project":"bartholomew","title":"Bartholomew themes","subheading":"","content":"Bartholomew supports theming which allows for easy customization of the site along with the user-defined tempaltes.","url":"/bartholomew/themes"},{"project":"bartholomew","title":"Bartholomew themes","subheading":"Adding a Theme","content":"Once the initial site has been set up using the undefined, create a themes folder where you will be able to download different themes.mkdir themesOnce the folder is created, different themes can be added as submodules to the folder which can then in turn be used to theme the site.cd themes\ngit submodule add <Source_to_the_theme>Multiple themes can be added to the themes directory but only one of them will be active at a given time as described in the next section.","url":"/bartholomew/themes.md#adding-a-theme"},{"project":"bartholomew","title":"Bartholomew themes","subheading":"Configuring the Site to Use the Theme","content":"To choose a theme for the website, the theme attribute in config/site.toml must be configured, where the value is the name of the theme as found in the themes/ folder.title = \"Bartholomew Documentation\"\nbase_url = \"http://localhost:3000\"\nabout = \"The Micro-CMS for WebAssembly and Spin\"\ntheme = \"<theme-directory>\"\n\n[extra]\ncopyright = \"Fermyon\"\ngithub = \"https://github.com/fermyon/bartholomew\"\ntwitter = \"https://twitter.com/fermyontech\"\nga_measurement_id = \"\"\n\ndate_style = \"%B %e, %Y\"One more step that needs to be done before themes are fully available to the site is to the change the static file server component in the spin.toml configuration so that it provides the static assets of the selected theme. The convention of mounting the static assets of the themes before the user-defined static assets is recommened..\n.\n.\n\n[[component]]\nsource = \"modules/spin_static_fs.wasm\"\nid = \"fileserver\"\nfiles = [ {source = \"themes/<name of theme>/static\", destination =\"/\"}, { source = \"static/\", destination = \"/\" }, ]\n[component.trigger]\nroute = \"/static/...\"","url":"/bartholomew/themes.md#configuring-the-site-to-use-the-theme"},{"project":"bartholomew","title":"Bartholomew themes","subheading":"Template Precedence","content":"When a theme is enabled for a site, both the user-defined and theme-provided assets like the templates, scripts and static assets will be available. If a theme-provided asset and user-provided asset have the same name, the user-defined asset takes precedence. This allows for the user to override the theme to allow for customization.As an example, if both templates/main.hbs and themes/<name of theme>/templates/main.hbs exist, the user-defined templates/main.hbs takes precedence leading to the rendering engine using the user-defined template overriding the theme.","url":"/bartholomew/themes.md#template-precedence"},{"project":"bartholomew","title":"Bartholomew themes","subheading":"Creating a Theme","content":"Creating a theme for Bartholomew is easy. Create a new folder and initialize it.mkdir custom_theme\ncd custom_theme\ngit initOnce the git repository is initialized, create the three required directories.mkdir templates scripts staticCreate the custom theme by placing the handlebar templates in the template/ folder while the Rhai scripts are placed in the scripts/ folder. All the static assets such as  the images, JS and CSS are placed in the static folder. For reference on creating templates, refer to the undefined.Once the required changes are done, commit and push the changes to a remote repository, so as to allow for the theme to cloned as a submodule that can be used for theming a site.Let's take a look at how you can do something special in your templates undefined.","url":"/bartholomew/themes.md#creating-a-theme"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"","content":"","url":"/cloud/data-postgres"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"PostgreSQL","content":"undefined, is a powerful, open-source object-relational database system that has earned a strong reputation for reliability, robustness and performance. This tutorial will implement a persistent storage solution for Fermyon Cloud, using PostgreSQL. In this tutorial, we will be using undefined's free PostgreSQL service.","url":"/cloud/data-postgres.md#postgresql"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Spin and Fermyon Cloud","content":"First, you need to have Spin installed on your computer. Please use the official Fermyon Cloud Quickstart to both undefined Spin and also undefined to Fermyon Cloud.","url":"/cloud/data-postgres.md#spin-and-fermyon-cloud"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Using Spin Application Templates","content":"The Spin CLI facilitates the creation of new Spin applications through the use of application templates. You can install Spin application templates using the undefined. The template we are interested in, for this tutorial, is the experimental http-csharp template. We can go ahead and install it using the following command:$ spin templates install --git https://github.com/fermyon/spin-dotnet-sdk --branch main --updateThe output from the command above will be similar to the following:Copying remote template source\nInstalling template http-csharp...\nInstalled 1 template(s)\n\n+------------------------------------------------------------+\n| Name          Description                                  |\n+============================================================+\n| http-csharp   HTTP request handler using C# (EXPERIMENTAL) |\n+------------------------------------------------------------+","url":"/cloud/data-postgres.md#using-spin-application-templates"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Creating Our New Spin Application","content":"The official Spin CLI documentation also has instructions on how to undefined, from an existing template. Using the docs as a reference, we can perform the following:spin new http-csharp httpCSharpApplication\nProject description: A new http-csharp spin application\nHTTP base: /\nHTTP path: /data","url":"/cloud/data-postgres.md#creating-our-new-spin-application"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"CSharp","content":"using Fermyon.Spin.Sdk;\nusing System.Net;\nusing System.Text;\n\nnamespace httpCSharpApplication;\n\npublic static class Handler {\n  [HttpHandler]\n  public static HttpResponse HandleHttpRequest(HttpRequest request) {\n    if (request.Url == Warmup.DefaultWarmupUrl) {\n      return new HttpResponse();\n    }\n\n    var connectionString = \"user=username password=password dbname=databasename host=127.0.0.1\";\n    var result = PostgresOutbound.Query(connectionString, \"SELECT * FROM myTable\");\n\n    var responseText = new StringBuilder();\n\n    responseText.AppendLine($\"Got {result.Rows.Count} row(s)\");\n    responseText.AppendLine($\"COL: [{String.Join(\" | \", result.Columns.Select(FmtCol))}]\");\n\n    string FmtEntry(DbValue v) {\n      return v.Value() switch {\n        null => \"<DBNULL>\",\n          var val => val.ToString() ?? \"<NULL>\",\n      };\n    }\n\n    foreach(var row in result.Rows) {\n      responseText.AppendLine($\"ROW: [{String.Join(\" | \", row.Select(FmtEntry))}]\");\n    }\n\n    return new HttpResponse {\n      StatusCode = HttpStatusCode.OK,\n        BodyAsString = responseText.ToString(),\n    };\n  }\n  private static string FmtCol(PgColumn c) {\n    return $ \"{c.Name} ({c.DataType})\";\n  }\n}","url":"/cloud/data-postgres.md#csharp"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Wizer","content":"Wizer is required to successfully build this application. Please go ahead and install Wizer using the following command:$ cargo install wizer --all-features","url":"/cloud/data-postgres.md#wizer"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Spin Build","content":"To build the application, use the following command:$ spin build","url":"/cloud/data-postgres.md#spin-build"},{"project":"cloud","title":"Persistent Data: PostgreSQL","subheading":"Spin Deploy","content":"To deploy the application, use the deploy command:$ spin deployThe above deploy command will produce similar output to the following:Deployed httpCSharpApplication version 1.0.0+XXXXXXXX\nAvailable Routes:\n  http_c_sharp_application: https://httpcsharpapplication-XXXXXXXX.fermyon.app/dataVisiting the above URL will show your data in the browser's body","url":"/cloud/data-postgres.md#spin-deploy"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"","content":"","url":"/cloud/data-redis"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Redis","content":"undefined, is an open-source data store used by millions of developers as a database, cache, streaming engine, and message broker. This tutorial will implement a persistent storage solution for Fermyon Cloud, using Redis. In this tutorial, we will be using undefined' free Redis service.","url":"/cloud/data-redis.md#redis"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Spin and Fermyon Cloud","content":"First, you need to have Spin installed on your computer. Please use the official Fermyon Cloud Quickstart to both undefined Spin and also undefined to Fermyon Cloud.","url":"/cloud/data-redis.md#spin-and-fermyon-cloud"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Using Spin Application Templates","content":"The Spin CLI facilitates the creation of new Spin applications through the use of application templates. You can install Spin application templates using the undefined. For example:$ spin templates install --git https://github.com/fermyon/spinThe output from the command above will be similar to the following:Copying remote template source\n// --snip--\nInstalling template http-rust...\n// --snip--\n\nInstalled 8 template(s)\n\n+-----------------------------------------------------------------+\n| Name         Description                                        |\n+=================================================================+\n| // --snip--                                                     |\n| http-rust     HTTP request handler using Rust                   |\n+-----------------------------------------------------------------+The template we are interested in is http-rust.","url":"/cloud/data-redis.md#using-spin-application-templates"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Creating Our New Spin Application","content":"The official Spin CLI documentation also has instructions on how to undefined. Let's go ahead and create a new http-rust application:$ spin new http-rust redisRustApplicationThe above command will ask you to enter a Project description, HTTP base (default set to / which is fine) and HTTP path:Project description: \nHTTP base: /\nHTTP path: /...You can fill out these values, when prompted, for example:Project description: A new redis-rust Spin Application.\nHTTP base: /\nHTTP path: /dataundefined","url":"/cloud/data-redis.md#creating-our-new-spin-application"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Redis","content":"To create your free database go to undefined. For this tutorial, we are signing up using GitHub authentication.undefinedOnce you have logged in to Redislabs click on the Data Access Control and Databases menus (in the left sidebar) to create roles/users and a new Redis database. Be sure to acknowledge the usernames, passwords and database URLs (provided during setup) as we will be using these to configure our Spin application. Please see the  undefined for additional information.","url":"/cloud/data-redis.md#redis"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Configuration","content":"Open the Spin application's spin.toml file and add an environment configuration value, within the [[component]] section. For example:environment = { REDIS_ADDRESS = \"redis://username:password@redis.cloud.redislabs.com:16675\" }undefined","url":"/cloud/data-redis.md#configuration"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Spin SDK's Redis Implementation","content":"In this tutorial we will create the code to store and retrieve data from a Redislabs database.","url":"/cloud/data-redis.md#spin-sdks-redis-implementation"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Rust","content":"The following is the content which is required in the src/lib.rs file. Feel free to cut and paste the following, for convenience:use anyhow::{anyhow, Result};\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component, redis,\n};\n\nconst REDIS_ADDRESS_ENV: &str = \"REDIS_ADDRESS\";\n\n#[http_component]\nfn publish(_req: Request) -> Result<Response> {\n    let address = std::env::var(REDIS_ADDRESS_ENV)?;\n\n    // Set the Redis key \"spin-example\" to value \"Eureka Cloud!\"\n    redis::set(&address, \"spin-example\", &b\"Eureka Cloud!\"[..])\n        .map_err(|_| anyhow!(\"Error executing Redis set command\"))?;\n\n    // Get the value from the Redis key \"spin-example\"\n    let payload =\n        redis::get(&address, \"spin-example\").map_err(|_| anyhow!(\"Error querying Redis\"))?;\n\n    // Return the permanently stored value to the user's browser body\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(payload.into()))?)\n}","url":"/cloud/data-redis.md#rust"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Log Into Fermyon Cloud","content":"We need to log into Fermyon Cloud, so that we can build/deploy our application. For example:$ spin login","url":"/cloud/data-redis.md#log-into-fermyon-cloud"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Spin Build","content":"We build this application by typing the following command:$ spin buildThe output from the above command will look similar to the following:Executing the build command for component redis-rust-application: cargo build --target wasm32-wasi --release\n    Finished release [optimized] target(s) in 0.09s\nSuccessfully ran the build command for the Spin components.","url":"/cloud/data-redis.md#spin-build"},{"project":"cloud","title":"Persistent Data: Redis","subheading":"Spin Deploy","content":"To deploy the application, use the deploy command:$ spin deployThe above deploy command will produce similar output to the following:Deployed redisRustApplication version 0.1.0+XXXXXXXX\nApplication is running at redisRustApplication-XXXXXXXX.fermyon.appVisiting the URL, which is provided by the spin deploy command's output will show the Eureka Cloud! value for the spin-example key which is stored in Redis.","url":"/cloud/data-redis.md#spin-deploy"},{"project":"cloud","title":"Deleting an application","subheading":"","content":"undefinedundefinedundefinedIt’s super easy to delete your application with Fermyon Cloud. This can be done in just a few steps using the Fermyon Cloud website.","url":"/cloud/delete"},{"project":"cloud","title":"Deleting an application","subheading":"Sign in to the Fermyon Cloud Website","content":"undefinedundefinedundefined","url":"/cloud/delete.md#sign-in-to-the-fermyon-cloud-website"},{"project":"cloud","title":"Deleting an application","subheading":"Delete Your Application","content":"undefinedundefinedundefinedundefinedundefinedundefinedThat’s all about deleting your Spin Application on the Fermyon Cloud!","url":"/cloud/delete.md#delete-your-application"},{"project":"cloud","title":"Deleting an application","subheading":"Next Steps","content":"undefinedundefined","url":"/cloud/delete.md#next-steps"},{"project":"cloud","title":"Deploy an application","subheading":"","content":"undefinedundefinedundefinedundefinedThis article will guide you through deploying a Spin Application with the Fermyon Cloud. You can deploy your undefined or undefined site in just a few steps.","url":"/cloud/deploy"},{"project":"cloud","title":"Deploy an application","subheading":"Prerequisites - Install the Spin CLI","content":"Before developing a Spin application, you need to have the Spin CLI installed locally. Here’s a way to install the Spin CLI:curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash{{ details \"Additional info\" \"It's easier if you move the spin binary somewhere in your path, so it can be accessed from any directory. E.g., sudo mv ./spin /usr/local/bin/spin. \\n\\nYou can verify the version of Spin installed by running spin --version\" }}","url":"/cloud/deploy.md#prerequisites-install-the-spin-cli"},{"project":"cloud","title":"Deploy an application","subheading":"Log in to the Fermyon Cloud","content":"Next, you can log in to the Fermyon Cloud, which requires your GitHub account to sign in.$ spin login\n\nCopy your one-time code:\n\nXXXXXXXX\n\n...and open the authorization page in your browser:\n\nhttps://cloud.fermyon.com/device-authorization\n\nWaiting for device authorization...\nDevice authorized!This command generates an authentication code for your device to be authorized on the Fermyon Cloud.","url":"/cloud/deploy.md#log-in-to-the-fermyon-cloud"},{"project":"cloud","title":"Deploy an application","subheading":"Deploy Your Application","content":"After having signed in to the Fermyon Cloud, you deploy the application, by running the following command in the directory where your applications spin.toml file is located.$ spin deploy\nUploading cloud_start version 0.1.0+XXXXXXXX...\nDeploying...\nWaiting for application to become ready... ready\nAvailable Routes:\n  cloud-start: https://cloud-start-XXXXXXXX.fermyon.app (wildcard)Take a look at the undefined for how to get a pre-built application to deploy.{{ details \"Additional info\" \"spin deploy can point to a spin.toml file by using the --file option.\" }}undefined","url":"/cloud/deploy.md#deploy-your-application"},{"project":"cloud","title":"Deploy an application","subheading":"Next Steps","content":"undefined","url":"/cloud/deploy.md#next-steps"},{"project":"cloud","title":"Deployment Concepts","subheading":"","content":"undefinedundefinedundefined","url":"/cloud/deployment-concepts"},{"project":"cloud","title":"Deployment Concepts","subheading":"Deployments in Fermyon Cloud","content":"Deploying applications to a cloud service should be simple. Even though there is complexity involved in operating a cloud with many servers, many applications, and an ever-changing number of workloads, the user's responsibility when deploying their applications should be minimal.In this article, we describe the core technologies and concepts, which are part of the deployment process in the Fermyon Cloud.","url":"/cloud/deployment-concepts.md#deployments-in-fermyon-cloud"},{"project":"cloud","title":"Deployment Concepts","subheading":"Bindle - An Aggregate Object Storage System","content":"The Fermyon Cloud uses undefined to package and distribute Spin applications. Bindle is an open-source project, built and maintained by Deis Labs. Bindle is very well documented, so we will not go into details of how Bindle works, other than calling out a few core features of the system here:undefinedundefinedundefined","url":"/cloud/deployment-concepts.md#bindle-an-aggregate-object-storage-system"},{"project":"cloud","title":"Deployment Concepts","subheading":"The Deployment Process Explained","content":"In the Fermyon Cloud, we host an instance of Bindle, so when you run spin deploy, the command will take care of:undefinedundefinedThere is no direct interaction with Bindle when using the Fermyon Cloud.Let's unfold each of these steps.","url":"/cloud/deployment-concepts.md#the-deployment-process-explained"},{"project":"cloud","title":"Deployment Concepts","subheading":"1. Packaging and Uploading an Application","content":"The first step in deploying an application is to package all the files into parcels and generate an invoice.  All of this is handled in a staging directory, which is either a temporary directory using undefined or the staging directory defined using the --staging-dir option.The bindle will be named using the name from spin.toml, the version from spin.toml, and a build metadata string, which is automatically generated by Spin at deployment time.Bindles in the Fermyon Cloud always use Semantic Versioning and require major, minor, and patch version numbers to be specified. Therefore, the version in spin.toml has to conform to the MAJOR.MINOR.PATCH format, i.e. 1.0.1 is valid, 1.0 and 1 are not valid version numbers for a Spin application. The result is that the version of a Spin application will be like this my_app_name/1.0.0+r80e5abb.Following packaging, the bindle will be uploaded to the Fermyon Cloud. As soon as a bindle has been uploaded, it cannot be modified or deleted. This is to preserve the integrity of the immutability of bindles.","url":"/cloud/deployment-concepts.md#1-packaging-and-uploading-an-application"},{"project":"cloud","title":"Deployment Concepts","subheading":"2. Create or Upgrade an Application","content":"The next step in the deployment process is to create or upgrade the application.An application in the Fermyon Cloud can have multiple revisions, which are tied to channels. These concepts are derived from undefined an open-source Platform as a Service (PaaS) for WebAssembly. As you deploy your application both an application, a channel and a revision will be created in the Fermyon Cloud.If the application already exists, an upgrade will take place. What happens at this point is that a new revision will be created, and as soon as this is deemed healthy, traffic will start to route to the new revision. The failover from the old to the new revision takes a short amount of time, during which you will be able to observe replies from both revisions. The application existence is determined based on the combination of the user account and the Spin application name, as defined in spin.toml.The deployment process checks for the application health endpoint and finishes once the application is concluded to be healthy by the cloud. The application health point is an integral part of the Fermyon Cloud but does reserve the HTTP route /.well-known/spin/health, which will not be routed to your Spin application.","url":"/cloud/deployment-concepts.md#2-create-or-upgrade-an-application"},{"project":"cloud","title":"Develop a Spin application","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedThis article briefly describes how to create a new Spin application. For a more thorough guide to developing Spin applications, take a look undefined.","url":"/cloud/develop"},{"project":"cloud","title":"Develop a Spin application","subheading":"Prerequisites - Install the Spin CLI","content":"Before developing a Spin application, you need to have the Spin CLI installed locally. Here’s a way to install the Spin CLI:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash{{ details \"Additional info\" \"It's easier if you move the spin binary somewhere in your path, so it can be accessed from any directory. E.g., sudo mv ./spin /usr/local/bin/spin. \\n\\nYou can verify the version of Spin installed by running spin --version\" }}","url":"/cloud/develop.md#prerequisites-install-the-spin-cli"},{"project":"cloud","title":"Develop a Spin application","subheading":"Create a New Spin Application From a Template","content":"You can create your very own application based on undefined. Start by installing a set of Spin application templates undefined:$ spin templates install --git https://github.com/fermyon/spin\nCopying remote template source\nInstalling template http-rust...\nInstalling template http-go...\n...\n+--------------------------------------------------+\n| Name         Description                         |\n+==================================================+\n| http-rust    HTTP request handler using Rust     |\n| http-go      HTTP request handler using (Tiny)Go |\n| ...                                              |\n+--------------------------------------------------+{{ details \"Additional info\" \"If you already have templates installed, you can update them by running spin templates install --git https://github.com/fermyon/spin --update \\n\\nIf you’re interested in building your own template, you can follow the guide here undefined and the undefined.\" }}We will be using the http-rust template to build our Spin Application, by running spin new.$ spin new\nPick a template to start your project with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-csharp (HTTP request handler using C# (EXPERIMENTAL))\n  http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n> http-rust (HTTP request handler using Rust)\n  http-swift (HTTP request handler using SwiftWasm)\n  http-zig (HTTP request handler using Zig)\n  redis-go (Redis message handler using (Tiny)Go)\n  redis-rust (Redis message handler using Rust)\n\nEnter a name for your new project: hello_rust\nProject description: My first Rust Spin application\nHTTP base: /\nHTTP path: /...The command created all the files we need to build and run our Spin Application. Here’s the spin.toml file — the manifest file for a Spin application:spin_version = \"1\"\nauthors = [\"Doc Docsen <docs@fermyon.com>\"]\ndescription = \"My first Rust Spin application\"\nname = \"hello_rust\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"hello-rust\"\nsource = \"target/wasm32-wasi/release/hello_rust.wasm\"\n[component.trigger]\nroute = \"/...\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"Next, let’s build the app.$ spin build\nExecuting the build command for component hello-rust: cargo build --target wasm32-wasi --release\n    Updating crates.io index\n    Updating git repository `https://github.com/fermyon/spin`\n    Updating git repository `https://github.com/bytecodealliance/wit-bindgen`\n    ...\n   Compiling hello-rust v0.1.0 (/Users/doc/hello_rust)\n    Finished release [optimized] target(s) in 10.15s\nSuccessfully ran the build command for the Spin components.","url":"/cloud/develop.md#create-a-new-spin-application-from-a-template"},{"project":"cloud","title":"Develop a Spin application","subheading":"Run the Application","content":"Now it’s time to spin up the application.$ spin up\nServing http://127.0.0.1:3000\nAvailable Routes:\n  hello-rust: http://127.0.0.1:3000 (wildcard){{ details \"Additional info\" \"To get information printed to the console, use the --follow-all flag when running spin up. /n/nYou can also set the RUST_LOG environment variable for detailed logs, before running spin up, e.g., RUST_LOG=spin=debug spin up.\" }}Spin will instantiate all components from the application manifest, and will create the router configuration for the HTTP trigger accordingly. The component can now be invoked by making requests to http://localhost:3000:$ curl -i localhost:3000\nHTTP/1.1 200 OK\nfoo: bar\ncontent-length: 15\n\nHello, Fermyon","url":"/cloud/develop.md#run-the-application"},{"project":"cloud","title":"Develop a Spin application","subheading":"Write Your Code","content":"For this template, we have a single crate built from src/lib.rs, which contains the following code:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n/// A simple Spin HTTP component.\n#[http_component]\nfn hello_rust(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req.headers());\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Fermyon\".into()))?)\n}Let's change the body text returned to be a parameter from the URL, by changing the hello_rust function to the code below:/// A simple Spin HTTP component, returning the value of the first URL parameter as a greeting.\n/// Try `curl \"http://localhost:3000?Doc\"`\n#[http_component]\nfn hello_rust(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req.headers());\n    \n    let query_string = req.uri().query();\n\n    let reply_body = match query_string {\n        Some(s) => format!(\"Hello {s}!\"),\n        None => \"Who's there?\".to_string(),\n    };\n    \n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(reply_body.into()))?)\n}This Spin application will now take the query string of the URL http://localhost:3000?Doc and return the text Hello Doc! as a greeting.","url":"/cloud/develop.md#write-your-code"},{"project":"cloud","title":"Develop a Spin application","subheading":"Next Steps","content":"undefinedundefinedundefined","url":"/cloud/develop.md#next-steps"},{"project":"cloud","title":"FAQ and Known Limitations","subheading":"","content":"This document contains:undefinedundefinedundefinedundefined","url":"/cloud/faq"},{"project":"cloud","title":"FAQ and Known Limitations","subheading":"Service Limits","content":"The following are the limits of the Fermyon Cloudundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","url":"/cloud/faq.md#service-limits"},{"project":"cloud","title":"FAQ and Known Limitations","subheading":"Known Limitations","content":"The following are known limitations of the Fermyon Cloudundefinedundefinedundefinedundefined","url":"/cloud/faq.md#known-limitations"},{"project":"cloud","title":"FAQ and Known Limitations","subheading":"Frequently Asked Questions","content":"undefined11:08:13 : Hello from Rust\n11:08:18 : Hello from Rust - updated\n11:08:19 : Hello from Rust\n11:08:23 : Hello from Rust - updated\n11:08:24 : Bad Gateway\n11:08:26 : Hello from Rust - updated\n11:08:27 : Bad Gateway\n11:08:29 : Hello from Rust - updatedundefined","url":"/cloud/faq.md#frequently-asked-questions"},{"project":"cloud","title":"FAQ and Known Limitations","subheading":"Next Steps","content":"undefined","url":"/cloud/faq.md#next-steps"},{"project":"cloud","title":"Fermyon Cloud","subheading":"","content":"undefinedundefined","url":"/cloud/fermyon-cloud"},{"project":"cloud","title":"Fermyon Cloud","subheading":"The Fermyon Cloud Explained","content":"undefined is a cloud application platform for WebAssembly microservices. It enables you to run undefined, at scale, in the cloud, without any infrastructure setup.In this article we describe the core technologies and concepts which are part of the Fermyon Cloud.","url":"/cloud/fermyon-cloud.md#the-fermyon-cloud-explained"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Core Components of the Fermyon Cloud","content":"The Fermyon Cloud is an expansion of the undefined, built to provide scalable and resilient hosting for Spin applications.The following core components are needed in a cloud platform:undefinedundefinedundefinedundefinedundefinedAll of the above are key to ensuring the high dynamism of a cloud platform where applications and traffic come and go in unpredictable patterns.","url":"/cloud/fermyon-cloud.md#core-components-of-the-fermyon-cloud"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Orchestration","content":"The core orchestration in the Fermyon Cloud is done using undefined. Nomad enables the Fermyon Cloud to spread workloads across servers, and run an optimized highly resilient cloud. Nomad guarantees quick placement of Spin applications, at deployment, upgrade and failures in the underlying infrastructure - which do happen, so we planned for it.","url":"/cloud/fermyon-cloud.md#orchestration"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Service Resolution","content":"In order to successfully route traffic to your Spin applications, a service registry is needed to map application endpoints to sockets on servers. This is done using Consul, as an integrated part of Nomad. Consul helps ensure we can always find your application, as the orchestration engine may or may not move it around.","url":"/cloud/fermyon-cloud.md#service-resolution"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Traffic Routing","content":"Traffic routing is done using undefined, which ensures that data is sent to the right places in the cloud.","url":"/cloud/fermyon-cloud.md#traffic-routing"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Application Packaging and Distribution","content":"To package and distribute application to and within the cloud, we rely on Bindle. For more information about deployment concepts in the Fermyon Cloud, see undefined.","url":"/cloud/fermyon-cloud.md#application-packaging-and-distribution"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Web UI, API and CLI","content":"The Fermyon Cloud exposes a public undefined which is used by the undefined and the Spin CLI when logging in and deploying applications.","url":"/cloud/fermyon-cloud.md#web-ui-api-and-cli"},{"project":"cloud","title":"Fermyon Cloud","subheading":"","content":"undefinedundefinedundefinedundefinedundefined is a cloud application platform for WebAssembly microservices. It enables you to run undefined, at scale, in the cloud, without any infrastructure setup.","url":"/cloud/index"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Documentation","content":"This site contains the documentation for the Fermyon Cloud. Here you will:undefinedundefinedundefinedundefinedundefinedundefined","url":"/cloud/index.md#documentation"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Getting Support","content":"If you have any questions (and cannot find answers) on this site, please go to our undefined for assistance.","url":"/cloud/index.md#getting-support"},{"project":"cloud","title":"Fermyon Cloud","subheading":"Open Beta","content":"The Fermyon Cloud is currently an open beta service. This means that Fermyon Technologies does not provide any service-level agreements on the service, including the workloads you choose to deploy. We also reserve the right to break compatibility with:undefinedundefined","url":"/cloud/index.md#open-beta"},{"project":"cloud","title":"Let's get started","subheading":"","content":"undefinedundefinedundefinedundefinedundefinedundefinedundefinedThis guide will get you up and running in the Fermyon Cloud in less than two minutes. To do so, we've already made a Spin application ready for you to deploy to the cloud.","url":"/cloud/quickstart"},{"project":"cloud","title":"Let's get started","subheading":"Install Spin","content":"First, you need to have Spin installed on your computer. Use the command below to install the latest version of Spin.curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashThis command downloads and unpacks the latest Spin binary in the current directory.undefined, e.g.:$ sudo mv spin /usr/local/bin/{{ details \"Learn more\" \"undefined is an open-source project used for creating, developing, building, running, and deploying Spin applications. It is both a CLI tool and a runtime, and provides SDKs for a variety of programming languages, including, but not limited to, Rust, TinyGo, and C#. \\n\\n The Spin project provides installers that are supported on Linux (amd64), macOS (amd64 and arm64), and Windows(amd64). \\n\\n The undefined documentation is a good starting place to learn more about using the framework to develop applications.\"}}","url":"/cloud/quickstart.md#install-spin"},{"project":"cloud","title":"Let's get started","subheading":"Log in to the Fermyon Cloud","content":"Now, let's log in to the Fermyon Cloud. You will be using your undefined to sign in.$ spin login\n\nCopy your one-time code:\n\nXXXXXXXX\n\n...and open the authorization page in your browser:\n\nhttps://cloud.fermyon.com/device-authorization\n\nWaiting for device authorization...\nDevice authorized!This command will generate an authentication code for your current device to be authorized against the Fermyon Cloud. Follow the instructions in the prompt to complete the authorization process.{{ details \"Learn more\" \"The default behavior of spin login is to authenticate with the Fermyon Cloud. The command can authenticate against any instance of the undefined.\" }}","url":"/cloud/quickstart.md#log-in-to-the-fermyon-cloud"},{"project":"cloud","title":"Let's get started","subheading":"Clone the Quickstart Repo","content":"To make this easy, we've already compiled a Webassembly module and created a Spin application for you to deploy.Let's go ahead and clone the undefined repository to your computer to retrieve that application.$ git clone https://github.com/fermyon/cloud-start && cd cloud-startThis command clones the repository into a local directory named cloud-start, and then enters that directory.{{ details \"Learn more\" \"To write your Spin application, you would start by using the command spin new [template name] [project name]. This gives you the option to select a template based on your preference of programming language and trigger for your module - e.g., spin new rust-http my_rust_http_trigger. \\n\\n The undefined guides you through creating a Spin application from scratch.\" }}","url":"/cloud/quickstart.md#clone-the-quickstart-repo"},{"project":"cloud","title":"Let's get started","subheading":"Deploy the Application","content":"Let's deploy the application$ spin deployThe spin command will run using the Spin binary in your system path and read the Spin application definition file spin.toml in the current (cloud-start) directory to know what application to deploy.{{ details \"Learn more\" \"Deploying a Spin application to the Fermyon Cloud includes packaging the application and all the required files, uploading it to a Bindle registry, as well as instantiating the application on the cloud. \\n\\n You can learn more about the deployment process undefined.\" }}","url":"/cloud/quickstart.md#deploy-the-application"},{"project":"cloud","title":"Let's get started","subheading":"Success","content":"This is what a successful Spin application deployment on Fermyon Cloud looks like:Uploading cloud_start version 0.1.0+XXXXXXXX...\nDeploying...\nWaiting for application to become ready... ready\nAvailable Routes:\n  cloud-start: https://cloud-start-XXXXXXXX.fermyon.app (wildcard)You can CTRL+Click on the link in the terminal to visit the web application you just deployed.Congratulations, you've now deployed your first Spin application to the undefined","url":"/cloud/quickstart.md#success"},{"project":"cloud","title":"Let's get started","subheading":"Next Steps","content":"undefinedundefinedundefinedundefinedundefined","url":"/cloud/quickstart.md#next-steps"},{"project":"cloud","title":"Rest API","subheading":"","content":"","url":"/cloud/rest-api"},{"project":"cloud","title":"Rest API","subheading":"OpenAPI","content":"The undefined project contains automatically generated client libraries for use with the Fermyon Cloud.","url":"/cloud/rest-api.md#openapi"},{"project":"cloud","title":"Rest API","subheading":"Rust Client","content":"To use undefined, go ahead and add a reference to the Fermyon Cloud OpenAPI in your project’s Cargo.toml file, as shown below:cloud-openapi = { git = \"https://github.com/fermyon/cloud-openapi\" }","url":"/cloud/rest-api.md#rust-client"},{"project":"cloud","title":"Rest API","subheading":"Documenting the Fermyon Cloud API","content":"The documentation for each client library is automatically generated and is available in the undefined.","url":"/cloud/rest-api.md#documenting-the-fermyon-cloud-api"},{"project":"cloud","title":"Rest API","subheading":"Related Resources","content":"undefinedundefined","url":"/cloud/rest-api.md#related-resources"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"","content":"","url":"/cloud/spin-vs-code-extension"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"Visual Studio Code","content":"undefined is a source-code editor that can be used with a variety of programming languages. It was recently ranked the most popular developer environment tool (by 82, 000 respondents in the undefined).","url":"/cloud/spin-vs-code-extension.md#visual-studio-code"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"The Spin Extension","content":"VS Code extensions allow you to add tools to your installation, to support your development workflow. Fermyon's undefined integrates Spin developer tasks into the VS Code editor.","url":"/cloud/spin-vs-code-extension.md#the-spin-extension"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"Installation","content":"The Spin Extension for VS Code can be found in the undefined and can also be installed by searching for Fermyon Spin within the Extensions section of your VS Code editor. The extension downloads and uses a compatible version of Spin by default.","url":"/cloud/spin-vs-code-extension.md#installation"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"Supported Spin Commands","content":"At present, the Spin VS Code Extension supports the undefined, undefined and undefined commands. Simply open your VS Code terminal (from the main VS Code menu bar) to perform these commands.","url":"/cloud/spin-vs-code-extension.md#supported-spin-commands"},{"project":"cloud","title":"Spin Visual Studio (VS) Code Extension","subheading":"Fermyon Cloud and VS Code","content":"undefined shows you how to create, build, deploy, update and re-deploy a new Spin application, all from within VS Code. The video is based on using Fermyon Cloud","url":"/cloud/spin-vs-code-extension.md#fermyon-cloud-and-vs-code"},{"project":"cloud","title":"Support","subheading":"","content":"This article contains the following information:undefinedundefinedundefined","keywords":"abuse security concern","url":"/cloud/support"},{"project":"cloud","title":"Support","subheading":"Engage on Discord","content":"As the Fermyon Cloud is currently in Beta, support is being provided best effort through undefined. This link will take you to the undefined channel, which is a good place to start.For support related to undefined, undefined, and other projects, please use the appropriate channels on Discord as well.","keywords":"abuse security concern","url":"/cloud/support.md#engage-on-discord"},{"project":"cloud","title":"Support","subheading":"Report Issues on GitHub","content":"To see any know issues and report a specific issue, feel free to use the undefined","keywords":"abuse security concern","url":"/cloud/support.md#report-issues-on-github"},{"project":"cloud","title":"Support","subheading":"Report Abuse","content":"To report suspected abuse of the Fermyon Cloud service, please e-mail abuse@fermyon.com.","keywords":"abuse security concern","url":"/cloud/support.md#report-abuse"},{"project":"cloud","title":"Upgrade an Application","subheading":"","content":"undefinedundefinedTo upgrade your Spin application, there are just a few steps to take. This doesn’t require so much stress.","url":"/cloud/upgrade"},{"project":"cloud","title":"Upgrade an Application","subheading":"Upgrade Your Application","content":"To upgrade a Spin application running in the Fermyon Cloud, you first have to change the version of your application.undefinedversion = \"0.1.0\"In this case, we're changing the version from 0.1.0 to 0.1.1version = \"0.1.1\"{{ details \"Additional info\" \"Spin application are packaged using undefined. Bindle ensures immutability, meaning you cannot overwrite a Bindle (name+version), once it has been uploaded to a Bindle server. /n/n spin deploy will fail if you try to redeploy a version of an application, which already exists in the Fermyon Cloud.\" }}You can now deploy the upgraded version of your application by running this command:$ spin deployThat’s how to upgrade a Spin Application, just as simple as that!","url":"/cloud/upgrade.md#upgrade-your-application"},{"project":"cloud","title":"Upgrade an Application","subheading":"Next Steps","content":"undefinedundefined","url":"/cloud/upgrade.md#next-steps"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"","content":"undefined","url":"/common/cli-reference"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Spin","content":"This page documents the Spin Command Line Interface (CLI). Specifically, all of the available Spin Options and Subcommands. You can reproduce this documentation on your machine by using the --help For example:$ spin --help\n\nUSAGE:\n    spin <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    add          Scaffold a new component into an existing application\n    bindle       Commands for publishing applications as bindles\n    build        Build the Spin application\n    deploy       Deploy a Spin application\n    help         Print this message or the help of the given subcommand(s)\n    login        Log into the server\n    new          Scaffold a new application based on a template\n    plugins      Install/uninstall Spin plugins\n    templates    Commands for working with WebAssembly component templates\n    up           Start the Spin application","url":"/common/cli-reference.md#spin"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Add","content":"Adding a subcommand (and again issuing the --help command) will provide information specific to that particular subcommand. For example:$ spin add --help\n\nUSAGE:\n    spin add [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n        --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -f, --file <APP_CONFIG_FILE>       Path to spin.toml\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parameters\n                                       specified in the file","url":"/common/cli-reference.md#add"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Bindle","content":"Adding a subcommand (and again issuing the --help command) will provide information specific to that particular subcommand. For example:$ spin bindle --help\n\nUSAGE:\n    spin bindle <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help       Print this message or the help of the given subcommand(s)\n    prepare    Create a standalone bindle for subsequent publication\n    push       Publish an application as a bindle","url":"/common/cli-reference.md#bindle"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Prepare (Bindle)","content":"Again, adding another related subcommand provides even more specific information. For example:$ spin bindle prepare --help\n\nUSAGE:\n    spin bindle prepare [OPTIONS] --staging-dir <STAGING_DIR>\n\nOPTIONS:\n        --buildinfo <BUILDINFO>        Build metadata to append to the bindle version\n    -d, --staging-dir <STAGING_DIR>    Path to create standalone bindle\n    -f, --file <APP_CONFIG_FILE>       Path to spin.toml\n    -h, --help                         Print help information","url":"/common/cli-reference.md#prepare-bindle"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Push (Bindle)","content":"$ spin bindle push --help\n\nUSAGE:\n    spin bindle push [OPTIONS] --bindle-server <BINDLE_SERVER_URL>\n\nOPTIONS:\n        --bindle-password <BINDLE_PASSWORD>\n            Basic http auth password for the bindle server [env: BINDLE_PASSWORD=]\n\n        --bindle-server <BINDLE_SERVER_URL>\n            URL of bindle server [env: BINDLE_URL=]\n\n        --bindle-username <BINDLE_USERNAME>\n            Basic http auth username for the bindle server [env: BINDLE_USERNAME=]\n\n        --buildinfo <BUILDINFO>\n            Build metadata to append to the bindle version\n\n    -d, --staging-dir <STAGING_DIR>\n            Path to assemble the bindle before pushing (defaults to temporary directory)\n\n    -f, --file <APP_CONFIG_FILE>\n            Path to spin.toml\n\n    -h, --help\n            Print help information\n\n    -k, --insecure\n            Ignore server certificate errors","url":"/common/cli-reference.md#push-bindle"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Build","content":"$ spin build --help\n\nUSAGE:\n    spin build [OPTIONS] [UP_ARGS]...\n\nARGS:\n    <UP_ARGS>...    \n\nOPTIONS:\n    -f, --file <APP_CONFIG_FILE>    Path to spin.toml\n    -h, --help                      Print help information\n    -u, --up                        Run the application after building","url":"/common/cli-reference.md#build"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Deploy","content":"$ spin deploy --help\n\nUSAGE:\n    spin deploy [OPTIONS]\n\nOPTIONS:\n        --buildinfo <BUILDINFO>\n            Build metadata to append to the bindle version\n\n    -d, --staging-dir <STAGING_DIR>\n            Path to assemble the bindle before pushing (defaults to a temporary directory)\n\n    -e, --deploy-existing-bindle\n            Deploy existing bindle if it already exists on bindle server\n\n        --environment-name <environment-name>\n            Deploy to the Fermyon instance saved under the specified name. If omitted, Spin deploys\n            to the default unnamed instance [env: FERMYON_DEPLOYMENT_ENVIRONMENT=]\n\n    -f, --file <APP_CONFIG_FILE>\n            Path to spin.toml [default: spin.toml]\n\n    -h, --help\n            Print help information\n\n        --no-buildinfo\n            Disable attaching buildinfo [env: SPIN_DEPLOY_NO_BUILDINFO=]\n\n        --readiness-timeout <READINESS_TIMEOUT_SECS>\n            How long in seconds to wait for a deployed HTTP application to become ready. The default\n            is 60 seconds. Set it to 0 to skip waiting for readiness [default: 60]","url":"/common/cli-reference.md#deploy"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Help","content":"spin help\n\nUSAGE:\n    spin <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    add          Scaffold a new component into an existing application\n    bindle       Commands for publishing applications as bindles\n    build        Build the Spin application\n    deploy       Deploy a Spin application\n    help         Print this message or the help of the given subcommand(s)\n    login        Log into the server\n    new          Scaffold a new application based on a template\n    plugins      Install/uninstall Spin plugins\n    templates    Commands for working with WebAssembly component templates\n    up           Start the Spin applicationundefined","url":"/common/cli-reference.md#help"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Login","content":"spin login --help\n\nUSAGE:\n    spin login [OPTIONS]\n\nOPTIONS:\n        --auth-method <auth-method>\n            [env: AUTH_METHOD=] [possible values: github, username]\n\n        --bindle-password <BINDLE_PASSWORD>\n            Basic http auth password for the bindle server [env: BINDLE_PASSWORD=]\n\n        --bindle-server <BINDLE_SERVER_URL>\n            URL of bindle server [env: BINDLE_URL=]\n\n        --bindle-username <BINDLE_USERNAME>\n            Basic http auth username for the bindle server [env: BINDLE_USERNAME=]\n\n        --environment-name <environment-name>\n            Save the login details under the specified name instead of making them the default. Use\n            named environments with `spin deploy --environment-name <name>` [env:\n            FERMYON_DEPLOYMENT_ENVIRONMENT=]\n\n    -h, --help\n            Print help information\n\n    -k, --insecure\n            Ignore server certificate errors from bindle and hippo\n\n        --list\n            List saved logins\n\n        --password <HIPPO_PASSWORD>\n            Hippo password [env: HIPPO_PASSWORD=]\n\n        --status\n            Display login status\n\n        --url <HIPPO_SERVER_URL>\n            URL of hippo server [env: HIPPO_URL=] [default: https://cloud.fermyon.com/]\n\n        --username <HIPPO_USERNAME>\n            Hippo username [env: HIPPO_USERNAME=]","url":"/common/cli-reference.md#login"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"New","content":"$ spin new --help\n\nUSAGE:\n    spin new [OPTIONS] [ARGS]\n\nARGS:\n    <TEMPLATE_ID>    The template from which to create the new application or component. Run\n                     `spin templates list` to see available options\n    <NAME>           The name of the new application or component\n\nOPTIONS:\n        --accept-defaults              An optional argument that allows to skip prompts for the\n                                       manifest file by accepting the defaults if available on the\n                                       template\n    -h, --help                         Print help information\n    -o, --output <OUTPUT_PATH>         The directory in which to create the new application or\n                                       component. The default is the name argument\n    -v, --value <VALUES>               Parameter values to be passed to the template (in name=value\n                                       format)\n        --values-file <VALUES_FILE>    A TOML file which contains parameter values in name = \"value\"\n                                       format. Parameters passed as CLI option overwrite parametersThe spin add command is identical to spin new except that it adds a component to an existing application (instead of starting a new application).  It needs an existing spin.toml file, either in the current directory or referenced via the -f option.","url":"/common/cli-reference.md#new"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Plugins","content":"$ spin plugins --help\n\nUSAGE:\n    spin plugins <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install plugin from a manifest\n    list         List available or installed plugins\n    uninstall    Remove a plugin from your installation\n    update       Fetch the latest Spin plugins from the spin-plugins repository\n    upgrade      Upgrade one or all plugins","url":"/common/cli-reference.md#plugins"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Install (Plugins)","content":"$ spin plugins install --help\n\nUSAGE:\n    spin plugins install [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>\n            Name of Spin plugin\n\nOPTIONS:\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            URL of remote plugin manifest to install\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin","url":"/common/cli-reference.md#install-plugins"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"List (Plugins)","content":"$ spin plugins list --help\n\nUSAGE:\n    spin plugins list [OPTIONS]\n\nOPTIONS:\n    -h, --help         Print help information\n        --installed    List only installed plugins","url":"/common/cli-reference.md#list-plugins"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Uninstall (Plugins)","content":"$ spin plugins uninstall --help\n\nUSAGE:\n    spin plugins uninstall <NAME>\n\nARGS:\n    <NAME>    Name of Spin plugin\n\nOPTIONS:\n    -h, --help    Print help information","url":"/common/cli-reference.md#uninstall-plugins"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Update (Plugins)","content":"$ spin plugins update --help\n\nFetch the latest Spin plugins from the spin-plugins repository\n\nUSAGE:\n    spin plugins update\n\nOPTIONS:\n    -h, --help    Print help information","url":"/common/cli-reference.md#update-plugins"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Upgrade (Plugins)","content":"$ spin plugins upgrade --help\n\nUSAGE:\n    spin plugins upgrade [OPTIONS] [PLUGIN_NAME]\n\nARGS:\n    <PLUGIN_NAME>    Name of Spin plugin to upgrade\n\nOPTIONS:\n    -a, --all\n            Upgrade all plugins\n\n    -d, --downgrade\n            Allow downgrading a plugin's version\n\n    -f, --file <LOCAL_PLUGIN_MANIFEST>\n            Path to local plugin manifest\n\n    -h, --help\n            Print help information\n\n        --override-compatibility-check\n            Overrides a failed compatibility check of the plugin with the current version of Spin\n\n    -u, --url <REMOTE_PLUGIN_MANIFEST>\n            Path to remote plugin manifest\n\n    -v, --version <VERSION>\n            Specific version of a plugin to be install from the centralized plugins repository\n\n    -y, --yes\n            Skips prompt to accept the installation of the plugin[s]","url":"/common/cli-reference.md#upgrade-plugins"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Templates","content":"$ spin templates --help\n\nUSAGE:\n    spin templates <SUBCOMMAND>\n\nOPTIONS:\n    -h, --help    Print help information\n\nSUBCOMMANDS:\n    help         Print this message or the help of the given subcommand(s)\n    install      Install templates from a Git repository or local directory\n    list         List the installed templates\n    uninstall    Remove a template from your installation","url":"/common/cli-reference.md#templates"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Install (Templates)","content":"$ spin templates install --help\n\nUSAGE:\n    spin templates install [OPTIONS]\n\nOPTIONS:\n        --branch <BRANCH>\n            The optional branch of the git repository\n\n        --dir <FROM_DIR>\n            Local directory containing the template(s) to install\n\n        --git <FROM_GIT>\n            The URL of the templates git repository. The templates must be in a git repository in a\n            \"templates\" directory\n\n    -h, --help\n            Print help information\n\n        --update\n            If present, updates existing templates instead of skipping","url":"/common/cli-reference.md#install-templates"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"List (Templates)","content":"$ spin templates list --help\n\nUSAGE:\n    spin templates list\n\nOPTIONS:\n    -h, --help    Print help information","url":"/common/cli-reference.md#list-templates"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Uninstall (Templates)","content":"$ spin templates uninstall --help\n\nUSAGE:\n    spin templates uninstall <TEMPLATE_ID>\n\nARGS:\n    <TEMPLATE_ID>    The template to uninstall\n\nOPTIONS:\n    -h, --help    Print help information","url":"/common/cli-reference.md#uninstall-templates"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Up","content":"The following options are available in relation to running your Spin application. Additionally, depending on the type of trigger that your application uses (i.e. HTTP or Redis trigger), there are trigger-specific options available. Details of the trigger options can be found in the next section (below).$ spin up --help\nUSAGE:\n    spin up [OPTIONS]\n\nOPTIONS:\n    -b, --bindle <BINDLE_ID>\n            ID of application bindle\n\n        --bindle-password <BINDLE_PASSWORD>\n            Basic http auth password for the bindle server [env: BINDLE_PASSWORD=]\n\n        --bindle-server <BINDLE_SERVER_URL>\n            URL of bindle server [env: BINDLE_URL=]\n\n        --bindle-username <BINDLE_USERNAME>\n            Basic http auth username for the bindle server [env: BINDLE_USERNAME=]\n\n        --direct-mounts\n            For local apps with directory mounts and no excluded files, mount them directly instead\n            of using a temporary directory\n\n    -e, --env <ENV>\n            Pass an environment variable (key=value) to all components of the application\n\n    -f, --file <APP_CONFIG_FILE>\n            Path to spin.toml\n\n    -h, --help\n            \n\n    -k, --insecure\n            Ignore server certificate errors from bindle server\n\n        --temp <TMP>\n            Temporary directory for the static assets of the components","url":"/common/cli-reference.md#up"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Trigger Options","content":"","url":"/common/cli-reference.md#trigger-options"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"Redis Request Handler","content":"Below, please see the available trigger options for the Redis request handler.TRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --follow <FOLLOW_ID>\n            Print output for given component(s) to stdout/stderr\n\n        --follow-all\n            Print all component output to stdout/stderr\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]","url":"/common/cli-reference.md#redis-request-handler"},{"project":"common","title":"Spin Command Line Interface (CLI) Reference","subheading":"HTTP Request Handler","content":"Below, please see the available trigger options for the HTTP request handler. Note the additional three trigger options that the HTTP request handler offers (--listen, --tls-cert and --tls-key).TRIGGER OPTIONS:\n        --allow-transient-write\n            Set the static assets of the components in the temporary directory as writable\n\n        --cache <WASMTIME_CACHE_FILE>\n            Wasmtime cache configuration file\n            \n            [env: WASMTIME_CACHE_FILE=]\n\n        --disable-cache\n            Disable Wasmtime cache\n            \n            [env: DISABLE_WASMTIME_CACHE=]\n\n        --follow <FOLLOW_ID>\n            Print output for given component(s) to stdout/stderr\n\n        --follow-all\n            Print all component output to stdout/stderr\n\n    -L, --log-dir <APP_LOG_DIR>\n            Log directory for the stdout and stderr of components\n\n        --listen <ADDRESS>\n            IP address and port to listen on\n            \n            [default: 127.0.0.1:3000]\n\n        --runtime-config-file <RUNTIME_CONFIG_FILE>\n            Configuration file for config providers and wasmtime config\n            \n            [env: RUNTIME_CONFIG_FILE=]\n\n        --tls-cert <TLS_CERT>\n            The path to the certificate to use for https, if this is not set, normal http will be\n            used. The cert should be in PEM format\n            \n            [env: SPIN_TLS_CERT=]\n\n        --tls-key <TLS_KEY>\n            The path to the certificate key to use for https, if this is not set, normal http will\n            be used. The key should be in PKCS#8 format","url":"/common/cli-reference.md#http-request-handler"},{"project":"common","title":"Contributing to Docs","subheading":"","content":"undefinedundefinedThank you for your interest in contributing to the Fermyon documentation. Below are a few pointers designed to help you contribute.","url":"/common/contributing-docs"},{"project":"common","title":"Contributing to Docs","subheading":"Technical Documentation Types","content":"The following points will help guide your contribution from a resource-type perspective; essentially we would really appreciate you creating and contributing any of the following 4 resource types.","url":"/common/contributing-docs.md#technical-documentation-types"},{"project":"common","title":"Contributing to Docs","subheading":"1. Tutorials","content":"Tutorials are oriented toward learning. Tutorials are designed to get a user started on something new (that they have not tried before). You can think of a tutorial as a lesson i.e. teaching a Spin user undefined. The tutorial may contain many logically ordered steps i.e. installing Spin, installing Redis, using Spin templates, configuring a Spin application and so forth. The desired outcome for a tutorial is for the user to have a working deployment or application. Think of it as a lesson in how to bake a cake.","url":"/common/contributing-docs.md#1-tutorials"},{"project":"common","title":"Contributing to Docs","subheading":"2. How-To Guides","content":"How-to guides are oriented towards showing a user how to solve a problem, which leads them to be able to achieve their own goal. The how-to guide will follow a series of logical steps. Think of it as providing a recipe for the user's creativity. For example, you can show a user how to undefined without telling them what the application must do; that is up to the user's imagination.","url":"/common/contributing-docs.md#2-howto-guides"},{"project":"common","title":"Contributing to Docs","subheading":"3. Reference","content":"Reference resources are merely a dry description; describing the feature in its simplest form. A great example of a reference resource is the undefined. You will notice that the CLI Reference page simply lists all of the commands and available options.","url":"/common/contributing-docs.md#3-reference"},{"project":"common","title":"Contributing to Docs","subheading":"4. Explanation","content":"An explanation resource is written using a deep-dive approach i.e. providing a deep explanation with the view to impart a deep understanding of a particular concept, feature or product. You may find your contribution is so in-depth that it becomes a long form article like a blog post. If that is the case, please get in touch and we can discuss options around getting your content published on another platform; like the undefined.undefinedYou will notice that the menu system is organized in terms of \"Tutorial\", \"How-To\", \"Reference\" and so forth. When you write your contribution please decide which product (Cloud, Spin, Bartholomew) category it falls into and also which resource type it aligns with. Armed with that information you can go ahead and create your new file. For example, your \"how-to\" resource on \"developing a Spin application\" in Fermyon cloud would be saved to the content/cloud/ folder; specifically, content/cloud/develop.md and the menu item (for the left-hand-side menu) would be added to the templates/cloud_sidebar.hbs file, as shown below.undefinedThe resulting output would be as follows.undefined","url":"/common/contributing-docs.md#4-explanation"},{"project":"common","title":"Contributing to Docs","subheading":"Technical Documentation Procedure","content":"The following steps will assist you to contribute from a technical standpoint.","url":"/common/contributing-docs.md#technical-documentation-procedure"},{"project":"common","title":"Contributing to Docs","subheading":"1. Fork the Repository","content":"The first step is to fork the undefined, from Fermyon's GitHub, to your own GitHub account.undefinedEnsure that you are forking the developer repository undefined GitHub account; where you have full editing privileges.","url":"/common/contributing-docs.md#1-fork-the-repository"},{"project":"common","title":"Contributing to Docs","subheading":"2. Clone the Fork","content":"Copy the URL from the UI in readiness for running the git clone command.undefinedGo ahead and clone the new fork that you just created (the one which resides in your own GitHub account):$ cd ~\n$ git clone git@github.com:yourusername/developer.git\n$ cd developer","url":"/common/contributing-docs.md#2-clone-the-fork"},{"project":"common","title":"Contributing to Docs","subheading":"3. Create New Branch","content":"Create a new branch that will house all of your changes for this specific contribution:$ git checkout -b my_new_branch","url":"/common/contributing-docs.md#3-create-new-branch"},{"project":"common","title":"Contributing to Docs","subheading":"4. Add Upstream","content":"Create a new remote for the upstream (a pointer to the original repository to which you are contributing):$ git remote add upstream https://github.com/fermyon/developer","url":"/common/contributing-docs.md#4-add-upstream"},{"project":"common","title":"Contributing to Docs","subheading":"5. Code Blocks, Annotations and Table of Contents (ToC)","content":"It is highly recommended that you use either the <!-- @selectiveCpy --> or the <!-- @nocpy --> annotation before each of your code blocks, and that each code block defines the appropriate undefined. The annotation can be skipped for code blocks with example code snippets i.e. non-terminal or generic output examples.The selective copy annotation (<!-- @selectiveCpy -->) is intended for use when communicating code and/or CLI commands for the reader to copy and paste. The selective copy annotation allows the reader to see the entire code block (both commands and results) but only copies the lines that start with $ into the reader's clipboard (minus the $) when the user clicks the copy button. For example, copying the following code block will only copy echo \"hello\" into your clipboard, for pasting.$ echo \"hello\"\nhelloundefinedThe no copy annotation (<!-- @nocpy -->) precedes a code block where no copy and pasting of code is intended. If using the no copy attribute please still be sure to add the appropriate syntax highlighting to your code block (for display purposes). For example:<!-- @nocpy -->Some generic code not intended for copying/pastingundefinedIf you create content with many headings it is highly recommended to place a ToC in your markdown file. There are excellent extensions (such as this Visual Studio Code Extension called undefined which will automatically generate your ToC).","url":"/common/contributing-docs.md#5-code-blocks-annotations-and-table-of-contents-toc"},{"project":"common","title":"Contributing to Docs","subheading":"6. Check Content","content":"Once you are satisfied with your contribution, you can programmatically check your content.If you have not done so already, please go ahead and perform the npm install command; to enable Node dependencies such as markdownlint-cli2. Simply run the following command, from the root of the developer repository:$ npm installWith all Node dependencies installed, you can now check for broken links and also lint your markdown files. Simply run the following command, from the root of the developer repository:$ npm test","url":"/common/contributing-docs.md#6-check-content"},{"project":"common","title":"Contributing to Docs","subheading":"7. Add Changes","content":"Once your changes have been checked, go ahead and add your changes by moving to a top-level directory, under which your changes exist i.e. cd ~/developer.Add your changes by running the following command, from the root of the developer repository:$ git add","url":"/common/contributing-docs.md#7-add-changes"},{"project":"common","title":"Contributing to Docs","subheading":"8. Commit Changes","content":"Before committing, please ensure that your GitHub installation is configured sufficiently so that you can --signoff as part of the git commit command. For example, please ensure that the user.name and user.email are configured in your terminal. You can check if these are set by typing git config --list.If you need to set these values please use the following commands:$ git config user.name \"yourusername\"$ git config user.email \"youremail@somemail.com\"More information can be found at this GitHub documentation page called undefined.Type the following commit command to ensure that you sign off (--signoff), sign the data (-S) - recommended, and also leave a short message (-m):$ git commit -S --signoff -m \"Updating documentation\"undefined","url":"/common/contributing-docs.md#8-commit-changes"},{"project":"common","title":"Contributing to Docs","subheading":"9. Push Changes","content":"At this stage, it is a good idea to just quickly check what GitHub thinks the origin is. For example, if we type git remote -v we can see that the origin is our repo; which we a) forked the original repo into and b) which we then cloned to our local disk so that we could edit:$ git remote -vThe above command will return output similar to the following:origin\tgit@github.com:yourusername/developer.git (fetch)\norigin\tgit@github.com:yourusername/developer.git (push)\nupstream\thttps://github.com/fermyon/developer (fetch)\nupstream\thttps://github.com/fermyon/developer (push)Once you are satisfied go ahead and push your changes:$ git push -u origin my_new_branch","url":"/common/contributing-docs.md#9-push-changes"},{"project":"common","title":"Contributing to Docs","subheading":"10. Create a Pull Request","content":"If you return to your GitHub repository in your browser, you will notice that a PR has automatically been generated for you.Clicking on the green “Compare and pull request” button will allow you to add a title and description as part of the PR.undefinedYou can also add any information in the textbox provided below the title. For example, screen captures and/or code/console/terminal snippets of your contribution working correctly and/or tests passing etc.Once you have finished creating your PR, please keep an eye on the PR; answering any questions as part of the collaboration process.undefinedThanks for contributing.","url":"/common/contributing-docs.md#10-create-a-pull-request"},{"project":"robots.md","title":"Untitled","subheading":"","content":"This is the robots.txt file. It is autogenerated","url":"/robots"},{"project":"sitemap.md","title":"Sitemap XML file","subheading":"","content":"This is the autogenerated sitemap. Note that the suffix .xml is replaced with .md by Bartholomew","url":"/sitemap"},{"project":"spin","title":"Spin Architecture and Internals","subheading":"","content":"This document aims to offer an overview to the implementation of Spin, as well\nas explain how the code is structured and how all parts fit together. This\ndocument is continuously evolving, and if you want even more detailed\ninformation, make sure to review the code for a given part of Spin.","url":"/spin/architecture"},{"project":"spin","title":"Spin Architecture and Internals","subheading":"How Spin Runs an Application","content":"A Spin application is defined as a spin.toml file. It can either be run\ndirectly by spin up, passing the manifest file (--file spin.toml), or it can\nbe pushed to the registry then referenced using its remote ID\n(spin bindle push followed by spin up --bindle <id>).Regardless of the application origin (local file or remote reference from the\nregistry), a Spin application is defined by\nspin_manifest::Application (contained in the\nundefined crate),\nwhich is the canonical representation of a Spin application.The crate responsible for transforming a custom configuration into a canonical\nSpin application is undefined,\nwhich implements loading applications from local spin.toml files and from\nremote Bindle references (and ensures files referenced in the application\nconfiguration are copied and mounted at the location expected in the WebAssembly\nmodule). Once the canonical representation is loaded from an application source,\nit is passed to a trigger.The HTTP trigger (defined in the spin-http crate) takes an\napplication configuration (undefined\nexplores a trigger handling multiple applications), starts an HTTP listener, and\nfor each new request, it routes it to the component configured in the\napplication configuration. Then, it instantiates the WebAssembly module (using a\nspin_engine::ExecutionContext) and uses the appropriate executor (either the\nSpinHttpExecutor or the WagiHttpExecutor, based on the component\nconfiguration) to handle the request and return the response.","url":"/spin/architecture.md#how-spin-runs-an-application"},{"project":"spin","title":"Spin Architecture and Internals","subheading":"The Spin Execution Context","content":"The Spin execution context (or \"Spin engine\") is the part of Spin that executes\nWebAssembly components using the\nundefined WebAssembly runtime. It\nis implemented in the spin-engine crate, and serves as\nthe part of Spin that takes a fully formed application configuration and creates\nWasm instances based on the component configurations.There are two important concepts in this crate:undefinedundefined","url":"/spin/architecture.md#the-spin-execution-context"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"","content":"Spin applications are comprised of general information (metadata), and a collection\nof at least one undefined. Configuration for a Spin application lives in a TOML\nfile called spin.toml (the undefined). In the example below we can see\na simple HTTP application with a single component executed when the /hello endpoint\nis accessed:spin_version = \"1\"\nname = \"spin-hello-world\"\ndescription = \"A simple application that returns hello world.\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"hello\"\ndescription = \"A simple component that returns hello world.\"\nsource = \"target/wasm32-wasi/release/spinhelloworld.wasm\"\n[component.trigger]\nroute = \"/hello\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"","url":"/spin/configuration"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Application Manifest Reference","content":"","url":"/spin/configuration.md#application-manifest-reference"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Application Configuration","content":"The following are the fields supported by the spin.toml manifest file:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","url":"/spin/configuration.md#application-configuration"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Component Configuration","content":"Each component object has the following fields:undefinedundefinedundefinedundefinedundefinedundefinedundefinedundefinedundefined","url":"/spin/configuration.md#component-configuration"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Custom Configuration","content":"Spin applications may define custom configuration which can be looked up by\ncomponent code via the undefined.","url":"/spin/configuration.md#custom-configuration"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Custom Config Variables","content":"Application-global custom config variables are defined in the top-level [variables]\nsection. These entries aren't accessed directly by components, but are referenced\nby undefined value templates. Each entry must\neither have a default value or be marked as required = true. \"Required\" entries\nmust be undefined with a value.Configuration keys may only contain lowercase letters and underscores between letters.[variables]\napi_host = { default = \"api.example.com\" }\napi_key = { required = true }","url":"/spin/configuration.md#custom-config-variables"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Component Custom Config","content":"The configuration entries available to a component are listed in its\n[component.config] section. Configuration values may reference\nundefined with simple\nundefined-inspired string templates.[[component]]\n# ...\n[component.config]\napi_base_url = \"https://{{ api_host }}/v1\"\napi_key = \"{{ api_key }}\"","url":"/spin/configuration.md#component-custom-config"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Custom Config Providers","content":"undefined values may be set at runtime by\nconfig \"providers\". Currently, there are two providers: the environment\nvariable provider and vault config provider.","url":"/spin/configuration.md#custom-config-providers"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Environment Variable Provider","content":"The environment variable provider which gets config values from the spin process's\nenvironment (undefined the component environment). Config keys are translated\nto environment variables by upper-casing and prepending with SPIN_APP_:$ export SPIN_APP_API_KEY = \"1234\"  # Sets the `api_key` value.\n$ spin up","url":"/spin/configuration.md#environment-variable-provider"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Vault Config Provider","content":"The Vault config provider gets secret values from undefined.\nCurrently, only undefined is supported.\nYou can set up v2 kv secret engine at any mount point and give Vault information in the undefined file:[[config_provider]]\ntype = \"vault\"\nurl = \"http://127.0.0.1:8200\"\ntoken = \"root\"\nmount = \"secret\"","url":"/spin/configuration.md#vault-config-provider"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Vault Config Provider Example","content":"undefinedundefined$ vault server -dev -dev-root-token-id rootundefined$ export VAULT_TOKEN=root\n$ export VAULT_ADDR=http://127.0.0.1:8200\n$ vault kv put secret/password value=\"test_password\"\n$ vault kv get secret/passwordundefinedundefined$ spin build\n$ spin up --runtime-config-file runtime_config.tomlundefined$ curl -i http://127.0.0.1:3000\nHTTP/1.1 200 OK\ncontent-length: 26\ndate: Tue, 18 Oct 2022 12:34:40 GMT\n\nGot password test_password","url":"/spin/configuration.md#vault-config-provider-example"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Runtime Configuration","content":"Runtime configuration contains config provider information like undefined.\nYou can use the runtime configuration by giving --runtime-config-file in spin up command.","url":"/spin/configuration.md#runtime-configuration"},{"project":"spin","title":"Configuration for Spin Applications","subheading":"Examples","content":"undefined[[component]]\nsource = \"modules/spin_static_fs.wasm\"\nid = \"fileserver\"\nfiles = [ { source = \"static/\", destination = \"/\" } ]\n[component.trigger]\nroute = \"/static/...\"undefined[[component]]\nsource = { url = \"https://github.com/fermyon/spin-fileserver/releases/download/v0.0.1/spin_static_fs.wasm\", digest = \"sha256:650376c33a0756b1a52cad7ca670f1126391b79050df0321407da9c741d32375\" }\nid = \"fileserver\"\nfiles = [ { source = \"static/\", destination = \"/\" } ]\n[component.trigger]\nroute = \"/static/...\"undefined[[component]]\nsource = \"modules/env_wagi.wasm\"\nid = \"env\"\nfiles = [ \"content/**/*\" , \"templates/*\", \"scripts/*\", \"config/*\"]\n[component.trigger]\nroute = \"/...\"\nexecutor = { type = \"wagi\", argv = \"test ${SCRIPT_NAME} ${ARGS} done\", entrypoint = \"some-other-export-function\" }undefined[[component]]\nid = \"echo-message\"\nsource = \"spinredis.wasm\"\n[component.trigger]\nchannel = \"messages\"","url":"/spin/configuration.md#examples"},{"project":"spin","title":"Contributing to Spin","subheading":"","content":"We are delighted that you are interested in making Spin better! Thank you! This\ndocument will guide you through making your first contribution to the project.First, any contribution and interaction on any Fermyon project MUST follow our\nundefined. Thank you for being\npart of an inclusive and open community!\nWe welcome and appreciate contributions of all types — opening issues, fixing\ntypos, adding examples, one-liner code fixes, tests, or complete features.If you plan on contributing anything complex, please go through the issue and PR\nqueues first to make sure someone else has not started working on it. If it\ndoesn't exist already, please open an issue so you have a chance to get feedback\nfrom the community and the maintainers before you start working on your feature.","url":"/spin/contributing-spin"},{"project":"spin","title":"Contributing to Spin","subheading":"Making Code Contributions to Spin","content":"The following guide is intended to make sure your contribution can get merged as\nsoon as possible. First, make sure you have the following prerequisites\nconfigured:undefinedundefinedundefinedundefinedundefinedundefinedOnce you have set up the prerequisites and identified the contribution you want\nto make to Spin, make sure you can correctly build the project:# clone the repository\n$ git clone https://github.com/fermyon/spin && cd spin\n# add a new remote pointing to your fork of the project\n$ git remote add fork https://github.com/<your-username>/spin\n# create a new branch for your work\n$ git checkout -b <your-branch>\n\n# if you are making a documentation contribution,\n# you can skip compiling and running the tests.\n\n# build a release version of the Spin CLI\n$ cargo build --release\n# make sure compilation is successful\n$ ./target/release/spin --help\n\n# run the tests and make sure they pass\n$ make testNow you should be ready to start making your contribution. To familiarize\nyourself with the Spin project, please read the\nundefined. Since most of Spin is implemented in\nRust, we try to follow the common Rust coding conventions (keep an eye on the\nrecommendations from Clippy!) If applicable, add unit or integration tests to\nensure your contribution is correct.Build the project and run the tests (make build test), and if everything is\nsuccessful, you should be ready to commit your changes. We try to follow the\nundefined\nguidelines for writing commit messages:$ git commit -S -s -m \"<your commit message that follows https://www.conventionalcommits.org/en/v1.0.0/>\"We try to only keep useful changes as separate commits — if you prefer to commit\noften, please\nundefined\nbefore opening a pull request. Once you are happy with your changes you can push\nthe branch to your fork:# \"fork\" is the name of the git remote pointing to your fork\n$ git push forkNow you are ready to create a pull request. Thank you for your contribution","url":"/spin/contributing-spin.md#making-code-contributions-to-spin"},{"project":"spin","title":"Deploying Spin Applications to Fermyon","subheading":"","content":"undefined is the frictionless WebAssembly platform for deploying\nmicroservices and web apps. With Fermyon, you can deploy your spin applications onto a server in\nmoments.For instructions guiding you through running the Fermyon platform on your development workstation,\nfollow undefined.For instructions guiding you through running the Fermyon platform on AWS, follow\nundefined.","url":"/spin/deploying-to-fermyon"},{"project":"spin","title":"Developing Spin Applications","subheading":"","content":"The Spin CLI offers a few commands to simplify developing applications.","url":"/spin/developing"},{"project":"spin","title":"Developing Spin Applications","subheading":"Building Spin Applications","content":"A Spin application is made up of one or more components. When developing a\nmulti-component application, it is very common to have multiple directories with\nsource code for components — and when making changes to components, having to\nmanually go into the each component directory, compile the component, then go\nback to the directory with spin.toml can be a very repetitive task.This is why Spin has a top-level command that will execute the build command\nset by each component, spin up:[component.build]\ncommand = \"cargo build --target wasm32-wasi --release --manifest-path http-rust/Cargo.toml\"Then, running spin build will execute, sequentially, each build command:$ RUST_LOG=spin=trace spin build\n2022-04-25T03:01:56.721630Z  INFO spin_build: Executing the build command for component rust-hello.\n    Finished release [optimized] target(s) in 0.05s\n2022-04-25T03:01:56.832360Z  INFO spin_build: Executing the build command for component rust-static-assets.\n    Finished release [optimized] target(s) in 0.02s\n2022-04-25T03:01:56.905424Z  INFO spin_build: Executing the build command for component rust-outbound-http.\n    Finished release [optimized] target(s) in 0.02sThe spin build command is intended to offer a built-in way to build more complex\nSpin applications without needing a separate build process.\nIt is not intended to replace complex build scripts — if\nyou have existing automated ways for building source code, those can be used\ninstead, or the build command can call that process.spin build --up can be used to start the application after the build process\nfinishes for all application components.","url":"/spin/developing.md#building-spin-applications"},{"project":"spin","title":"Developing Spin Applications","subheading":"Component  workdir","content":"By default, the command to build a component is executed in the manifest's\ndirectory. This can be changed. For example, assume a component is located in\nsubdirectory deep:.\n├── deep\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n└── spin.tomlTo run the build command in directory deep, set the component's workdir:[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"\nworkdir = \"deep\"Note that workdir must be a relative path and it operates relative to the\nspin.toml. Specifying an absolute path leads to an error.","url":"/spin/developing.md#component-workdir"},{"project":"spin","title":"Packaging and Distributing Spin Applications","subheading":"","content":"","url":"/spin/distributing-apps"},{"project":"spin","title":"Packaging and Distributing Spin Applications","subheading":"Distributing Spin Applications Using Container Registry Services","content":"Starting with undefined, Spin supports distributing applications using existing container registry services such as GitHub Container Registry, Docker Hub, Azure ACR, or AWS ECR. This feature is experimental, and will continue to evolve in future versions of Spin.While this feature is still in experimental phase, the CLI will reuse the container registry authentication used by the Docker CLI, so you first have to log in to the registry service using an existing tool (such as docker login, or using the instructions provided by the registry service). In a future version this will be improved using a Spin login command for the target registry.Pushing an application to a registry:$ spin oci push ghcr.io/radu-matei/spin-hello-world:v1\nPushed \"https://ghcr.io/v2/radu-matei/spin-hello-world/manifests/sha256:06b19f4394c59fe943140c9b59f083aefd4b53c6b632758523a2800d819a1575\"Then running the application using the registry reference:$ spin oci run ghcr.io/radu-matei/spin-hello-world:v1This feature is built on top of the undefined.","url":"/spin/distributing-apps.md#distributing-spin-applications-using-container-registry-services"},{"project":"spin","title":"Packaging and Distributing Spin Applications","subheading":"Signing Spin Applications and Verifying Signatures","content":"Since Spin is now using existing container registries to distribute applications, it can also take advantage of the state of the art in terms of signing and verifying artifacts distributed using OCI registries. Here is an example of signing and verifying a Spin application using undefined:# Push your Spin application to any registry that supports OCI Artifacts,\n# such as the GitHub Container Registry, Docker Hub, Azure ACR, or AWS ECR.\n$ spin oci push ghcr.io/radu-matei/spin-hello-world:v1\nPushed \"https://ghcr.io/v2/radu-matei/spin-hello-world/manifests/sha256:06b19\"\n\n# You can now sign your Spin app using Cosign (or any other tool that can sign OCI objects)\n$ COSIGN_EXPERIMENTAL=1 cosign sign ghcr.io/radu-matei/spin-hello-world@sha256:06b19\nGenerating ephemeral keys...\nRetrieving signed certificate...\ntlog entry created with index: 12519542\nPushing signature to: ghcr.io/radu-matei/spin-hello-world\n\n# You can use cosign to now verify the signature before running the application.\n$ COSIGN_EXPERIMENTAL=1 cosign verify ghcr.io/radu-matei/spin-hello-world@sha256:06b19\nVerification for ghcr.io/radu-matei/spin-hello-world@sha256:06b19 --\nThe following checks were performed on each of these signatures:\n  - The cosign claims were validated\n  - Existence of the claims in the transparency log was verified offline\n  - Any certificates were verified against the Fulcio roots.\n\n# You can now point Spin to the application in the registry and run it.\n$ spin oci run ghcr.io/radu-matei/spin-hello-world:v1","url":"/spin/distributing-apps.md#signing-spin-applications-and-verifying-signatures"},{"project":"spin","title":"Packaging and Distributing Spin Applications","subheading":"Distributing Spin Applications Using Bindle","content":"Packaging and distributing Spin applications can be done using undefined, an open source aggregate object storage system. This allows the packaging of the application manifest, components, and static assets together, and takes advantage of the features of a modern object storage system.To distribute applications, we first need a Bindle registry. You can undefined, or use the undefined VS Code extension (through the Bindle: Start command):$ bindle-server --address 127.0.0.1:8000 --directory . --unauthenticatedLet's push the application from the undefined to the registry:$ export BINDLE_URL=http://localhost:8000/v1\n$ spin bindle push --file spin.toml\npushed: spin-hello-world/1.0.0Now we can run the application using spin up directly from the registry:$ spin up --bindle spin-hello-world/1.0.0undefinedThe application can also be prepared in a local directory before pushing to the registry by running spin bindle prepare.","url":"/spin/distributing-apps.md#distributing-spin-applications-using-bindle"},{"project":"spin","title":"Extending and Embedding Spin","subheading":"","content":"undefinedSpin currently implements triggers and application models for:undefinedundefinedThe Spin internals and execution context (the part of Spin executing\ncomponents) are agnostic of the event source and application model.\nIn this document we will explore how to extend Spin with custom event sources\n(triggers) and application models built on top of the WebAssembly component\nmodel, as well as how to embed Spin in your application.In this article we will build a Spin trigger to run the applications based on a\ntimer, executing Spin components at configured time interval.The current application types that can be implemented with Spin have entry points\ndefined using\nundefined:// The entry point for an HTTP handler.\nhandle-http-request: function(req: request) -> response\n\n// The entry point for a Redis handler.\nhandle-redis-message: function(msg: payload) -> expected<_, error>The entry point we want to execute for our timer trigger takes a string as its\nonly argument (the trigger will populate that with the current date and time),\nand it expects a string as the only return value. This is purposefully chosen\nto be a simple function signature:// examples/spin-timer/spin-timer.wit\nhandle-timer-request: function(msg: string) -> stringThis is the function that all components executed by the timer trigger must\nimplement, and which is used by the timer executor when instantiating and\ninvoking the component.Let's have a look at building the timer trigger:// examples/spin-timer/src/main.rs\nwit_bindgen_wasmtime::import!({paths: [\"spin-timer.wit\"], async: *});\ntype ExecutionContext = spin_engine::ExecutionContext<spin_timer::SpinTimerData>;\n\n/// A custom timer trigger that executes a component on every interval.\n#[derive(Clone)]\npub struct TimerTrigger {\n    /// The interval at which the component is executed.\n    pub interval: Duration,\n    /// The Spin execution context.\n    engine: Arc<ExecutionContext>,\n}A few important things to note from the start:undefinedundefinedundefinedFinally, whenever there is a new event (in the case of our timer-based trigger\nevery n seconds), we execute the entry point of a selected component:/// Execute the first component in the application manifest.\nasync fn handle(&self, msg: String) -> Result<()> {\n    // create a new Wasmtime store and instance based on the first component's WebAssembly module.\n    let (mut store, instance) =\n        self.engine\n            .prepare_component(&self.app.components[0].id, None, None, None, None)?;\n\n    // spawn a new thread and call the entry point function from the WebAssembly module \n    let res = spawn_blocking(move || -> Result<String> {\n            // use the auto-generated WIT bindings to get the Wasm exports and call the `handle-timer-request` function.\n        let t = spin_timer::SpinTimer::new(&mut store, &instance, |host| {\n            host.data.as_mut().unwrap()\n        })?;\n        Ok(t.handle_timer_request(&mut store, &msg)?)\n    })\n    .await??;\n    // do something with the result.\n    log::info!(\"{}\\n\", res);\n    Ok(())\n}A few notes:undefinedundefinedundefinedThis is very similar to how the undefined and undefined\ntriggers are implemented, and it is the recommended way to extend Spin with your\nown trigger and application model.Writing components for the new trigger can be done by using the\nundefined from\nRust and other supported languages (see undefined):// automatically generate Rust bindings that help us implement the \n// `handle-timer-request` function that the trigger will execute.\nwit_bindgen_rust::export!(\"../spin-timer.wit\");\n...\nfn handle_timer_request(msg: String) -> String {\n    format!(\"ECHO: {}\", msg)\n}Components can be compiled to WebAssembly, then used from a spin.toml\napplication manifest.Embedding the new trigger in a Rust application is done by creating a new trigger\ninstance, then calling its run function:// app() is a utility function that generates a complete application configuration.\nlet trigger = TimerTrigger::new(Duration::from_secs(1), app()).await?;\n// run the trigger indefinitely\ntrigger.run().awaitundefinedIn this example, we built a simple timer trigger — building more complex triggers\nwould also involve updating the Spin application manifest, and extending\nthe application-level trigger configuration, as well as component-level\ntrigger configuration (an example of component-level trigger configuration\nfor this scenario would be each component being able to define its own\nindependent time interval for scheduling the execution).","url":"/spin/extending-and-embedding"},{"project":"spin","title":"Extending and Embedding Spin","subheading":"Other Ways to Extend and Use Spin","content":"Besides building custom triggers, the internals of Spin could also be used\nindependently:undefinedundefined","url":"/spin/extending-and-embedding.md#other-ways-to-extend-and-use-spin"},{"project":"spin","title":"Building Spin components in Go","subheading":"","content":"undefined is an implementation of the\nundefined for embedded systems and WebAssembly.\nThe Spin SDK for Go uses\nundefined\nto build programs written in Go as Spin components.undefinedundefined","url":"/spin/go-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Versions","content":"TinyGo 0.25.x is recommended, which requires Go 1.16.x or newer.undefined","url":"/spin/go-components.md#versions"},{"project":"spin","title":"Building Spin components in Go","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Go has improved support for\nwriting applications, through its SDK.Building a Spin HTTP component using the Go SDK means writing a single function,\ninit — below is a complete implementation for such a component:// A Spin component written in Go that returns \"Hello, Fermyon!\"\npackage main\n\nimport (\n \"fmt\"\n \"net/http\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n  w.Header().Set(\"Content-Type\", \"text/plain\")\n  fmt.Fprintln(w, \"Hello Fermyon!\")\n })\n}\n\nfunc main() {}The important things to note in the implementation above:undefinedundefinedundefined","url":"/spin/go-components.md#http-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound requests to HTTP endpoints. Let's\nsee an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:// A Spin component written in Go that sends a request to an API\n// with random dog facts.\n\npackage main\n\nimport (\n \"bytes\"\n \"fmt\"\n \"net/http\"\n \"os\"\n\n spinhttp \"github.com/fermyon/spin/sdk/go/http\"\n)\n\nfunc init() {\n spinhttp.Handle(func(w http.ResponseWriter, r *http.Request) {\n  r, _ := spinhttp.Get(\"https://some-random-api.ml/facts/dog\")\n\n  fmt.Fprintln(w, r.Body)\n  fmt.Fprintln(w, r.Header.Get(\"content-type\"))\n\n  // `spin.toml` is not configured to allow outbound HTTP requests to this host,\n  // so this request will fail.\n  if _, err := spinhttp.Get(\"https://fermyon.com\"); err != nil {\n   fmt.Fprintf(os.Stderr, \"Cannot send HTTP request: %v\", err)\n  }\n })\n}\n\nfunc main() {}The component can be built using the tingygo toolchain:$ tinygo build -wasm-abi=generic -target=wasi -no-debug -o main.wasm main.goBefore we can execute this component, we need to add the\nsome-random-api.ml domain to the application manifest allowed_http_hosts\nlist containing the list of domains the component is allowed to make HTTP\nrequests to:# spin.toml\nspin_version = \"1\"\nname = \"spin-hello-tinygo\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"tinygo-hello\"\nsource = \"main.wasm\"\nallowed_http_hosts = [ \"some-random-api.ml\" ]\n[component.trigger]\nroute = \"/hello\"undefinedRunning the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /hello:$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\ncontent-type: text/plain; charset=utf-8\nserver: spin/0.1.0\ncontent-length: 85\ndate: Fri, 18 Mar 2022 23:27:33 GMT\n\n{{\"fact\":\"Seventy percent of people sign their dog's name on their holiday cards.\"}}undefinedundefined","url":"/spin/go-components.md#sending-outbound-http-requests"},{"project":"spin","title":"Building Spin components in Go","subheading":"Redis Components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger, which\nwill connect to a Redis instance and will execute components for new messages\non the configured channels.undefinedWriting a Redis component in Go also takes advantage of the SDK:package main\n\nimport (\n \"fmt\"\n\n \"github.com/fermyon/spin/sdk/go/redis\"\n)\n\nfunc init() {\n // redis.Handle() must be called in the init() function.\n redis.Handle(func(payload []byte) error {\n  fmt.Println(\"Payload::::\")\n  fmt.Println(string(payload))\n  return nil\n })\n}\n\n// main function must be included for the compiler but is not executed.\nfunc main() {}The manifest for a Redis application must contain the address of the Redis instance:spin_version = \"1\"\nname = \"spin-redis\"\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"echo-message\"\nsource = \"main.wasm\"\n[component.trigger]\nchannel = \"messages\"\n[component.build]\ncommand = \"tinygo build -wasm-abi=generic -target=wasi -gc=leaking -no-debug -o main.wasm main.go\"The application will connect to redis://localhost:6379, and for every new message\non the messages channel, the echo-message component will be executed:# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin build --up\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component:INFO spin_redis_engine: Received message on channel \"messages\"\nPayload::::\nHello, there!","url":"/spin/go-components.md#redis-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Storing Data in Redis From Go Components","content":"Using the Spin's Go SDK, you can use the Redis key/value store to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Go SDK to connect to Redis:package main\n\nimport (\n \"net/http\"\n \"os\"\n\n spin_http \"github.com/fermyon/spin/sdk/go/http\"\n \"github.com/fermyon/spin/sdk/go/redis\"\n)\n\nfunc init() {\n // handler for the http trigger\n spin_http.Handle(func(w http.ResponseWriter, r *http.Request) {\n\n  // addr is the environment variable set in `spin.toml` that points to the\n  // address of the Redis server.\n  addr := os.Getenv(\"REDIS_ADDRESS\")\n\n  // channel is the environment variable set in `spin.toml` that specifies\n  // the Redis channel that the component will publish to.\n  channel := os.Getenv(\"REDIS_CHANNEL\")\n\n  // payload is the data publish to the redis channel.\n  payload := []byte(`Hello redis from tinygo!`)\n\n  if err := redis.Publish(addr, channel, payload); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // set redis `mykey` = `myvalue`\n  if err := redis.Set(addr, \"mykey\", []byte(\"myvalue\")); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n   return\n  }\n\n  // get redis payload for `mykey`\n  if payload, err := redis.Get(addr, \"mykey\"); err != nil {\n   http.Error(w, err.Error(), http.StatusInternalServerError)\n  } else {\n   w.Write([]byte(\"mykey value was: \"))\n   w.Write(payload)\n  }\n })\n}\n\nfunc main() {}This HTTP component demonstrates fetching a value from Redis by key, setting a\nkey with a value, and publishing a message to a Redis channel. The component is\ntriggered by an HTTP request served on the route configured in the spin.toml:[[component]]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\n[component.trigger]\nroute = \"/publish\"This HTTP component can be paired with a Redis component, triggered on new\nmessages on the messages Redis channel.undefined","url":"/spin/go-components.md#storing-data-in-redis-from-go-components"},{"project":"spin","title":"Building Spin components in Go","subheading":"Using Go Packages in Spin Components","content":"Any\nundefined that can be imported in TinyGo and that compiles to\nWASI can be used when implementing a Spin component.undefined","url":"/spin/go-components.md#using-go-packages-in-spin-components"},{"project":"spin","title":"The Spin HTTP Trigger","subheading":"","content":"An important workload in event-driven environments is represented by HTTP\napplications, and Spin has built-in support for creating and running HTTP\ncomponents. This document presents an overview of the HTTP trigger, as well as\nsome implementation details around the WebAssembly component model and how it\nis used in Spin.The HTTP trigger in Spin is a web server. It listens for incoming requests and\nbased on the undefined, it routes them to an\nundefined which instantiates the appropriate component, executes its\nentry point function, then returns an HTTP response.Creating an HTTP application is done when undefined\nby defining the top-level application trigger:# spin.toml\ntrigger = { type = \"http\", base = \"/\" }Then, when defining the component (in spin.toml), there are two pieces of\nconfiguration that can be set for the component trigger: the route,\nand the undefined (see details below about executors). For example:undefined[component.trigger]\nroute = \"/hello\"\nexecutor = { type = \"spin\" }undefined[component.trigger]\nroute = \"/goodbye\"\nexecutor = { type = \"wagi\" }","url":"/spin/http-trigger"},{"project":"spin","title":"The Spin HTTP Trigger","subheading":"Routing","content":"Routing an incoming request to a particular component is done using the\napplication base path (base in spin.toml) and the component defined routes\n(route in the component configuration) by prefixing the application base path\nto all component routes defined for that application.For example, if the application base path is base = /base, and a component\nhas defined route = /foo, that component will be executed for requests on\nhttp(s)://<spin-up-defined-address-and-port>/base/foo.Components can either define exact routes, for example route = /bar/baz, where\nthe component will be invoked only for requests on /base/bar/baz, or they\ncan define a wildcard as the last path segment, for example route = /bar/baz/...,\nwhich means the component will be invoked for every request starting with the\n/base/bar/baz/ prefix (such as /base/bar/baz, /base/bar/baz/qux,\n/base/bar/baz/qux/quux and so on).If multiple components could potentially handle the same request based on their\ndefined routes, the component whose route has the longest matching prefix\ntakes precedence.In the following example, any request starting with the  /foo/ prefix (e.g. /foo/bar)\nwill be handled by component-1:# spin.toml\n\ntrigger = { type = \"http\", base = \"/\"}\n\n[[component]]\nid = \"component-1\"\n[component.trigger]\nroute = \"/foo/...\"\n\n[[component]]\nid = \"component-2\"\n[component.trigger]\nroute = \"/...\"undefinedEvery HTTP application has a special route always configured at /.well-known/spin/health, which\nreturns OK 200 when the Spin instance is healthy.Once Spin selects a component to handle an incoming request based on the route\nconfiguration, it will instantiate and execute that component based on its\ndefined undefined, and the next sections explore the two ways of building\nHTTP components based on the two available executors.","url":"/spin/http-trigger.md#routing"},{"project":"spin","title":"The Spin HTTP Trigger","subheading":"The Spin HTTP Executor","content":"Spin is built on top of the\nundefined.\nWe undefined believe the component model represents the future of WebAssembly,\nand we are working with the undefined\ncommunity on building exciting new features and tools for it. As a result, the\nSpin HTTP undefined is defined using WebAssembly interfaces.undefinedWe define the HTTP objects as\nundefined\nobjects, currently using undefined:// wit/ephemeral/http-types.wit\n\n// The HTTP status code.\ntype http-status = u16\n// The HTTP body.\ntype body = list<u8>\n// The HTTP headers represented as a list of (name, value) pairs.\ntype headers = list<tuple<string, string>>\n// The HTTP parameter queries, represented as a list of (name, value) pairs.\ntype params = list<tuple<string, string>>\n// The HTTP URI of the current request.\ntype uri = string\n// The HTTP method.\nenum method { get, post, put,... }\n\n// An HTTP request.\nrecord request {\n    method: method,\n    uri: uri,\n    headers: headers,\n    params: params,\n    body: option<body>,\n}\n\n// An HTTP response.\nrecord response {\n    status: http-status,\n    headers: option<headers>,\n    body: option<body>,\n}undefinedThen, we define the entry point for a Spin HTTP component:// wit/ephemeral/spin-http.wit\n\nuse * from http-types\n// The entry point for an HTTP handler.\nhandle-http-request: function(req: request) -> responseThis is the function signature that all HTTP components must implement, and\nwhich is used by the Spin HTTP executor when instantiating and invoking the\ncomponent.\nThis interface (spin-http.wit) can be directly used together with the\nundefined\nto build a component that the Spin HTTP executor can invoke.\nThis is exactly how undefined is built, and,\nas more languages add support for the component model, how we plan to add\nsupport for them as well.","url":"/spin/http-trigger.md#the-spin-http-executor"},{"project":"spin","title":"The Spin HTTP Trigger","subheading":"The Wagi HTTP Executor","content":"The WebAssembly component model proposal is currently in its early stages, which\nmeans only a few programming languages fully implement it. While the language\ncommunities implement toolchain support for the component model (for emitting\ncomponents and for automatically generating bindings for importing other\ncomponents), we want to allow developers to use any language that compiles to\nWASI to build Spin HTTP applications. This is why Spin currently implements an\nHTTP executor based on undefined, or the\nWebAssembly Gateway Interface, a project that implements the\nundefined\nspecification for WebAssembly.undefinedWagi allows a module built in any programming language that compiles to undefined\nto handle an HTTP request by passing the HTTP request information to the module's\nstandard input, environment variables, and arguments, and expecting the HTTP\nresponses through the module's standard output.\nThis means that if a language has support for the WebAssembly System Interface,\nit can be used to build Spin HTTP components.\nThe Wagi model is only used to parse the HTTP request and response. Everything\nelse — defining the application, running it, or undefined\nis done the same way as a component that uses the Spin executor.Building a Wagi component in a particular programming language that can compile\nto wasm32-wasi does not require any special libraries — instead,\nundefined can\nbe done by reading the HTTP request from the standard input and environment\nvariables, and sending the HTTP response to the module's standard output.In pseudo-code, this is the minimum required in a Wagi component:undefinedundefinedundefinedprint(\"content-type: text/html; charset=UTF-8\\n\\n\");\nprint(\"hello world\\n\");The undefined supports the Spin executor.\nHere is another example, written in undefined,\na new programming language that natively targets WebAssembly:import Process from \"sys/process\";\nimport Array from \"array\";\n\nprint(\"content-type: text/plain\\n\");\n\n// This will print all the Wagi env variables\nprint(\"==== Environment: ====\");\nArray.forEach(print, Process.env());\n\n// This will print the route path followed by each query\n// param. So /foo?bar=baz will be [\"/foo\", \"bar=baz\"].\nprint(\"==== Args: ====\");\nArray.forEach(print, Process.argv());undefined","url":"/spin/http-trigger.md#the-wagi-http-executor"},{"project":"spin","title":"The Spin HTTP Trigger","subheading":"The Default Headers Set in Spin HTTP Components","content":"Spin sets a few default headers on the request based on the base path, component\nroute, and request URI, which will always be available when writing a module:undefinedundefinedundefinedundefinedundefinedundefined","url":"/spin/http-trigger.md#the-default-headers-set-in-spin-http-components"},{"project":"spin","title":"The Spin HTTP Trigger","subheading":"The Default Headers Set in Wagi HTTP Components","content":"For Wagi HTTP components, the following are set as environment variables for the\nhandler WebAssembly modules:undefinedundefinedundefinedundefinedundefinedundefinedBesides the headers above, components that use the Wagi executor also have set\nundefined.","url":"/spin/http-trigger.md#the-default-headers-set-in-wagi-http-components"},{"project":"spin","title":"Introducing Spin","subheading":"","content":"Spin is a framework for building and running event-driven microservice applications with WebAssembly (Wasm) components. With Spin, we’re trying to make it easier to get started with using WebAssembly on the server so that we can all take advantage of the security, portability, and speed WebAssembly provides when it comes to running microservices.undefined","url":"/spin/index"},{"project":"spin","title":"Introducing Spin","subheading":"Structure of a Spin Application","content":"undefinedundefinedSpin executes the component(s) as a result of events being generated by the trigger(s)\ndefined in the spin.toml file.","url":"/spin/index.md#structure-of-a-spin-application"},{"project":"spin","title":"Introducing Spin","subheading":"Example Spin Application","content":"The following illustrates how to define an HTTP application.","url":"/spin/index.md#example-spin-application"},{"project":"spin","title":"Introducing Spin","subheading":"HTTP Handler","content":"This hello_world function written in Rust defines a component that takes a Request and returns a Result<Response>.#[http_component]​\nfn hello_world(_req: Request) -> Result<Response> {​\n    Ok(http::Response::builder()​\n        .status(200)​\n        .body(Some(\"Hello, Fermyon!\".into()))?)​\n}​","url":"/spin/index.md#http-handler"},{"project":"spin","title":"Introducing Spin","subheading":"Spin Manifest","content":"Once the code is compiled to a WebAssembly component, it can be referenced in a spin.toml\nfile to create an HTTP application like what you can see below:spin_version = \"1\"\nname = \"spin-hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"hello\"\nsource = \"<path to compiled Wasm module>\"\n[component.trigger]\nroute = \"/hello\"","url":"/spin/index.md#spin-manifest"},{"project":"spin","title":"Introducing Spin","subheading":"Running a Spin Application","content":"Running this application with the spin CLI is as simple as using the spin up command.\nBecause a trigger type of http is specified in the spin.toml file, spin up will start\na web server:$ spin up\nServing HTTP on address http://127.0.0.1:3000\nAvailable Routes:\n  hello: http://127.0.0.1:3000/helloAny time a request is made on the /hello route, it will invoke the\nhello_world function. Adding another component is as simple as adding another [[component]]\nstanza to the spin.toml file.","url":"/spin/index.md#running-a-spin-application"},{"project":"spin","title":"Introducing Spin","subheading":"Deploying a Spin Application","content":"Spin applications can be deployed to the fully managed undefined, or using the self-hosted undefined","url":"/spin/index.md#deploying-a-spin-application"},{"project":"spin","title":"Introducing Spin","subheading":"Next Steps","content":"undefinedundefinedundefined","url":"/spin/index.md#next-steps"},{"project":"spin","title":"Install Spin","subheading":"","content":"","keywords":"install","url":"/spin/install"},{"project":"spin","title":"Install Spin","subheading":"Installing Spin","content":"Spin runs on Linux (amd64 and arm64), macOS (Intel and Apple Silicon), and Windows with WSL2 (amd64).{{ tabs \"os\" }}{{ startTab \"Linux\"}}There are multiple ways to install Spin. The easiest is to use the installer script, hosted on this site.$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashOn a fresh Linux installation, you will also need the standard build toolchain\n(gcc, make, etc.), the SSL library headers, and on some distributions you may need pkg-config.On Debian-like distributions, including Ubuntu, you can install these with a command like this.$ sudo apt-get install build-essential libssl-dev pkg-configIt's highly recommended to add Spin to a folder, which is on your path, e.g.:$ sudo mv spin /usr/local/bin/To install a specific version, you can pass arguments to the install script this way:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v v0.8.0To install the canary version of spin, you should pass the argument -v canary. The canary version is always the latest commit to the main branch of Spin.$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v canary{{ blockEnd }}{{ startTab \"macOS\"}}There are multiple ways to install Spin. The easiest is to use the installer script, hosted on this site.$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashIt's highly recommended to add Spin to a folder, which is on your path, e.g.:$ sudo mv spin /usr/local/bin/To install a specific version, you can pass arguments to the install script this way:$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v v0.8.0To install the canary version of spin, you should pass the argument -v canary. The canary version is always the latest commit to the main branch of Spin.$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bash -s -- -v canary{{ blockEnd }}{{ startTab \"Windows\"}}On Windows systems you can download undefined.Simply unzip the binary release and place the spin.exe in your system path.{{ blockEnd }}\n{{ blockEnd }}","keywords":"install","url":"/spin/install.md#installing-spin"},{"project":"spin","title":"Install Spin","subheading":"Building Spin From Source","content":"undefined for a detailed guide on building Spin from source:$ git clone https://github.com/fermyon/spin\n$ cd spin && make build\n$ ./target/release/spin --help","keywords":"install","url":"/spin/install.md#building-spin-from-source"},{"project":"spin","title":"Install Spin","subheading":"Using Cargo to Install Spin","content":"If you have undefined, you can clone the repo and install it to your path:$ git clone https://github.com/fermyon/spin -b v0.8.0\n$ cd spin\n$ rustup target add wasm32-wasi\n$ cargo install --locked --path .\n$ spin --help","keywords":"install","url":"/spin/install.md#using-cargo-to-install-spin"},{"project":"spin","title":"Install Spin","subheading":"Next Steps","content":"undefinedundefinedundefined","keywords":"install","url":"/spin/install.md#next-steps"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"","content":"With JavaScript being a very popular language, Spin provides support for building components with it using the experimental SDK. The development of the JavaScript SDK is continually being worked on to improve user experience and add features.undefinedundefinedIn order to compile JavaScript programs to Spin components, you also need to install a Spin plugin js2wasm using the following command:$ spin plugin update\n$ spin plugin install js2wasm","url":"/spin/javascript-components"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Installing Templates","content":"The JavaScript/TypeScript templates can be installed from undefined using the following command:$ spin templates install --git https://github.com/fermyon/spin-js-sdkwhich will install the http-js and http-ts templates.Copying remote template source\nInstalling template http-ts...\nInstalling template http-js...\nInstalled 2 template(s)\n\n+-------------------------------------------------+\n| Name      Description                           |\n+=================================================+\n| http-js   HTTP request handler using Javascript |\n| http-ts   HTTP request handler using Typescript |\n+-------------------------------------------------+","url":"/spin/javascript-components.md#installing-templates"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Structure of a JS/TS Component","content":"A new JS/TS component can be created using the following command:$ spin new http-ts hello-world --accept-defaultsThis creates a directory of the following structure:hello-world/\n├── package.json\n├── package-lock.json\n├── README.md\n├── spin.toml\n├── src\n│   └── index.ts\n├── tsconfig.json\n└── webpack.config.jsThe source for the component is present in src/index.ts. undefined is used to bundle the component into a single .js file which will then be compiled to a .wasm module using the js2wasm plugin.","url":"/spin/javascript-components.md#structure-of-a-jsts-component"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Building and Running the Template","content":"First, the dependencies for the template need to be installed and then bundled into a single JavaScript file using the following commands:$ cd hello-world\n$ npm install\n$ npm run buildOnce a Spin compatible module is created, it can be run using$ spin up","url":"/spin/javascript-components.md#building-and-running-the-template"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"A Quick Note About NPM Scripts","content":"Please note that using pre-built NPM scripts can have different effects on different Operating Systems (OSs). Let's take the npm run build command (like undefined) as an example:\"scripts\": {\n    \"build\": \"npx webpack --mode=production && mkdir -p target && spin js2wasm -o target/spin-http-js.wasm dist/spin.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  }The npm run build command will work on Linux and macOS. However, on Windows it will create both a -p directory and a target directory.On Linux/Unix systems, the -p option in the mkdir command is designed to prevent an error from occuring in the event that the target directory already exists. However, on Windows systems, npm (by default) uses cmd.exe which does not recognize the -p option, regarding its mkdir command.If you run npm run build on Windows (more than once) the following error will be encountered.A subdirectory or file -p already exists\nA Subdirectory or file target already existsIf any errors, as described above, occur please consider one of the two following options:a) Configure your instance of npm to use bash (by using the script-shell configuration setting):npm config set script-shell \"C:\\\\Program Files\\\\git\\\\bin\\\\bash.exe\"b) Run the separate parts of the build manually, to suite your needs (OS syntax requirements):npx webpack --mode=production\nspin js2wasm -o target/spin-http-js.wasm dist/spin.js","url":"/spin/javascript-components.md#a-quick-note-about-npm-scripts"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, and Javascript/TypeScript has improved support\nfor writing Spin components with the Spin JS/TS SDK.undefinedBuilding a Spin HTTP component using the JS/TS SDK means writing a single function\nthat takes an HTTP request as a parameter, and returns an HTTP response — below\nis a complete implementation for such a component in TypeScript:import { HandleRequest, HttpRequest, HttpResponse } from \"@fermyon/spin-sdk\"\n\nconst encoder = new TextEncoder()\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n\n    return {\n        status: 200,\n        headers: {\"foo\": \"bar\"},\n        body: encoder.encode(\"Hello from JS-SDK\").buffer\n    }\n}The important things to note in the implementation above:undefinedundefined","url":"/spin/javascript-components.md#http-components"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:import { HandleRequest, HttpRequest, HttpResponse } from \"@fermyon/spin-sdk\"\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n\n    const dogFact = await fetch(\"https://some-random-api.ml/facts/dog\")\n\n    const dogFactBody = await dogFact.text()\n\n    const env = JSON.stringify(process.env)\n\n    const body = `Here's a dog fact: ${dogFactBody}\\n`\n\n    return {\n        status: 200,\n        headers: { \"foo\": \"bar\" },\n        body: encoder.encode(body).buffer\n    }\n}Before we can execute this component, we need to add the some-random-api.ml\ndomain to the application manifest allowed_http_hosts list containing the list of\ndomains the component is allowed to make HTTP requests to:# spin.toml\nspin_version = \"1\"\nauthors = [\"Fermyon Engineering <engineering@fermyon.com>\"]\nname = \"spin-http-js\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[variables]\nobject = { default = \"teapot\" }\n\n[[component]]\nid = \"hello\"\nsource = \"target/spin-http-js.wasm\"\nallowed_http_hosts = [\"https://some-random-api.ml\"]\n[component.trigger]\nroute = \"/hello\"\n[component.build]\ncommand = \"npm run build\"The component can be built using the spin build command. Running the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /hello:$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\ndate: Fri, 18 Mar 2022 03:54:36 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nserver: spin/0.1.0\n\nHere's a dog fact: {\"fact\":\"It's a myth that dogs only see in black and white. In fact, it's believed that dogs see primarily in blue, greenish-yellow, yellow and various shades of gray.\"}undefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.","url":"/spin/javascript-components.md#sending-outbound-http-requests"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Storing Data in Redis From JS/TS Components","content":"undefinedUsing the Spin's JS SDK, you can use the Redis key/value store and to publish messages to Redis channels.Let's see how we can use the JS/TS SDK to connect to Redis:import { HandleRequest, HttpRequest, HttpResponse } from \"@fermyon/spin-sdk\"\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nconst redisAddress = \"redis://localhost:6379/\"\n\nexport const handleRequest: HandleRequest = async function (request: HttpRequest): Promise<HttpResponse> {\n\n    spinSdk.redis.incr(redisAddress, \"test\")\n    spinSdk.redis.incr(redisAddress, \"test\")\n\n    console.log(decoder.decode(spinSdk.redis.get(redisAddress, \"test\")))\n\n    spinSdk.redis.set(redisAddress, \"test-set\", encoder.encode(\"This is a test\").buffer)\n\n    console.log(decoder.decode(spinSdk.redis.get(redisAddress, \"test-set\")))\n\n    spinSdk.redis.publish(redisAddress, \"test\", encoder.encode(\"This is a test\").buffer)\n\n    return {\n        status: 200,\n        headers: {\"foo\": \"bar\"},\n        body: encoder.encode(\"Hello from JS-SDK\").buffer\n    }\n}This HTTP component demonstrates fetching a value from Redis by key, setting a key with a value, and publishing a message to a Redis channel. The component is triggered by an HTTP request served on the route configured in the spin.toml:undefined","url":"/spin/javascript-components.md#storing-data-in-redis-from-jsts-components"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Using External NPM Libraries","content":"undefinedSome NPM packages can be installed and used in the component. If a popular library does not work, please open an issue/feature request in the undefined.","url":"/spin/javascript-components.md#using-external-npm-libraries"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Suggested Libraries for Common Tasks","content":"These are some of the suggested libraries that have been tested and confired to work with the SDK for common tasks.{{ details \"Parsing formdata\" \"- undefined\" }}{{ details \"Unique ID generator\" \"- undefined\\n- undefined\\n- undefined\" }}","url":"/spin/javascript-components.md#suggested-libraries-for-common-tasks"},{"project":"spin","title":"Building Spin Components in JavaScript","subheading":"Caveats","content":"undefinedundefinedundefined","url":"/spin/javascript-components.md#caveats"},{"project":"spin","title":"Building Spin components in other languages","subheading":"","content":"undefinedundefinedWebAssembly is becoming undefined, and as language toolchains add support for the\nundefined,\nbuilding Spin components will also become supported.As a general rule:undefinedundefinedundefinedundefined","url":"/spin/other-languages"},{"project":"spin","title":"Building Spin components in other languages","subheading":"AssemblyScript","content":"undefined is a TypeScript-based language that compiles directly to WebAssembly.\nAssemblyScript has WASI/Wagi support, and so can be used with Spin.undefinedundefinedundefined","url":"/spin/other-languages.md#assemblyscript"},{"project":"spin","title":"Building Spin components in other languages","subheading":"C/C++","content":"C and C++ are both broadly supported in the WebAssembly ecosystem. WASI/Wagi support means that both can be used to write Spin apps.undefinedundefinedundefined","url":"/spin/other-languages.md#cc"},{"project":"spin","title":"Building Spin components in other languages","subheading":"C# and .NET Languages","content":".NET has experimental support for WASI, so many (if not all) .NET languages, including C# and F#, can be used to write Spin applications.undefinedundefined","url":"/spin/other-languages.md#c-and-net-languages"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Grain","content":"undefined, a new functional programming language, has WASI/Wagi support and can be used to write Spin apps.undefinedundefinedundefined","url":"/spin/other-languages.md#grain"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Python","content":"Python's interpreter can be compiled to WebAssembly, and it has WASI support. It is known to work for Spin.undefinedundefinedundefinedundefinedundefined","url":"/spin/other-languages.md#python"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Ruby","content":"Upstream undefined officially supports WebAssembly and WASI, and we here at Fermyon have successfully run Ruby apps in Spin.undefinedundefined","url":"/spin/other-languages.md#ruby"},{"project":"spin","title":"Building Spin components in other languages","subheading":"Zig","content":"Zig is a low-level systems language that has support for Wasm and WASI, and can be used to write Spin apps.undefinedundefined","url":"/spin/other-languages.md#zig"},{"project":"spin","title":"Creating Spin Plugins","subheading":"","content":"Spin plugins add new functionality or subcommands to Spin without modifying the\nSpin codebase. They make Spin easily extensible while keeping it lightweight.\nSpin plugins can add new triggers to Spin (such as the undefined),\nenable new language SDKs (such as\nundefined),\nand more.This document will cover what Spin plugins are, how to use a plugin, and how to\ncreate a plugin.","url":"/spin/plugin-authoring"},{"project":"spin","title":"Creating Spin Plugins","subheading":"What Are Spin Plugins?","content":"A Spin plugin is an executable that is added to Spin's plugins directory\n($XDG_DATA_HOME/spin/plugins) upon a spin plugins install <plugin-name>. The\nplugin is then ready to be used. If the plugin is an extension to the Spin CLI,\nit can now be executed directly as a subcommand: spin <plugin-name>. If the\nplugin is a trigger plugin, it will be executed during spin up when an app\nusing that trigger is run.While for now plugins are assumed to be executables, in the future, support for\nplugging in WebAssembly modules may be desirable.","url":"/spin/plugin-authoring.md#what-are-spin-plugins"},{"project":"spin","title":"Creating Spin Plugins","subheading":"How to Find and Use a Spin Plugin","content":"Spin maintains a centralized catalogue of available Spin plugins in the undefined. During plugin\ninstallation, if it does not already exist, Spin fetches the remote catalogue\nand creates a local snapshot. To ensure that the local snapshot is up to date,\nit is best to run spin plugins update before installing any plugins.To list available plugins, run spin plugins list. Now, decide which plugin to\ninstall. For example, the js2wasm plugin, which is needed in order to build\nJavaScript Spin applications, can be installed by running:$ spin plugins install js2wasmWith the plugin installed, you can now call spin js2wasm to run it. In this\ncase, for example, you might call it from your JavaScript application's npm\nbuild script. Learn more about building Spin components in JavaScript\nundefined.To upgrade installed plugins to newer versions, run spin plugin update to\nfetch the latest plugins to the local catalogue and spin plugin upgrade to perform the\nupgrade on the installed plugins.","url":"/spin/plugin-authoring.md#how-to-find-and-use-a-spin-plugin"},{"project":"spin","title":"Creating Spin Plugins","subheading":"Authoring a Spin Plugin","content":"Spin plugins are implemented as a manifest that points to one or more .tar.gz archives which contain the plugin executables. So, to create a plugin you must:undefinedundefined","url":"/spin/plugin-authoring.md#authoring-a-spin-plugin"},{"project":"spin","title":"Creating Spin Plugins","subheading":"Packaging a Plugin","content":"After creating your plugin executable, package it along with its license as a\ntar.gz archive. Note that the name field in the plugin manifest must match\nboth the binary and license name. See the undefined\nfor more details on naming conventions.Refer to the aptly named undefined for an\nexample of how to build a plugin.","url":"/spin/plugin-authoring.md#packaging-a-plugin"},{"project":"spin","title":"Creating Spin Plugins","subheading":"Creating a Spin Plugin Manifest","content":"A Spin plugin manifest is a JSON file that conforms to the undefined.\nA manifest defines a plugin’s name, version, license, homepage (i.e. GitHub\nrepo), compatible Spin version, and gives a short description of the plugin. It\nalso lists the URLs of the tar archives of the plugin for various operating\nsystems and platforms. The URL can point to the local path to the file by using\nthe file scheme file://, for example, file:///tmp/my-plugin.tar.gz.To ensure your plugin manifest is valid, follow the steps in the undefined.","url":"/spin/plugin-authoring.md#creating-a-spin-plugin-manifest"},{"project":"spin","title":"Creating Spin Plugins","subheading":"Installing a Local Plugin","content":"By default, Spin will look in the plugins catalogue for a plugin. However, when\ndeveloping and testing a plugin, it is unlikely to be in the the catalogue. For\nboth installs and upgrades, the --file or --url flags can be used to point\nto specific local or remote plugin manifests. For example, a local manifest\ncalled practice.json can be installed and run as follows:$ spin plugin install --file practice.json\n$ spin practice","url":"/spin/plugin-authoring.md#installing-a-local-plugin"},{"project":"spin","title":"Creating Spin Plugins","subheading":"Contributing a Plugin","content":"If you think the community would benefit from your newly created plugin, create\na PR to add it to the undefined!","url":"/spin/plugin-authoring.md#contributing-a-plugin"},{"project":"spin","title":"Taking Spin for a spin","subheading":"","content":"undefined","keywords":"quickstart","url":"/spin/quickstart"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Getting the  spin  Binary","content":"You can install the spin binary using the install.sh script hosted on this site.$ curl -fsSL https://developer.fermyon.com/downloads/install.sh | bashAt this point, move the spin binary somewhere in your path, so it can be\naccessed from any directory. For example:$ sudo mv ./spin /usr/local/bin/spinMore ways to undefined","keywords":"quickstart","url":"/spin/quickstart.md#getting-the-spin-binary"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Creating a New Spin Application From a Template","content":"Spin helps you create a new application based on templates:$ spin templates list\nYou have no templates installed. Run\nspin templates install --git https://github.com/fermyon/spin\nto install a starter set.We first need to configure the undefined:$ spin templates install --git https://github.com/fermyon/spin\nCopying remote template source\nInstalling template redis-rust...\nInstalling template http-rust...\nInstalling template http-go...\n+--------------------------------------------------+\n| Name         Description                         |\n+==================================================+\n| http-go      HTTP request handler using (Tiny)Go |\n| http-rust    HTTP request handler using Rust     |\n| redis-rust   Redis message handler using Rust    |\n| ...                                              |\n+--------------------------------------------------+undefinedLet's create a new Spin application based on the Rust HTTP template:$ spin new\nPick a template to start your project with:\n  http-c (HTTP request handler using C and the Zig toolchain)\n  http-csharp (HTTP request handler using C# (EXPERIMENTAL))\n  http-go (HTTP request handler using (Tiny)Go)\n  http-grain (HTTP request handler using Grain)\n> http-rust (HTTP request handler using Rust)\n  http-swift (HTTP request handler using SwiftWasm)\n  http-zig (HTTP request handler using Zig)\n  redis-go (Redis message handler using (Tiny)Go)\n  redis-rust (Redis message handler using Rust)\n\nEnter a name for your new project: hello_rust\nProject description: My first Rust Spin application\nHTTP base: /\nHTTP path: /...\n$ tree\n├── .cargo\n│   └── config.toml\n├── .gitignore\n├── Cargo.toml\n├── spin.toml\n└── src\n    └── lib.rsThis command created all the necessary files we need to build and run our first\nSpin application. Here is spin.toml, the manifest file for a Spin application:spin_version = \"1\"\ndescription = \"A simple Spin HTTP component in Rust\"\nname = \"spin-hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"spin-hello-world\"\nsource = \"target/wasm32-wasi/release/spin_hello_world.wasm\"\n[component.trigger]\nroute = \"/hello\"\n[component.build]\ncommand = \"cargo build --target wasm32-wasi --release\"This represents a simple Spin HTTP application (triggered by an HTTP request), with\na single component called spin-hello-world. Spin will execute the spin_hello_world.wasm\nWebAssembly module for HTTP requests on the route /hello.\n(See the undefined for a detailed guide on the Spin\napplication manifest.)Now let's have a look at the code. Below is the complete source\ncode for a Spin HTTP component written in Rust — a regular Rust function that\ntakes an HTTP request as a parameter and returns an HTTP response, and it is\nannotated with the http_component macro:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn spin_hello_world(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req.headers());\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Fermyon\".into()))?)\n}undefinedFor Rust templates you need to install the wasm32-wasi target using rustup:$ rustup target add wasm32-wasi\ninfo: downloading component 'rust-std' for 'wasm32-wasi'\ninfo: installing component 'rust-std' for 'wasm32-wasi'\n 19.8 MiB /  19.8 MiB (100 %)  11.5 MiB/s in  1s ETA:  0sFor TinyGo templates you need the undefined.We can build this component using the regular Rust toolchain, targeting\nwasm32-wasi, which will produce the WebAssembly module and place it at\ntarget/wasm32-wasi/release/spinhelloworld.wasm as referenced in the\nspin.toml. For convenience, we can use the spin build command, which will\nexecute the command defined above in spin.toml and call the Rust toolchain:$ spin build\nExecuting the build command for component spin-hello-world: cargo build --target wasm32-wasi --release\n   Compiling spin_hello_world v0.1.0\n    Finished release [optimized] target(s) in 0.10s\nSuccessfully ran the build command for the Spin components.undefinedundefinedIf you run into errors, you might want to use rustup check to see if your Rust installation is up-to-date.","keywords":"quickstart","url":"/spin/quickstart.md#creating-a-new-spin-application-from-a-template"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Running the Application With  spin up","content":"Now that we configured the application and built our component, we can undefined\nthe application (pun intended):$ spin up\nServing HTTP on address http://127.0.0.1:3000\nAvailable Routes:\n  spin-hello-world: http://127.0.0.1:3000/helloOptionally, set the RUST_LOG environment variable for detailed logs, before running spin up.export RUST_LOG=spin=traceSpin will instantiate all components from the application manifest, and\nwill create the router configuration for the HTTP trigger accordingly. The\ncomponent can now be invoked by making requests to http://localhost:3000/hello\n(see route field in the configuration):$ curl -i localhost:3000/hello\nHTTP/1.1 200 OK\nfoo: bar\ncontent-length: 15\n\nHello, Fermyon!You can add as many components as needed in spin.toml, mount files and\ndirectories, allow granular outbound HTTP connections, or set environment variables\n(see the undefined for a detailed guide on\nthe Spin application manifest) and iterate locally with\nspin up --file spin.toml until you are ready to distribute the application.Congratulations! You just completed building and running your first Spin\napplication!\nNext, check out the undefined or undefined language\nguides, or have a look at undefined.","keywords":"quickstart","url":"/spin/quickstart.md#running-the-application-with-spin-up"},{"project":"spin","title":"Taking Spin for a spin","subheading":"Next Steps","content":"undefinedundefined","keywords":"quickstart","url":"/spin/quickstart.md#next-steps"},{"project":"spin","title":"The Spin Redis trigger","subheading":"","content":"Spin applications can be triggered by a new message on a undefined.\nSpin will connect to a configured Redis instance and will invoke components for\nnew messages on the configured channels.undefinedThe Redis instance address is specified in the application trigger:# spin.toml\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }undefinedThen, all components in the application are triggered when new messages are\npublished to channels in the instance. undefined the channel\nis done by setting the channel field in the component trigger configuration.[component.trigger]\nchannel = \"messages\"","url":"/spin/redis-trigger"},{"project":"spin","title":"The Spin Redis trigger","subheading":"The WebAssembly Interface","content":"The Redis trigger is built on top of the\nundefined.\nThe current interface is defined using the\nundefined\nformat, and is a function that takes the message payload as its only parameter:// wit/ephemeral/spin-redis.wit\n\n// The message payload.\ntype payload = list<u8>\n\n// The entry point for a Redis handler.\nhandle-redis-message: function(msg: payload) -> expected<_, error>undefinedThis is the function that all Redis components must implement, and which is\nused by the Spin Redis executor when instantiating and invoking the component.\nThis interface (spin-redis.wit) can be directly used together with the\nundefined\nto build a component that the Spin HTTP executor can invoke.\nThis is exactly how undefined is built, and,\nas more languages add support for the component model, how we plan to add\nsupport for them as well.undefined","url":"/spin/redis-trigger.md#the-webassembly-interface"},{"project":"spin","title":"Building Spin components in Rust","subheading":"","content":"Spin aims to have best-in-class support for building components in Rust, and\nwriting such components should be familiar for Rust developers.undefinedundefinedIn order to compile Rust programs to Spin components, you also need the\nwasm32-wasi target. You can add it using rustup:$ rustup target add wasm32-wasi","url":"/spin/rust-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"HTTP Components","content":"In Spin, HTTP components are triggered by the occurrence of an HTTP request, and\nmust return an HTTP response at the end of their execution. Components can be\nbuilt in any language that compiles to WASI, but Rust has improved support\nfor writing Spin components with the Spin Rust SDK.undefinedBuilding a Spin HTTP component using the Rust SDK means writing a single function\nthat takes an HTTP request as a parameter, and returns an HTTP response — below\nis a complete implementation for such a component:use anyhow::Result;\nuse spin_sdk::{\n    http::{Request, Response},\n    http_component,\n};\n\n/// A simple Spin HTTP component.\n#[http_component]\nfn hello_world(req: Request) -> Result<Response> {\n    println!(\"{:?}\", req);\n    Ok(http::Response::builder()\n        .status(200)\n        .header(\"foo\", \"bar\")\n        .body(Some(\"Hello, Fermyon!\".into()))?)\n}The important things to note in the implementation above:undefinedundefinedundefined","url":"/spin/rust-components.md#http-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Sending Outbound HTTP Requests","content":"If allowed, Spin components can send outbound HTTP requests.\nLet's see an example of a component that makes a request to\nundefined and\ninserts a custom header into the response before returning:#[http_component]\nfn hello_world(_req: Request) -> Result<Response> {\n    let mut res = spin_sdk::http::send(\n        http::Request::builder()\n            .method(\"GET\")\n            .uri(\"https://some-random-api.ml/facts/dog\")\n            .body(None)?,\n    )?;\n\n    res.headers_mut()\n        .insert(http::header::SERVER, \"spin/0.1.0\".try_into()?);\n\n    Ok(res)\n}Before we can execute this component, we need to add the some-random-api.ml\ndomain to the application manifest allowed_http_hosts list containing the list of\ndomains the component is allowed to make HTTP requests to:# spin.toml\nspin_version = \"1\"\nname = \"spin-hello-world\"\ntrigger = { type = \"http\", base = \"/\" }\nversion = \"1.0.0\"\n\n[[component]]\nid = \"hello\"\nsource = \"target/wasm32-wasi/release/spinhelloworld.wasm\"\nallowed_http_hosts = [ \"some-random-api.ml\" ]\n[component.trigger]\nroute = \"/outbound\"Running the application using spin up --file spin.toml will start the HTTP\nlistener locally (by default on localhost:3000), and our component can\nnow receive requests in route /outbound:$ curl -i localhost:3000/outbound\nHTTP/1.1 200 OK\ndate: Fri, 18 Mar 2022 03:54:36 GMT\ncontent-type: application/json; charset=utf-8\ncontent-length: 185\nserver: spin/0.1.0\n\n{\"fact\":\"It's rumored that, at the end of the Beatles song, \n\\\"A Day in the Life,\\\" Paul McCartney recorded an ultrasonic whistle, \naudible only to dogs, just for his Shetland sheepdog.\"}undefinedundefinedWe just built a WebAssembly component that sends an HTTP request to another\nservice, manipulates that result, then responds to the original request.\nThis can be the basis for building components that communicate with external\ndatabases or storage accounts, or even more specialized components like HTTP\nproxies or URL shorteners.","url":"/spin/rust-components.md#sending-outbound-http-requests"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Redis Components","content":"Besides the HTTP trigger, Spin has built-in support for a Redis trigger —\nwhich will connect to a Redis instance and will execute Spin components for\nnew messages on the configured channels.undefinedWriting a Redis component in Rust also takes advantage of the SDK:use anyhow::Result;\nuse bytes::Bytes;\nuse spin_sdk::redis_component;\n\n/// A simple Spin Redis component.\n#[redis_component]\nfn on_message(message: Bytes) -> Result<()> {\n    println!(\"{}\", std::str::from_utf8(&message)?);\n    Ok(())\n}undefinedundefinedundefinedThe component can be built with Cargo by executing:$ cargo build --target wasm32-wasi --releaseThe manifest for a Redis application must contain the address of the Redis\ninstance the trigger must connect to:spin_version = \"1\"\nname = \"spin-redis\"\ntrigger = { type = \"redis\", address = \"redis://localhost:6379\" }\nversion = \"0.1.0\"\n\n[[component]]\nid = \"echo-message\"\nsource = \"target/wasm32-wasi/release/spinredis.wasm\"\n[component.trigger]\nchannel = \"messages\"This application will connect to redis://localhost:6379, and for every new\nmessage on the messages channel, the echo-message component will be executed.# first, start redis-server on the default port 6379\n$ redis-server --port 6379\n# then, start the Spin application\n$ spin up --file spin.toml\n# the application log file will output the following\nINFO spin_redis_engine: Connecting to Redis server at redis://localhost:6379\nINFO spin_redis_engine: Subscribed component 0 (echo-message) to channel: messagesFor every new message on the  messages channel:$ redis-cli\n127.0.0.1:6379> publish messages \"Hello, there!\"Spin will instantiate and execute the component we just built, which will emit the println! message to the application log file:INFO spin_redis_engine: Received message on channel \"messages\"\nHello, there!If you would also like to see the println! messages echoed to the console as they happen, please include the additional --follow-all option, when starting the spin application. For example:spin up --file spin.toml --follow-allundefined","url":"/spin/rust-components.md#redis-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Storing Data in Redis From Rust Components","content":"Using the Spin's Rust SDK, you can use the Redis key/value store and to publish\nmessages to Redis channels. This can be used from both HTTP and Redis triggered\ncomponents.Let's see how we can use the Rust SDK to connect to Redis:use anyhow::{anyhow, Result};\nuse spin_sdk::{\n    http::{internal_server_error, Request, Response},\n    http_component, redis,\n};\n\n// The environment variable set in `spin.toml` that points to the\n// address of the Redis server that the component will publish\n// a message to.\nconst REDIS_ADDRESS_ENV: &str = \"REDIS_ADDRESS\";\n\n// The environment variable set in `spin.toml` that specifies\n// the Redis channel that the component will publish to.\nconst REDIS_CHANNEL_ENV: &str = \"REDIS_CHANNEL\";\n\n/// This HTTP component demonstrates fetching a value from Redis\n/// by key, setting a key with a value, and publishing a message\n/// to a Redis channel. The component is triggered by an HTTP\n/// request served on the route configured in the `spin.toml`.\n#[http_component]\n\nfn publish(_req: Request) -> Result<Response> {\n    let address = std::env::var(REDIS_ADDRESS_ENV)?;\n    let channel = std::env::var(REDIS_CHANNEL_ENV)?;\n\n    // Get the message to publish from the Redis key \"mykey\"\n    let payload = redis::get(&address, \"mykey\").map_err(|_| anyhow!(\"Error querying Redis\"))?;\n\n    // Set the Redis key \"spin-example\" to value \"Eureka!\"\n    redis::set(&address, \"spin-example\", &b\"Eureka!\"[..])\n        .map_err(|_| anyhow!(\"Error executing Redis set command\"))?;\n\n    // Set the Redis key \"int-key\" to value 0\n    redis::set(&address, \"int-key\", format!(\"{:x}\", 0).as_bytes())\n        .map_err(|_| anyhow!(\"Error executing Redis set command\"))?;\n    let int_value = redis::incr(&address, \"int-key\")\n        .map_err(|_| anyhow!(\"Error executing Redis incr command\",))?;\n    assert_eq!(int_value, 1);\n\n    // Publish to Redis\n    match redis::publish(&address, &channel, &payload) {\n        Ok(()) => Ok(http::Response::builder().status(200).body(None)?),\n        Err(_e) => internal_server_error(),\n    }\n}This HTTP component demonstrates fetching a value from Redis by key, setting a\nkey with a value, and publishing a message to a Redis channel. The component is\ntriggered by an HTTP request served on the route configured in the spin.toml:[[component]]\nenvironment = { REDIS_ADDRESS = \"redis://127.0.0.1:6379\", REDIS_CHANNEL = \"messages\" }\n[component.trigger]\nroute = \"/publish\"This HTTP component can be paired with a Redis component, triggered on new\nmessages on the messages Redis channel.undefined","url":"/spin/rust-components.md#storing-data-in-redis-from-rust-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Using External Crates in Rust Components","content":"In Rust, Spin components are regular libraries that contain a function\nannotated using the http_component macro, compiled to the\nundefined.\nThis means that any undefined that compiles to wasm32-wasi can\nbe used when implementing the component.","url":"/spin/rust-components.md#using-external-crates-in-rust-components"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Troubleshooting","content":"Sometimes things can go wrong, especially such early projects. If you bump into\nissues building and running your Rust component:undefinedundefinedundefinedundefinedundefined","url":"/spin/rust-components.md#troubleshooting"},{"project":"spin","title":"Building Spin components in Rust","subheading":"Manually Creating New Projects With Cargo","content":"The recommended way of creating new Spin projects is by starting from a template.\nThis section shows how to  manually create a new project with Cargo.When creating a new Spin projects with Cargo, you should use the --lib flag.$ cargo init --libA Cargo.toml with standard Spin dependencies looks like this:[package]\nname = \"your-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\n# Required to have a `cdylib` (dynamic library) to produce a Wasm module.\ncrate-type = [ \"cdylib\" ]\n\n[dependencies]\n# Useful crate to handle errors.\nanyhow = \"1\"\n# Crate to simplify working with bytes.\nbytes = \"1\"\n# General-purpose crate with common HTTP types.\nhttp = \"0.2\"\n# The Spin SDK.\nspin-sdk = { git = \"https://github.com/fermyon/spin\" }\n# Crate that generates Rust Wasm bindings from a WebAssembly interface.\nwit-bindgen-rust = { git = \"https://github.com/bytecodealliance/wit-bindgen\", rev = \"cb871cfa1ee460b51eb1d144b175b9aab9c50aba\" }At the time of this writing, wit-bindgen must be pinned to a specific rev.\nThis will change in the future.","url":"/spin/rust-components.md#manually-creating-new-projects-with-cargo"},{"project":"spin","title":"Creating Spin templates","subheading":"","content":"Spin templates allow a Spin developer to quickly create the skeleton of an\napplication or component, ready for the application logic to be filled in.A template consists of two directories, content and metadata.undefinedundefinedFor examples of the directory contents, see the templates directory in the\nundefined.Templates must always be shared in a templates directory.  This allows the\ninstaller to locate them in repos that contain other content.","url":"/spin/template-authoring"},{"project":"spin","title":"Creating Spin templates","subheading":"Authoring the Content","content":"Copy all the files that you want to be copied as part of the template into\nthe content directory. If you do nothing more, they will be copied\nverbatim. Often, though, you'll want to allow the user to put their own\nvalues in - for example, a project name, or a HTTP route.To do this, replace the text you want the user to be able to substitute\nwith an expression of the form {{parameter-name}}, where parameter-name\nis an identifier of your choice.  undefined - see below.You can reuse a parameter in more than one place - it will be prompted for\nonly once and will get the same value in each place.You can also transform the user value by specifying a filter after a bar:\n{{parameter-name | filter-name}}.  This is particularly useful when you\nwant to conform to specific language conventions. The following filters\nare supported:| Name          | Effect |\n|---------------|--------|\n| kebab_case  | Transforms input into kebab case, e.g. My Application to my-application |\n| snake_case  | Transforms input into snake case, e.g. My Application to my_application |\n| pascal_case | Transforms input into Pascal case, e.g. my appplication to MyApplication |","url":"/spin/template-authoring.md#authoring-the-content"},{"project":"spin","title":"Creating Spin templates","subheading":"Authoring the Manifest","content":"The template manifest is a TOML file. It must be named spin-template.toml.manifest_version = \"1\"\nid = \"my-application\"\ndescription = \"An application\"\n\n[parameters]\n# Example parameter\nproject-name = { type = \"string\", prompt = \"Project name\" }undefinedundefinedundefinedThe parameters table is where you list the placeholders that you edited\ninto your content for the user to substitute. You should include an entry\nfor each parameter. The key is the parameter name, and the value a JSON\ndocument that contains at minimum a type and prompt.  type must\ncurrently be string.  prompt is displayed when prompting the user\nfor the value to substitute.The document may also have a default, which will be displayed to the user\nand can be accepted by pressing Enter. It may also specify constraints\non what the user is allowed to enter. The following constraints are\nsupported:| Key           | Value and usage |\n|---------------|-----------------|\n| pattern     | A regular expression. The user input must match the regular expression to be accepted. |","url":"/spin/template-authoring.md#authoring-the-manifest"},{"project":"spin","title":"Creating Spin templates","subheading":"Supporting  spin add","content":"The spin add command lets users add your template as a new component in\nan existing application. If you'd like to support this, you'll need to\nadd a few items to your metadata.undefinedundefined| Key             | Value and usage |\n|-----------------|-----------------|\n| snippets      | A subtable with an entry named component, whose value is the name of the file containing the component manifest template. (Don't include the snippets directory prefix - Spin knows to look in the snippets directory.) |\n| skip_files    | Optional array of content files that should undefined be copied when running in \"add component\" mode. For example, if your template contains a spin.toml file, you should use this setting to exclude that, because you want to add a new entry to the existing file, not overwrite it. |\n| skip_parameters | Optional array of parameters that Spin should undefined prompt for when running in \"add component\" mode. For example, the HTTP templates don't prompt for the base path, because that's defined at the application level, not set on an individual component. |Here is an example add_component table from a HTTP template:[add_component]\nskip_files = [\"spin.toml\"]\nskip_parameters = [\"http-base\"]\n[add_component.snippets]\ncomponent = \"component.txt\"undefined","url":"/spin/template-authoring.md#supporting-spin-add"},{"project":"spin","title":"Creating Spin templates","subheading":"Hosting Templates in Git","content":"You can publish templates in a Git repo.  The templates must be in the /templates\ndirectory, with a subdirectory per template.When a user installs templates from your repo, by default Spin looks for a tag\nto identify a compatible version of the templates.  This tag is of the\nform spin/templates/vX.Y, where X is the major version, and Y the minor\nversion, of the user's copy of Spin. For example, if the user is on\nSpin 0.3.1, templates will be installed from spin/templates/v0.3.  If this\ntag does not exist, Spin installs templates from HEAD.","url":"/spin/template-authoring.md#hosting-templates-in-git"},{"project":"spin","title":"Building a URL shortener with Spin","subheading":"","content":"This tutorial will walk you through building a Spin component that\nredirects short URLs to their configured destinations.\nIn essence, this is a simple HTTP component that returns a response that contains\nredirect information based on the user-defined routes.This is an evolving tutorial. As Spin allows building more complex components\n(through supporting access to services like databases), this tutorial will be\nupdated to reflect that.undefinedFirst, our URL shortener allows users to configure their own final URLs —\ncurrently, that is done through a configuration file that contains multiple\n[[route]] entries, each containing the shortened path as source, and\nthe destination URL:[[route]]\nsource = \"/spin\"\ndestination = \"https://github.com/fermyon/spin\"\n\n[[route]]\nsource = \"/hype\"\ndestination = \"https://www.fermyon.com/blog/how-to-think-about-wasm\"Whenever a request for https://<domain>/spin is sent, our component will\nredirect to https://github.com/fermyon/spin. Now that we have a basic\nunderstanding of how the component should behave, let's see how to implement it\nusing Spin.First, we start with undefined:/// A Spin HTTP component that redirects requests \n/// based on the router configuration.\n#[http_component]\nfn redirect(req: Request) -> Result<Response> {\n    let router = Router::default()?;\n    router.redirect(req)\n}All the component does is create a new router based on the default configuration,\nthen use it to redirect the request. Let's see how the router is defined:#[derive(Debug, Deserialize, Serialize)]\npub struct Route {\n    pub source: String,\n    pub destination: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Router {\n    #[serde(rename = \"route\")]\n    pub routes: Vec<Route>,\n}The Router structure is a Rust representation of the TOML configuration above.pub fn redirect(self, req: Request) -> Result<Response> {\n    // read the request path from the `spin-path-info` header\n    let path_info = req\n        .headers()\n        .get(\"spin-path-info\")\n        .expect(\"cannot get path info from request headers\");\n    // if the path is not present in the router configuration,\n    // return 404 Not Found.\n    let route = match self.path(path_info.to_str()?) {\n        Some(r) => r,\n        None => return not_found(),\n    };\n    // otherwise, return the redirect to the destination\n    let res = http::Response::builder()\n        .status(http::StatusCode::PERMANENT_REDIRECT)\n        .header(http::header::LOCATION, route.destination)\n        .body(None)?;\n    Ok(res)\n}The redirect function is straightforward — it reads the request path from the\nspin-path-info header (make sure to read the undefined\nfor an overview of the HTTP headers present in Spin components), selects the\ncorresponding destination from the router configuration, then sends the\nHTTP redirect to the new location.At this point, we can build the module with cargo and run it with Spin:$ cargo build --target wasm32-wasi --release\n$ spin up --file spin.tomlAnd the component can now handle incoming requests:# based on the configuration file, a request\n# to /spin should be redirected\n$ curl -i localhost:3000/spin\nHTTP/1.1 308 Permanent Redirect\nlocation: https://github.com/fermyon/spin\ncontent-length: 0\n# based on the configuration file, a request\n# to /hype should be redirected\n$ curl -i localhost:3000/hype\nHTTP/1.1 308 Permanent Redirect\nlocation: https://www.fermyon.com/blog/how-to-think-about-wasm\ncontent-length: 0\n# /abc is not present in the router configuration,\n# so this returns a 404.\n$ curl -i localhost:3000/abc\nHTTP/1.1 404 Not Found\ncontent-length: 9\n\nNot FoundundefinedWe can now undefined (together\nwith router configuration file):$ spin bindle push --file spin.toml\npushed: url-shortener/1.0.0And now we can run the application directly from the registry:$ spin up --bindle url-shortener/1.0.0In this tutorial we built a simple URL shortener as a Spin component.\nIn the future we will expand this tutorial by storing the router configuration\nin a database supported by Spin, and potentially create another component that\ncan be used to add new routes to the configuration.","url":"/spin/url-shortener"}]